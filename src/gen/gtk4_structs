quote
$(Expr(:toplevel, quote
    begin
        gboxed_types = Any[]
    end
    begin
        nothing
        mutable struct GtkBitset <: GBoxed
            handle::Ptr{GtkBitset}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkBitset) = begin
                        ccall(("gtk_bitset_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkBitset(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkBitset)
            end
        end
        nothing
    end
    begin
        nothing
        mutable struct GtkBitsetIter
            handle::Ptr{GtkBitsetIter}
        end
        nothing
    end
    begin
        struct _GtkBorder
            left::Int16
            right::Int16
            top::Int16
            bottom::Int16
        end
        mutable struct GtkBorder <: GBoxed
            handle::Ptr{GtkBorder}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkBorder) = begin
                        ccall(("gtk_border_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkBorder(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkBorder)
            end
        end
        function Base.getproperty(s::GtkBorder, sym::Symbol)
            if sym === :handle
                return getfield(s, :handle)
            elseif sym in fieldnames(_GtkBorder)
                u = unsafe_load(Ptr{_GtkBorder}(s.handle))
                return getfield(u, sym)
            end
        end
    end
    begin
        nothing
        mutable struct GtkBuildableParseContext
            handle::Ptr{GtkBuildableParseContext}
        end
        nothing
    end
    begin
        nothing
        mutable struct GtkBuildableParser
            handle::Ptr{GtkBuildableParser}
        end
        nothing
    end
    begin
        struct _GtkCssLocation
            bytes::UInt64
            chars::UInt64
            lines::UInt64
            line_bytes::UInt64
            line_chars::UInt64
        end
        mutable struct GtkCssLocation
            handle::Ptr{GtkCssLocation}
        end
        function Base.getproperty(s::GtkCssLocation, sym::Symbol)
            if sym === :handle
                return getfield(s, :handle)
            elseif sym in fieldnames(_GtkCssLocation)
                u = unsafe_load(Ptr{_GtkCssLocation}(s.handle))
                return getfield(u, sym)
            end
        end
    end
    begin
        nothing
        mutable struct GtkCssSection <: GBoxed
            handle::Ptr{GtkCssSection}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkCssSection) = begin
                        ccall(("gtk_css_section_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkCssSection(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkCssSection)
            end
        end
        nothing
    end
    begin
        nothing
        mutable struct GtkCssStyleChange
            handle::Ptr{GtkCssStyleChange}
        end
        nothing
    end
    begin
        nothing
        mutable struct GtkExpressionWatch <: GBoxed
            handle::Ptr{GtkExpressionWatch}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkExpressionWatch) = begin
                        ccall(("gtk_expression_watch_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkExpressionWatch(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkExpressionWatch)
            end
        end
        nothing
    end
    begin
        struct _GtkPadActionEntry
            type::Int32
            index::Int32
            mode::Int32
            label::Ptr{UInt8}
            action_name::Ptr{UInt8}
        end
        mutable struct GtkPadActionEntry
            handle::Ptr{GtkPadActionEntry}
        end
        function Base.getproperty(s::GtkPadActionEntry, sym::Symbol)
            if sym === :handle
                return getfield(s, :handle)
            elseif sym in fieldnames(_GtkPadActionEntry)
                u = unsafe_load(Ptr{_GtkPadActionEntry}(s.handle))
                return getfield(u, sym)
            end
        end
    end
    begin
        nothing
        mutable struct GtkPaperSize <: GBoxed
            handle::Ptr{GtkPaperSize}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkPaperSize) = begin
                        ccall(("gtk_paper_size_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkPaperSize(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkPaperSize)
            end
        end
        nothing
    end
    begin
        nothing
        mutable struct GtkPrintBackend
            handle::Ptr{GtkPrintBackend}
        end
        nothing
    end
    begin
        struct _GtkRecentData
            display_name::Ptr{UInt8}
            description::Ptr{UInt8}
            mime_type::Ptr{UInt8}
            app_name::Ptr{UInt8}
            app_exec::Ptr{UInt8}
            groups::Ptr{Ptr{UInt8}}
            is_private::Cint
        end
        mutable struct GtkRecentData
            handle::Ptr{GtkRecentData}
        end
        function Base.getproperty(s::GtkRecentData, sym::Symbol)
            if sym === :handle
                return getfield(s, :handle)
            elseif sym in fieldnames(_GtkRecentData)
                u = unsafe_load(Ptr{_GtkRecentData}(s.handle))
                return getfield(u, sym)
            end
        end
    end
    begin
        nothing
        mutable struct GtkRecentInfo <: GBoxed
            handle::Ptr{GtkRecentInfo}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkRecentInfo) = begin
                        ccall(("gtk_recent_info_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkRecentInfo(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkRecentInfo)
            end
        end
        nothing
    end
    begin
        struct _GtkRequestedSize
            data::Ptr{Nothing}
            minimum_size::Int32
            natural_size::Int32
        end
        mutable struct GtkRequestedSize
            handle::Ptr{GtkRequestedSize}
        end
        function Base.getproperty(s::GtkRequestedSize, sym::Symbol)
            if sym === :handle
                return getfield(s, :handle)
            elseif sym in fieldnames(_GtkRequestedSize)
                u = unsafe_load(Ptr{_GtkRequestedSize}(s.handle))
                return getfield(u, sym)
            end
        end
    end
    begin
        struct _GtkRequisition
            width::Int32
            height::Int32
        end
        mutable struct GtkRequisition <: GBoxed
            handle::Ptr{GtkRequisition}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkRequisition) = begin
                        ccall(("gtk_requisition_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkRequisition(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkRequisition)
            end
        end
        function Base.getproperty(s::GtkRequisition, sym::Symbol)
            if sym === :handle
                return getfield(s, :handle)
            elseif sym in fieldnames(_GtkRequisition)
                u = unsafe_load(Ptr{_GtkRequisition}(s.handle))
                return getfield(u, sym)
            end
        end
    end
    begin
        struct _GtkTextIter
            dummy1::Ptr{Nothing}
            dummy2::Ptr{Nothing}
            dummy3::Int32
            dummy4::Int32
            dummy5::Int32
            dummy6::Int32
            dummy7::Int32
            dummy8::Int32
            dummy9::Ptr{Nothing}
            dummy10::Ptr{Nothing}
            dummy11::Int32
            dummy12::Int32
            dummy13::Int32
            dummy14::Ptr{Nothing}
        end
        mutable struct GtkTextIter <: GBoxed
            handle::Ptr{GtkTextIter}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkTextIter) = begin
                        ccall(("gtk_text_iter_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkTextIter(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkTextIter)
            end
        end
        function Base.getproperty(s::GtkTextIter, sym::Symbol)
            if sym === :handle
                return getfield(s, :handle)
            elseif sym in fieldnames(_GtkTextIter)
                u = unsafe_load(Ptr{_GtkTextIter}(s.handle))
                return getfield(u, sym)
            end
        end
    end
    begin
        struct _GtkTreeIter
            stamp::Int32
            user_data::Ptr{Nothing}
            user_data2::Ptr{Nothing}
            user_data3::Ptr{Nothing}
        end
        mutable struct GtkTreeIter <: GBoxed
            handle::Ptr{GtkTreeIter}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkTreeIter) = begin
                        ccall(("gtk_tree_iter_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkTreeIter(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkTreeIter)
            end
        end
        function Base.getproperty(s::GtkTreeIter, sym::Symbol)
            if sym === :handle
                return getfield(s, :handle)
            elseif sym in fieldnames(_GtkTreeIter)
                u = unsafe_load(Ptr{_GtkTreeIter}(s.handle))
                return getfield(u, sym)
            end
        end
    end
    begin
        nothing
        mutable struct GtkTreePath <: GBoxed
            handle::Ptr{GtkTreePath}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkTreePath) = begin
                        ccall(("gtk_tree_path_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkTreePath(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkTreePath)
            end
        end
        nothing
    end
    begin
        nothing
        mutable struct GtkTreeRowReference <: GBoxed
            handle::Ptr{GtkTreeRowReference}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkTreeRowReference) = begin
                        ccall(("gtk_tree_row_reference_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GtkTreeRowReference(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkTreeRowReference)
            end
        end
        nothing
    end
    begin
        gboxed_cache_init() = begin
                append!(GLib.gboxed_types, gboxed_types)
            end
    end
    begin
        gtype_wrapper_cache = Dict{Symbol, Type}()
    end
    begin
        abstract type GtkATContext <: GObject end
    end
    begin
        mutable struct GtkATContextLeaf <: GtkATContext
            handle::Ptr{GObject}
            function GtkATContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkATContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkATContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkATContextLeaf, args))
            end
            w = GtkATContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkATContext] = GtkATContextLeaf
        function GtkATContext(args...; kwargs...)
            GtkATContextLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkATContextLeaf) = begin
                    [:handle, :accessible_role, :display, :accessible]
                end
            function Base.getproperty(o::GtkATContextLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:accessible_role => (:AccessibleRole, 0, 7), :display => (:GdkDisplay, 0, 3), :accessible => (:GtkAccessible, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkATContextLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:accessible_role => (:AccessibleRole, 0, 7), :display => (:GdkDisplay, 0, 3), :accessible => (:GtkAccessible, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkWidget <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkWidgetLeaf <: GtkWidget
            handle::Ptr{GObject}
            function GtkWidgetLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkWidgetLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWidgetLeaf, args))
            end
            w = GtkWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWidget] = GtkWidgetLeaf
        function GtkWidget(args...; kwargs...)
            GtkWidgetLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkWidgetLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkWidgetLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkWidgetLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkWindow <: GtkWidget end
    end
    begin
        mutable struct GtkWindowLeaf <: GtkWindow
            handle::Ptr{GObject}
            function GtkWindowLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkWindowLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWindowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWindowLeaf, args))
            end
            w = GtkWindowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWindow] = GtkWindowLeaf
        function GtkWindow(args...; kwargs...)
            GtkWindowLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkWindowLeaf) = begin
                    [:handle, :application, :hexpand, :halign, :name, :opacity, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :margin_end, :display, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkWindowLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :focus_visible => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkWindowLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkAboutDialog <: GtkWindow end
    end
    begin
        mutable struct GtkAboutDialogLeaf <: GtkAboutDialog
            handle::Ptr{GObject}
            function GtkAboutDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAboutDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAboutDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAboutDialogLeaf, args))
            end
            w = GtkAboutDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAboutDialog] = GtkAboutDialogLeaf
        function GtkAboutDialog(args...; kwargs...)
            GtkAboutDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkAboutDialogLeaf) = begin
                    [:handle, :copyright, :version, :license, :application, :hexpand, :artists, :system_information, :halign, :name, :opacity, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :website, :can_target, :css_name, :mnemonics_visible, :scale_factor, :license_type, :fullscreened, :visible, :has_default, :resizable, :overflow, :authors, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :website_label, :height_request, :hexpand_set, :wrap_license, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :logo, :accessible_role, :margin_end, :comments, :logo_icon_name, :display, :program_name, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :documenters, :default_width, :sensitive, :margin_top, :has_focus, :translator_credits]
                end
            function Base.getproperty(o::GtkAboutDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:copyright => (:String, 0, 3), :version => (:String, 0, 3), :license => (:String, 0, 3), :application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :artists => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :system_information => (:String, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :website => (:String, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :license_type => (:License, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :authors => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :website_label => (:String, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :wrap_license => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :logo => (:GdkPaintable, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :comments => (:String, 0, 3), :logo_icon_name => (:String, 0, 3), :display => (:GdkDisplay, 0, 3), :program_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :documenters => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1), :translator_credits => (:String, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkAboutDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:copyright => (:String, 0, 3), :version => (:String, 0, 3), :license => (:String, 0, 3), :application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :artists => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :system_information => (:String, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :website => (:String, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :license_type => (:License, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :authors => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :website_label => (:String, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :wrap_license => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :logo => (:GdkPaintable, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :comments => (:String, 0, 3), :logo_icon_name => (:String, 0, 3), :display => (:GdkDisplay, 0, 3), :program_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :documenters => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :translator_credits => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkActionBar <: GtkWidget end
    end
    begin
        mutable struct GtkActionBarLeaf <: GtkActionBar
            handle::Ptr{GObject}
            function GtkActionBarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkActionBarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkActionBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkActionBarLeaf, args))
            end
            w = GtkActionBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkActionBar] = GtkActionBarLeaf
        function GtkActionBar(args...; kwargs...)
            GtkActionBarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkActionBarLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :revealed]
                end
            function Base.getproperty(o::GtkActionBarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :revealed => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkActionBarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :revealed => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkShortcutAction <: GObject end
    end
    begin
        mutable struct GtkShortcutActionLeaf <: GtkShortcutAction
            handle::Ptr{GObject}
            function GtkShortcutActionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkShortcutActionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutActionLeaf, args))
            end
            w = GtkShortcutActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutAction] = GtkShortcutActionLeaf
        function GtkShortcutAction(args...; kwargs...)
            GtkShortcutActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkActivateAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkActivateActionLeaf <: GtkActivateAction
            handle::Ptr{GObject}
            function GtkActivateActionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkActivateActionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkActivateActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkActivateActionLeaf, args))
            end
            w = GtkActivateActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkActivateAction] = GtkActivateActionLeaf
        function GtkActivateAction(args...; kwargs...)
            GtkActivateActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAdjustment <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkAdjustmentLeaf <: GtkAdjustment
            handle::Ptr{GObject}
            function GtkAdjustmentLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAdjustmentLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAdjustmentLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAdjustmentLeaf, args))
            end
            w = GtkAdjustmentLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAdjustment] = GtkAdjustmentLeaf
        function GtkAdjustment(args...; kwargs...)
            GtkAdjustmentLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkAdjustmentLeaf) = begin
                    [:handle, :step_increment, :value, :upper, :page_increment, :lower, :page_size]
                end
            function Base.getproperty(o::GtkAdjustmentLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:step_increment => (:Float64, 0, 3), :value => (:Float64, 0, 3), :upper => (:Float64, 0, 3), :page_increment => (:Float64, 0, 3), :lower => (:Float64, 0, 3), :page_size => (:Float64, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkAdjustmentLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:step_increment => (:Float64, 0, 3), :value => (:Float64, 0, 3), :upper => (:Float64, 0, 3), :page_increment => (:Float64, 0, 3), :lower => (:Float64, 0, 3), :page_size => (:Float64, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkShortcutTrigger <: GObject end
    end
    begin
        mutable struct GtkShortcutTriggerLeaf <: GtkShortcutTrigger
            handle::Ptr{GObject}
            function GtkShortcutTriggerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkShortcutTriggerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutTriggerLeaf, args))
            end
            w = GtkShortcutTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutTrigger] = GtkShortcutTriggerLeaf
        function GtkShortcutTrigger(args...; kwargs...)
            GtkShortcutTriggerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAlternativeTrigger <: GtkShortcutTrigger end
    end
    begin
        mutable struct GtkAlternativeTriggerLeaf <: GtkAlternativeTrigger
            handle::Ptr{GObject}
            function GtkAlternativeTriggerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAlternativeTriggerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAlternativeTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAlternativeTriggerLeaf, args))
            end
            w = GtkAlternativeTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAlternativeTrigger] = GtkAlternativeTriggerLeaf
        function GtkAlternativeTrigger(args...; kwargs...)
            GtkAlternativeTriggerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkAlternativeTriggerLeaf) = begin
                    [:handle, :first, :second]
                end
            function Base.getproperty(o::GtkAlternativeTriggerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:first => (:GtkShortcutTrigger, 0, 11), :second => (:GtkShortcutTrigger, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkAlternativeTriggerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:first => (:GtkShortcutTrigger, 0, 11), :second => (:GtkShortcutTrigger, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFilter <: GObject end
    end
    begin
        mutable struct GtkFilterLeaf <: GtkFilter
            handle::Ptr{GObject}
            function GtkFilterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFilterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFilterLeaf, args))
            end
            w = GtkFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFilter] = GtkFilterLeaf
        function GtkFilter(args...; kwargs...)
            GtkFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMultiFilter <: GtkFilter end
    end
    begin
        mutable struct GtkMultiFilterLeaf <: GtkMultiFilter
            handle::Ptr{GObject}
            function GtkMultiFilterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMultiFilterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMultiFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMultiFilterLeaf, args))
            end
            w = GtkMultiFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMultiFilter] = GtkMultiFilterLeaf
        function GtkMultiFilter(args...; kwargs...)
            GtkMultiFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAnyFilter <: GtkMultiFilter end
    end
    begin
        mutable struct GtkAnyFilterLeaf <: GtkAnyFilter
            handle::Ptr{GObject}
            function GtkAnyFilterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAnyFilterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAnyFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAnyFilterLeaf, args))
            end
            w = GtkAnyFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAnyFilter] = GtkAnyFilterLeaf
        function GtkAnyFilter(args...; kwargs...)
            GtkAnyFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAppChooserButton <: GtkWidget end
    end
    begin
        mutable struct GtkAppChooserButtonLeaf <: GtkAppChooserButton
            handle::Ptr{GObject}
            function GtkAppChooserButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAppChooserButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAppChooserButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAppChooserButtonLeaf, args))
            end
            w = GtkAppChooserButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAppChooserButton] = GtkAppChooserButtonLeaf
        function GtkAppChooserButton(args...; kwargs...)
            GtkAppChooserButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkAppChooserButtonLeaf) = begin
                    [:handle, :css_classes, :visible, :heading, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :content_type, :accessible_role, :show_dialog_item, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :modal, :name, :opacity, :height_request, :layout_manager, :show_default_item, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkAppChooserButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :heading => (:String, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :content_type => (:String, 0, 11), :accessible_role => (:AccessibleRole, 0, 3), :show_dialog_item => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 7), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :show_default_item => (:Bool, 0, 7), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkAppChooserButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :heading => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :content_type => (:String, 0, 11), :accessible_role => (:AccessibleRole, 0, 3), :show_dialog_item => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 7), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :show_default_item => (:Bool, 0, 7), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkDialog <: GtkWindow end
    end
    begin
        mutable struct GtkDialogLeaf <: GtkDialog
            handle::Ptr{GObject}
            function GtkDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDialogLeaf, args))
            end
            w = GtkDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDialog] = GtkDialogLeaf
        function GtkDialog(args...; kwargs...)
            GtkDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkDialogLeaf) = begin
                    [:handle, :application, :hexpand, :halign, :name, :opacity, :use_header_bar, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :margin_end, :display, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :focus_visible => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkAppChooserDialog <: GtkDialog end
    end
    begin
        mutable struct GtkAppChooserDialogLeaf <: GtkAppChooserDialog
            handle::Ptr{GObject}
            function GtkAppChooserDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAppChooserDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAppChooserDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAppChooserDialogLeaf, args))
            end
            w = GtkAppChooserDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAppChooserDialog] = GtkAppChooserDialogLeaf
        function GtkAppChooserDialog(args...; kwargs...)
            GtkAppChooserDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkAppChooserDialogLeaf) = begin
                    [:handle, :application, :hexpand, :halign, :name, :opacity, :use_header_bar, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :height_request, :hexpand_set, :gfile, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :heading, :has_tooltip, :transient_for, :content_type, :accessible_role, :margin_end, :display, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkAppChooserDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :gfile => (:GFile, 0, 11), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :heading => (:String, 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :content_type => (:String, 0, 11), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkAppChooserDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :gfile => (:GFile, 0, 11), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :heading => (:String, 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :content_type => (:String, 0, 11), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkAppChooserWidget <: GtkWidget end
    end
    begin
        mutable struct GtkAppChooserWidgetLeaf <: GtkAppChooserWidget
            handle::Ptr{GObject}
            function GtkAppChooserWidgetLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAppChooserWidgetLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAppChooserWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAppChooserWidgetLeaf, args))
            end
            w = GtkAppChooserWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAppChooserWidget] = GtkAppChooserWidgetLeaf
        function GtkAppChooserWidget(args...; kwargs...)
            GtkAppChooserWidgetLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkAppChooserWidgetLeaf) = begin
                    [:handle, :show_fallback, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :default_text, :has_tooltip, :overflow, :content_type, :accessible_role, :show_recommended, :margin_start, :margin_end, :hexpand, :show_default, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :show_other, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :show_all]
                end
            function Base.getproperty(o::GtkAppChooserWidgetLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:show_fallback => (:Bool, 0, 7), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :default_text => (:String, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :content_type => (:String, 0, 11), :accessible_role => (:AccessibleRole, 0, 3), :show_recommended => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :show_default => (:Bool, 0, 7), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :show_other => (:Bool, 0, 7), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :show_all => (:Bool, 0, 7))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkAppChooserWidgetLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:show_fallback => (:Bool, 0, 7), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :default_text => (:String, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :content_type => (:String, 0, 11), :accessible_role => (:AccessibleRole, 0, 3), :show_recommended => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :show_default => (:Bool, 0, 7), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :show_other => (:Bool, 0, 7), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :show_all => (:Bool, 0, 7))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkApplication <: GApplication end
    end
    begin
        mutable struct GtkApplicationLeaf <: GtkApplication
            handle::Ptr{GObject}
            function GtkApplicationLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkApplicationLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkApplicationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkApplicationLeaf, args))
            end
            w = GtkApplicationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkApplication] = GtkApplicationLeaf
        function GtkApplication(args...; kwargs...)
            GtkApplicationLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkApplicationLeaf) = begin
                    [:handle, :menubar, :is_registered, :is_remote, :register_session, :active_window, :screensaver_active, :resource_base_path, :is_busy, :application_id, :action_group, :inactivity_timeout, :flags]
                end
            function Base.getproperty(o::GtkApplicationLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:menubar => (:GMenuModel, 0, 3), :is_registered => (:Bool, 0, 1), :is_remote => (:Bool, 0, 1), :register_session => (:Bool, 0, 3), :active_window => (:GtkWindow, 0, 1), :screensaver_active => (:Bool, 0, 1), :resource_base_path => (:String, 0, 3), :is_busy => (:Bool, 0, 1), :application_id => (:String, 0, 7), :inactivity_timeout => (:UInt32, 0, 3), :flags => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkApplicationLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:resource_base_path => (:String, 0, 3), :application_id => (:String, 0, 7), :flags => (:Int32, 0, 3), :menubar => (:GMenuModel, 0, 3), :register_session => (:Bool, 0, 3), :action_group => (:GActionGroup, 0, 2), :inactivity_timeout => (:UInt32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkApplicationWindow <: GtkWindow end
    end
    begin
        mutable struct GtkApplicationWindowLeaf <: GtkApplicationWindow
            handle::Ptr{GObject}
            function GtkApplicationWindowLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkApplicationWindowLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkApplicationWindowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkApplicationWindowLeaf, args))
            end
            w = GtkApplicationWindowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkApplicationWindow] = GtkApplicationWindowLeaf
        function GtkApplicationWindow(args...; kwargs...)
            GtkApplicationWindowLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkApplicationWindowLeaf) = begin
                    [:handle, :application, :hexpand, :halign, :name, :opacity, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :show_menubar, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :margin_end, :display, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkApplicationWindowLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :show_menubar => (:Bool, 0, 7), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :focus_visible => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkApplicationWindowLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :show_menubar => (:Bool, 0, 7), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkAspectFrame <: GtkWidget end
    end
    begin
        mutable struct GtkAspectFrameLeaf <: GtkAspectFrame
            handle::Ptr{GObject}
            function GtkAspectFrameLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAspectFrameLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAspectFrameLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAspectFrameLeaf, args))
            end
            w = GtkAspectFrameLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAspectFrame] = GtkAspectFrameLeaf
        function GtkAspectFrame(args...; kwargs...)
            GtkAspectFrameLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkAspectFrameLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :obey_child, :has_tooltip, :overflow, :accessible_role, :xalign, :ratio, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :yalign]
                end
            function Base.getproperty(o::GtkAspectFrameLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :obey_child => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :xalign => (:Float32, 0, 3), :ratio => (:Float32, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :yalign => (:Float32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkAspectFrameLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :obey_child => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :xalign => (:Float32, 0, 3), :ratio => (:Float32, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :yalign => (:Float32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkAssistant <: GtkWindow end
    end
    begin
        mutable struct GtkAssistantLeaf <: GtkAssistant
            handle::Ptr{GObject}
            function GtkAssistantLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAssistantLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAssistantLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAssistantLeaf, args))
            end
            w = GtkAssistantLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAssistant] = GtkAssistantLeaf
        function GtkAssistant(args...; kwargs...)
            GtkAssistantLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkAssistantLeaf) = begin
                    [:handle, :pages, :application, :hexpand, :halign, :name, :opacity, :use_header_bar, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :margin_end, :display, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkAssistantLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pages => (:GListModel, 0, 1), :application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkAssistantLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkAssistantPage <: GObject end
    end
    begin
        mutable struct GtkAssistantPageLeaf <: GtkAssistantPage
            handle::Ptr{GObject}
            function GtkAssistantPageLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkAssistantPageLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAssistantPageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAssistantPageLeaf, args))
            end
            w = GtkAssistantPageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAssistantPage] = GtkAssistantPageLeaf
        function GtkAssistantPage(args...; kwargs...)
            GtkAssistantPageLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkAssistantPageLeaf) = begin
                    [:handle, :child, :complete, :title, :page_type]
                end
            function Base.getproperty(o::GtkAssistantPageLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child => (:GtkWidget, 0, 11), :complete => (:Bool, 0, 3), :title => (:String, 0, 3), :page_type => (:AssistantPageType, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkAssistantPageLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child => (:GtkWidget, 0, 11), :complete => (:Bool, 0, 3), :title => (:String, 0, 3), :page_type => (:AssistantPageType, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkLayoutManager <: GObject end
    end
    begin
        mutable struct GtkLayoutManagerLeaf <: GtkLayoutManager
            handle::Ptr{GObject}
            function GtkLayoutManagerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkLayoutManagerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLayoutManagerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLayoutManagerLeaf, args))
            end
            w = GtkLayoutManagerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLayoutManager] = GtkLayoutManagerLeaf
        function GtkLayoutManager(args...; kwargs...)
            GtkLayoutManagerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBinLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkBinLayoutLeaf <: GtkBinLayout
            handle::Ptr{GObject}
            function GtkBinLayoutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkBinLayoutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBinLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBinLayoutLeaf, args))
            end
            w = GtkBinLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBinLayout] = GtkBinLayoutLeaf
        function GtkBinLayout(args...; kwargs...)
            GtkBinLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBookmarkList <: GObject end
    end
    begin
        mutable struct GtkBookmarkListLeaf <: GtkBookmarkList
            handle::Ptr{GObject}
            function GtkBookmarkListLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkBookmarkListLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBookmarkListLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBookmarkListLeaf, args))
            end
            w = GtkBookmarkListLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBookmarkList] = GtkBookmarkListLeaf
        function GtkBookmarkList(args...; kwargs...)
            GtkBookmarkListLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkBookmarkListLeaf) = begin
                    [:handle, :attributes, :filename, :io_priority, :loading]
                end
            function Base.getproperty(o::GtkBookmarkListLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:attributes => (:String, 0, 3), :filename => (:String, 0, 11), :io_priority => (:Int32, 0, 3), :loading => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkBookmarkListLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:attributes => (:String, 0, 3), :filename => (:String, 0, 11), :io_priority => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkBoolFilter <: GtkFilter end
    end
    begin
        mutable struct GtkBoolFilterLeaf <: GtkBoolFilter
            handle::Ptr{GObject}
            function GtkBoolFilterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkBoolFilterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBoolFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBoolFilterLeaf, args))
            end
            w = GtkBoolFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBoolFilter] = GtkBoolFilterLeaf
        function GtkBoolFilter(args...; kwargs...)
            GtkBoolFilterLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkBoolFilterLeaf) = begin
                    [:handle, :expression, :invert]
                end
            function Base.getproperty(o::GtkBoolFilterLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:expression => (:GtkExpression, 0, 3), :invert => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkBoolFilterLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:expression => (:GtkExpression, 0, 3), :invert => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkBox <: GtkWidget end
    end
    begin
        mutable struct GtkBoxLeaf <: GtkBox
            handle::Ptr{GObject}
            function GtkBoxLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkBoxLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBoxLeaf, args))
            end
            w = GtkBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBox] = GtkBoxLeaf
        function GtkBox(args...; kwargs...)
            GtkBoxLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkBoxLeaf) = begin
                    [:handle, :css_classes, :visible, :spacing, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :homogeneous, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :baseline_position, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkBoxLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :spacing => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :homogeneous => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkBoxLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :spacing => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :homogeneous => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkBoxLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkBoxLayoutLeaf <: GtkBoxLayout
            handle::Ptr{GObject}
            function GtkBoxLayoutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkBoxLayoutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBoxLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBoxLayoutLeaf, args))
            end
            w = GtkBoxLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBoxLayout] = GtkBoxLayoutLeaf
        function GtkBoxLayout(args...; kwargs...)
            GtkBoxLayoutLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkBoxLayoutLeaf) = begin
                    [:handle, :homogeneous, :spacing, :baseline_position, :orientation]
                end
            function Base.getproperty(o::GtkBoxLayoutLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:homogeneous => (:Bool, 0, 3), :spacing => (:Int32, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :orientation => (:Orientation, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkBoxLayoutLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:homogeneous => (:Bool, 0, 3), :spacing => (:Int32, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :orientation => (:Orientation, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkBuilder <: GObject end
    end
    begin
        mutable struct GtkBuilderLeaf <: GtkBuilder
            handle::Ptr{GObject}
            function GtkBuilderLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkBuilderLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBuilderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBuilderLeaf, args))
            end
            w = GtkBuilderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBuilder] = GtkBuilderLeaf
        function GtkBuilder(args...; kwargs...)
            GtkBuilderLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkBuilderLeaf) = begin
                    [:handle, :translation_domain, :current_object, :scope]
                end
            function Base.getproperty(o::GtkBuilderLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:translation_domain => (:String, 0, 3), :current_object => (:GObject, 0, 3), :scope => (:GtkBuilderScope, 0, 7))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkBuilderLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:translation_domain => (:String, 0, 3), :current_object => (:GObject, 0, 3), :scope => (:GtkBuilderScope, 0, 7))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkBuilderCScope <: GObject end
    end
    begin
        mutable struct GtkBuilderCScopeLeaf <: GtkBuilderCScope
            handle::Ptr{GObject}
            function GtkBuilderCScopeLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkBuilderCScopeLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBuilderCScopeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBuilderCScopeLeaf, args))
            end
            w = GtkBuilderCScopeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBuilderCScope] = GtkBuilderCScopeLeaf
        function GtkBuilderCScope(args...; kwargs...)
            GtkBuilderCScopeLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkListItemFactory <: GObject end
    end
    begin
        mutable struct GtkListItemFactoryLeaf <: GtkListItemFactory
            handle::Ptr{GObject}
            function GtkListItemFactoryLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkListItemFactoryLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListItemFactoryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListItemFactoryLeaf, args))
            end
            w = GtkListItemFactoryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListItemFactory] = GtkListItemFactoryLeaf
        function GtkListItemFactory(args...; kwargs...)
            GtkListItemFactoryLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBuilderListItemFactory <: GtkListItemFactory end
    end
    begin
        mutable struct GtkBuilderListItemFactoryLeaf <: GtkBuilderListItemFactory
            handle::Ptr{GObject}
            function GtkBuilderListItemFactoryLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkBuilderListItemFactoryLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBuilderListItemFactoryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBuilderListItemFactoryLeaf, args))
            end
            w = GtkBuilderListItemFactoryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBuilderListItemFactory] = GtkBuilderListItemFactoryLeaf
        function GtkBuilderListItemFactory(args...; kwargs...)
            GtkBuilderListItemFactoryLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkBuilderListItemFactoryLeaf) = begin
                    [:handle, :bytes, :resource, :scope]
                end
            function Base.getproperty(o::GtkBuilderListItemFactoryLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:bytes => (:GBytes, 0, 11), :resource => (:String, 0, 11), :scope => (:GtkBuilderScope, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkBuilderListItemFactoryLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:bytes => (:GBytes, 0, 11), :resource => (:String, 0, 11), :scope => (:GtkBuilderScope, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkButton <: GtkWidget end
    end
    begin
        mutable struct GtkButtonLeaf <: GtkButton
            handle::Ptr{GObject}
            function GtkButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkButtonLeaf, args))
            end
            w = GtkButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkButton] = GtkButtonLeaf
        function GtkButton(args...; kwargs...)
            GtkButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkButtonLeaf) = begin
                    [:handle, :icon_name, :action_target, :css_classes, :visible, :label, :focusable, :has_default, :valign, :vexpand_set, :use_underline, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :action_name, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :scale_factor, :root, :has_frame]
                end
            function Base.getproperty(o::GtkButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:has_frame => (:Bool, 0, 3), :action_target => (:GVariant, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :scale_factor => (:Int32, 0, 1), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_target => (:GVariant, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :has_frame => (:Bool, 0, 3), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCalendar <: GtkWidget end
    end
    begin
        mutable struct GtkCalendarLeaf <: GtkCalendar
            handle::Ptr{GObject}
            function GtkCalendarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCalendarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCalendarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCalendarLeaf, args))
            end
            w = GtkCalendarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCalendar] = GtkCalendarLeaf
        function GtkCalendar(args...; kwargs...)
            GtkCalendarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCalendarLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :year, :accessible_role, :margin_start, :margin_end, :show_day_names, :hexpand, :receives_default, :show_heading, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :day, :hexpand_set, :sensitive, :width_request, :show_week_numbers, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :month]
                end
            function Base.getproperty(o::GtkCalendarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :year => (:Int32, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :show_day_names => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :show_heading => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :day => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :show_week_numbers => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :month => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCalendarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :year => (:Int32, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :show_day_names => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :show_heading => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :day => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :show_week_numbers => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :month => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCallbackAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkCallbackActionLeaf <: GtkCallbackAction
            handle::Ptr{GObject}
            function GtkCallbackActionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCallbackActionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCallbackActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCallbackActionLeaf, args))
            end
            w = GtkCallbackActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCallbackAction] = GtkCallbackActionLeaf
        function GtkCallbackAction(args...; kwargs...)
            GtkCallbackActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellArea <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkCellAreaLeaf <: GtkCellArea
            handle::Ptr{GObject}
            function GtkCellAreaLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellAreaLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellAreaLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellAreaLeaf, args))
            end
            w = GtkCellAreaLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellArea] = GtkCellAreaLeaf
        function GtkCellArea(args...; kwargs...)
            GtkCellAreaLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellAreaLeaf) = begin
                    [:handle, :focus_cell, :edit_widget, :edited_cell]
                end
            function Base.getproperty(o::GtkCellAreaLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:focus_cell => (:GtkCellRenderer, 0, 3), :edit_widget => (:GtkCellEditable, 0, 1), :edited_cell => (:GtkCellRenderer, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellAreaLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:focus_cell => (:GtkCellRenderer, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellAreaBox <: GtkCellArea end
    end
    begin
        mutable struct GtkCellAreaBoxLeaf <: GtkCellAreaBox
            handle::Ptr{GObject}
            function GtkCellAreaBoxLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellAreaBoxLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellAreaBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellAreaBoxLeaf, args))
            end
            w = GtkCellAreaBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellAreaBox] = GtkCellAreaBoxLeaf
        function GtkCellAreaBox(args...; kwargs...)
            GtkCellAreaBoxLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellAreaBoxLeaf) = begin
                    [:handle, :focus_cell, :spacing, :orientation, :edit_widget, :edited_cell]
                end
            function Base.getproperty(o::GtkCellAreaBoxLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:focus_cell => (:GtkCellRenderer, 0, 3), :spacing => (:Int32, 0, 3), :orientation => (:Orientation, 0, 3), :edit_widget => (:GtkCellEditable, 0, 1), :edited_cell => (:GtkCellRenderer, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellAreaBoxLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:focus_cell => (:GtkCellRenderer, 0, 3), :spacing => (:Int32, 0, 3), :orientation => (:Orientation, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellAreaContext <: GObject end
    end
    begin
        mutable struct GtkCellAreaContextLeaf <: GtkCellAreaContext
            handle::Ptr{GObject}
            function GtkCellAreaContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellAreaContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellAreaContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellAreaContextLeaf, args))
            end
            w = GtkCellAreaContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellAreaContext] = GtkCellAreaContextLeaf
        function GtkCellAreaContext(args...; kwargs...)
            GtkCellAreaContextLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellAreaContextLeaf) = begin
                    [:handle, :minimum_height, :natural_width, :minimum_width, :area, :natural_height]
                end
            function Base.getproperty(o::GtkCellAreaContextLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:minimum_height => (:Int32, 0, 1), :natural_width => (:Int32, 0, 1), :minimum_width => (:Int32, 0, 1), :area => (:GtkCellArea, 0, 11), :natural_height => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellAreaContextLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:area => (:GtkCellArea, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellRenderer <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkCellRendererLeaf <: GtkCellRenderer
            handle::Ptr{GObject}
            function GtkCellRendererLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererLeaf, args))
            end
            w = GtkCellRendererLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRenderer] = GtkCellRendererLeaf
        function GtkCellRenderer(args...; kwargs...)
            GtkCellRendererLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellRendererLeaf) = begin
                    [:handle, :width, :cell_background_rgba, :visible, :height, :is_expanded, :cell_background, :editing, :xalign, :mode, :cell_background_set, :sensitive, :ypad, :is_expander, :xpad, :yalign]
                end
            function Base.getproperty(o::GtkCellRendererLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :is_expanded => (:Bool, 0, 3), :editing => (:Bool, 0, 1), :xalign => (:Float32, 0, 3), :mode => (:CellRendererMode, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :is_expander => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :width => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellRendererLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :is_expanded => (:Bool, 0, 3), :cell_background => (:String, 0, 2), :xalign => (:Float32, 0, 3), :mode => (:CellRendererMode, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :is_expander => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :width => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellRendererText <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererTextLeaf <: GtkCellRendererText
            handle::Ptr{GObject}
            function GtkCellRendererTextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererTextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererTextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererTextLeaf, args))
            end
            w = GtkCellRendererTextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererText] = GtkCellRendererTextLeaf
        function GtkCellRendererText(args...; kwargs...)
            GtkCellRendererTextLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellRendererTextLeaf) = begin
                    [:handle, :placeholder_text, :foreground, :height, :text, :size_set, :strikethrough_set, :cell_background, :xalign, :style_set, :stretch, :mode, :background_rgba, :background, :foreground_rgba, :underline_set, :ellipsize, :scale_set, :visible, :is_expanded, :scale, :stretch_set, :align_set, :variant_set, :max_width_chars, :attributes, :style, :strikethrough, :background_set, :xpad, :yalign, :cell_background_rgba, :editing, :font_desc, :ellipsize_set, :editable, :cell_background_set, :ypad, :editable_set, :language, :single_paragraph_mode, :alignment, :wrap_mode, :width, :family_set, :rise, :weight, :weight_set, :size, :rise_set, :width_chars, :size_points, :foreground_set, :font, :language_set, :variant, :wrap_width, :sensitive, :markup, :is_expander, :family, :underline]
                end
            function Base.getproperty(o::GtkCellRendererTextLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :size_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :xalign => (:Float32, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :mode => (:CellRendererMode, 0, 3), :background_rgba => (:GdkRGBA, 0, 3), :foreground_rgba => (:GdkRGBA, 0, 3), :underline_set => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :scale_set => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :is_expanded => (:Bool, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :align_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :attributes => (:PangoAttrList, 0, 3), :style => (:Style, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :editing => (:Bool, 0, 1), :font_desc => (:PangoFontDescription, 0, 3), :ellipsize_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :editable_set => (:Bool, 0, 3), :language => (:String, 0, 3), :single_paragraph_mode => (:Bool, 0, 3), :alignment => (:Alignment, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :width => (:Int32, 0, 3), :family_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :rise_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :wrap_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :is_expander => (:Bool, 0, 3), :family => (:String, 0, 3), :underline => (:Underline, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellRendererTextLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :foreground => (:String, 0, 2), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :size_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :cell_background => (:String, 0, 2), :xalign => (:Float32, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :mode => (:CellRendererMode, 0, 3), :background_rgba => (:GdkRGBA, 0, 3), :background => (:String, 0, 2), :foreground_rgba => (:GdkRGBA, 0, 3), :underline_set => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :scale_set => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :is_expanded => (:Bool, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :align_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :attributes => (:PangoAttrList, 0, 3), :style => (:Style, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :ellipsize_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :editable_set => (:Bool, 0, 3), :language => (:String, 0, 3), :single_paragraph_mode => (:Bool, 0, 3), :alignment => (:Alignment, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :width => (:Int32, 0, 3), :family_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :rise_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :wrap_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :markup => (:String, 0, 2), :is_expander => (:Bool, 0, 3), :family => (:String, 0, 3), :underline => (:Underline, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellRendererAccel <: GtkCellRendererText end
    end
    begin
        mutable struct GtkCellRendererAccelLeaf <: GtkCellRendererAccel
            handle::Ptr{GObject}
            function GtkCellRendererAccelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererAccelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererAccelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererAccelLeaf, args))
            end
            w = GtkCellRendererAccelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererAccel] = GtkCellRendererAccelLeaf
        function GtkCellRendererAccel(args...; kwargs...)
            GtkCellRendererAccelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellRendererAccelLeaf) = begin
                    [:handle, :placeholder_text, :foreground, :height, :text, :size_set, :strikethrough_set, :cell_background, :xalign, :style_set, :stretch, :mode, :background_rgba, :background, :foreground_rgba, :underline_set, :ellipsize, :scale_set, :visible, :is_expanded, :scale, :stretch_set, :align_set, :variant_set, :max_width_chars, :attributes, :style, :accel_mods, :strikethrough, :background_set, :accel_mode, :xpad, :yalign, :cell_background_rgba, :editing, :font_desc, :accel_key, :ellipsize_set, :editable, :cell_background_set, :ypad, :editable_set, :language, :single_paragraph_mode, :alignment, :wrap_mode, :width, :family_set, :rise, :weight, :weight_set, :size, :rise_set, :width_chars, :size_points, :foreground_set, :font, :language_set, :variant, :wrap_width, :sensitive, :markup, :is_expander, :family, :keycode, :underline]
                end
            function Base.getproperty(o::GtkCellRendererAccelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :size_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :xalign => (:Float32, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :mode => (:CellRendererMode, 0, 3), :background_rgba => (:GdkRGBA, 0, 3), :foreground_rgba => (:GdkRGBA, 0, 3), :underline_set => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :scale_set => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :is_expanded => (:Bool, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :align_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :attributes => (:PangoAttrList, 0, 3), :style => (:Style, 0, 3), :accel_mods => (:Int32, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :accel_mode => (:CellRendererAccelMode, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :editing => (:Bool, 0, 1), :font_desc => (:PangoFontDescription, 0, 3), :accel_key => (:UInt32, 0, 3), :ellipsize_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :editable_set => (:Bool, 0, 3), :language => (:String, 0, 3), :single_paragraph_mode => (:Bool, 0, 3), :alignment => (:Alignment, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :width => (:Int32, 0, 3), :family_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :rise_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :wrap_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :is_expander => (:Bool, 0, 3), :family => (:String, 0, 3), :keycode => (:UInt32, 0, 3), :underline => (:Underline, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellRendererAccelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :foreground => (:String, 0, 2), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :size_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :cell_background => (:String, 0, 2), :xalign => (:Float32, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :mode => (:CellRendererMode, 0, 3), :background_rgba => (:GdkRGBA, 0, 3), :background => (:String, 0, 2), :foreground_rgba => (:GdkRGBA, 0, 3), :underline_set => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :scale_set => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :is_expanded => (:Bool, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :align_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :attributes => (:PangoAttrList, 0, 3), :style => (:Style, 0, 3), :accel_mods => (:Int32, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :accel_mode => (:CellRendererAccelMode, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :accel_key => (:UInt32, 0, 3), :ellipsize_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :editable_set => (:Bool, 0, 3), :language => (:String, 0, 3), :single_paragraph_mode => (:Bool, 0, 3), :alignment => (:Alignment, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :width => (:Int32, 0, 3), :family_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :rise_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :wrap_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :markup => (:String, 0, 2), :is_expander => (:Bool, 0, 3), :family => (:String, 0, 3), :keycode => (:UInt32, 0, 3), :underline => (:Underline, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellRendererCombo <: GtkCellRendererText end
    end
    begin
        mutable struct GtkCellRendererComboLeaf <: GtkCellRendererCombo
            handle::Ptr{GObject}
            function GtkCellRendererComboLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererComboLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererComboLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererComboLeaf, args))
            end
            w = GtkCellRendererComboLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererCombo] = GtkCellRendererComboLeaf
        function GtkCellRendererCombo(args...; kwargs...)
            GtkCellRendererComboLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellRendererComboLeaf) = begin
                    [:handle, :placeholder_text, :foreground, :height, :text, :size_set, :strikethrough_set, :cell_background, :xalign, :style_set, :stretch, :mode, :background_rgba, :background, :foreground_rgba, :underline_set, :ellipsize, :scale_set, :visible, :is_expanded, :scale, :stretch_set, :align_set, :variant_set, :max_width_chars, :attributes, :has_entry, :style, :strikethrough, :background_set, :xpad, :yalign, :cell_background_rgba, :editing, :font_desc, :ellipsize_set, :editable, :model, :cell_background_set, :ypad, :editable_set, :language, :single_paragraph_mode, :alignment, :wrap_mode, :width, :family_set, :rise, :weight, :weight_set, :size, :rise_set, :width_chars, :size_points, :foreground_set, :font, :language_set, :variant, :text_column, :wrap_width, :sensitive, :markup, :is_expander, :family, :underline]
                end
            function Base.getproperty(o::GtkCellRendererComboLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :size_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :xalign => (:Float32, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :mode => (:CellRendererMode, 0, 3), :background_rgba => (:GdkRGBA, 0, 3), :foreground_rgba => (:GdkRGBA, 0, 3), :underline_set => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :scale_set => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :is_expanded => (:Bool, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :align_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :attributes => (:PangoAttrList, 0, 3), :has_entry => (:Bool, 0, 3), :style => (:Style, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :editing => (:Bool, 0, 1), :font_desc => (:PangoFontDescription, 0, 3), :ellipsize_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :model => (:GtkTreeModel, 0, 3), :cell_background_set => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :editable_set => (:Bool, 0, 3), :language => (:String, 0, 3), :single_paragraph_mode => (:Bool, 0, 3), :alignment => (:Alignment, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :width => (:Int32, 0, 3), :family_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :rise_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :text_column => (:Int32, 0, 3), :wrap_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :is_expander => (:Bool, 0, 3), :family => (:String, 0, 3), :underline => (:Underline, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellRendererComboLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :foreground => (:String, 0, 2), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :size_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :cell_background => (:String, 0, 2), :xalign => (:Float32, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :mode => (:CellRendererMode, 0, 3), :background_rgba => (:GdkRGBA, 0, 3), :background => (:String, 0, 2), :foreground_rgba => (:GdkRGBA, 0, 3), :underline_set => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :scale_set => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :is_expanded => (:Bool, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :align_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :attributes => (:PangoAttrList, 0, 3), :has_entry => (:Bool, 0, 3), :style => (:Style, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :ellipsize_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :model => (:GtkTreeModel, 0, 3), :cell_background_set => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :editable_set => (:Bool, 0, 3), :language => (:String, 0, 3), :single_paragraph_mode => (:Bool, 0, 3), :alignment => (:Alignment, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :width => (:Int32, 0, 3), :family_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :rise_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :text_column => (:Int32, 0, 3), :wrap_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :markup => (:String, 0, 2), :is_expander => (:Bool, 0, 3), :family => (:String, 0, 3), :underline => (:Underline, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellRendererPixbuf <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererPixbufLeaf <: GtkCellRendererPixbuf
            handle::Ptr{GObject}
            function GtkCellRendererPixbufLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererPixbufLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererPixbufLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererPixbufLeaf, args))
            end
            w = GtkCellRendererPixbufLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererPixbuf] = GtkCellRendererPixbufLeaf
        function GtkCellRendererPixbuf(args...; kwargs...)
            GtkCellRendererPixbufLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellRendererPixbufLeaf) = begin
                    [:handle, :width, :icon_name, :cell_background_rgba, :texture, :visible, :height, :pixbuf, :is_expanded, :gicon, :cell_background, :editing, :xalign, :icon_size, :mode, :cell_background_set, :sensitive, :ypad, :is_expander, :pixbuf_expander_open, :pixbuf_expander_closed, :xpad, :yalign]
                end
            function Base.getproperty(o::GtkCellRendererPixbufLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:width => (:Int32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :texture => (:GdkTexture, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :is_expanded => (:Bool, 0, 3), :gicon => (:GIcon, 0, 3), :editing => (:Bool, 0, 1), :xalign => (:Float32, 0, 3), :icon_size => (:IconSize, 0, 3), :mode => (:CellRendererMode, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :is_expander => (:Bool, 0, 3), :pixbuf_expander_open => (:GdkPixbuf, 0, 3), :pixbuf_expander_closed => (:GdkPixbuf, 0, 3), :xpad => (:UInt32, 0, 3), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellRendererPixbufLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:width => (:Int32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :texture => (:GdkTexture, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :pixbuf => (:GdkPixbuf, 0, 2), :is_expanded => (:Bool, 0, 3), :gicon => (:GIcon, 0, 3), :cell_background => (:String, 0, 2), :xalign => (:Float32, 0, 3), :icon_size => (:IconSize, 0, 3), :mode => (:CellRendererMode, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :is_expander => (:Bool, 0, 3), :pixbuf_expander_open => (:GdkPixbuf, 0, 3), :pixbuf_expander_closed => (:GdkPixbuf, 0, 3), :xpad => (:UInt32, 0, 3), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellRendererProgress <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererProgressLeaf <: GtkCellRendererProgress
            handle::Ptr{GObject}
            function GtkCellRendererProgressLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererProgressLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererProgressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererProgressLeaf, args))
            end
            w = GtkCellRendererProgressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererProgress] = GtkCellRendererProgressLeaf
        function GtkCellRendererProgress(args...; kwargs...)
            GtkCellRendererProgressLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellRendererProgressLeaf) = begin
                    [:handle, :yalign, :cell_background_rgba, :visible, :height, :text, :is_expanded, :orientation, :text_yalign, :cell_background, :editing, :xalign, :mode, :pulse, :text_xalign, :inverted, :cell_background_set, :sensitive, :ypad, :value, :is_expander, :xpad, :width]
                end
            function Base.getproperty(o::GtkCellRendererProgressLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:width => (:Int32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :is_expanded => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :text_yalign => (:Float32, 0, 3), :editing => (:Bool, 0, 1), :xalign => (:Float32, 0, 3), :mode => (:CellRendererMode, 0, 3), :pulse => (:Int32, 0, 3), :text_xalign => (:Float32, 0, 3), :inverted => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :value => (:Int32, 0, 3), :is_expander => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellRendererProgressLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:width => (:Int32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :is_expanded => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :text_yalign => (:Float32, 0, 3), :cell_background => (:String, 0, 2), :xalign => (:Float32, 0, 3), :mode => (:CellRendererMode, 0, 3), :pulse => (:Int32, 0, 3), :text_xalign => (:Float32, 0, 3), :inverted => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :value => (:Int32, 0, 3), :is_expander => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellRendererSpin <: GtkCellRendererText end
    end
    begin
        mutable struct GtkCellRendererSpinLeaf <: GtkCellRendererSpin
            handle::Ptr{GObject}
            function GtkCellRendererSpinLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererSpinLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererSpinLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererSpinLeaf, args))
            end
            w = GtkCellRendererSpinLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererSpin] = GtkCellRendererSpinLeaf
        function GtkCellRendererSpin(args...; kwargs...)
            GtkCellRendererSpinLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellRendererSpinLeaf) = begin
                    [:handle, :placeholder_text, :foreground, :height, :text, :size_set, :strikethrough_set, :cell_background, :xalign, :style_set, :stretch, :mode, :background_rgba, :background, :foreground_rgba, :underline_set, :ellipsize, :scale_set, :digits, :visible, :is_expanded, :scale, :stretch_set, :align_set, :variant_set, :max_width_chars, :attributes, :style, :climb_rate, :strikethrough, :background_set, :xpad, :yalign, :cell_background_rgba, :editing, :font_desc, :ellipsize_set, :editable, :cell_background_set, :ypad, :editable_set, :language, :single_paragraph_mode, :alignment, :wrap_mode, :width, :family_set, :rise, :weight, :weight_set, :size, :rise_set, :width_chars, :size_points, :foreground_set, :font, :language_set, :variant, :adjustment, :wrap_width, :sensitive, :markup, :is_expander, :family, :underline]
                end
            function Base.getproperty(o::GtkCellRendererSpinLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :size_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :xalign => (:Float32, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :mode => (:CellRendererMode, 0, 3), :background_rgba => (:GdkRGBA, 0, 3), :foreground_rgba => (:GdkRGBA, 0, 3), :underline_set => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :scale_set => (:Bool, 0, 3), :digits => (:UInt32, 0, 3), :visible => (:Bool, 0, 3), :is_expanded => (:Bool, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :align_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :attributes => (:PangoAttrList, 0, 3), :style => (:Style, 0, 3), :climb_rate => (:Float64, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :editing => (:Bool, 0, 1), :font_desc => (:PangoFontDescription, 0, 3), :ellipsize_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :editable_set => (:Bool, 0, 3), :language => (:String, 0, 3), :single_paragraph_mode => (:Bool, 0, 3), :alignment => (:Alignment, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :width => (:Int32, 0, 3), :family_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :rise_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :adjustment => (:GtkAdjustment, 0, 3), :wrap_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :is_expander => (:Bool, 0, 3), :family => (:String, 0, 3), :underline => (:Underline, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellRendererSpinLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :foreground => (:String, 0, 2), :height => (:Int32, 0, 3), :text => (:String, 0, 3), :size_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :cell_background => (:String, 0, 2), :xalign => (:Float32, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :mode => (:CellRendererMode, 0, 3), :background_rgba => (:GdkRGBA, 0, 3), :background => (:String, 0, 2), :foreground_rgba => (:GdkRGBA, 0, 3), :underline_set => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :scale_set => (:Bool, 0, 3), :digits => (:UInt32, 0, 3), :visible => (:Bool, 0, 3), :is_expanded => (:Bool, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :align_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :attributes => (:PangoAttrList, 0, 3), :style => (:Style, 0, 3), :climb_rate => (:Float64, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :ellipsize_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :editable_set => (:Bool, 0, 3), :language => (:String, 0, 3), :single_paragraph_mode => (:Bool, 0, 3), :alignment => (:Alignment, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :width => (:Int32, 0, 3), :family_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :rise_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :adjustment => (:GtkAdjustment, 0, 3), :wrap_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :markup => (:String, 0, 2), :is_expander => (:Bool, 0, 3), :family => (:String, 0, 3), :underline => (:Underline, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellRendererSpinner <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererSpinnerLeaf <: GtkCellRendererSpinner
            handle::Ptr{GObject}
            function GtkCellRendererSpinnerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererSpinnerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererSpinnerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererSpinnerLeaf, args))
            end
            w = GtkCellRendererSpinnerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererSpinner] = GtkCellRendererSpinnerLeaf
        function GtkCellRendererSpinner(args...; kwargs...)
            GtkCellRendererSpinnerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellRendererSpinnerLeaf) = begin
                    [:handle, :width, :cell_background_rgba, :active, :visible, :height, :size, :is_expanded, :cell_background, :editing, :xalign, :mode, :pulse, :cell_background_set, :sensitive, :ypad, :is_expander, :xpad, :yalign]
                end
            function Base.getproperty(o::GtkCellRendererSpinnerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :active => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :size => (:IconSize, 0, 3), :is_expanded => (:Bool, 0, 3), :editing => (:Bool, 0, 1), :xalign => (:Float32, 0, 3), :mode => (:CellRendererMode, 0, 3), :pulse => (:UInt32, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :is_expander => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :width => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellRendererSpinnerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :active => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :size => (:IconSize, 0, 3), :is_expanded => (:Bool, 0, 3), :cell_background => (:String, 0, 2), :xalign => (:Float32, 0, 3), :mode => (:CellRendererMode, 0, 3), :pulse => (:UInt32, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :is_expander => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :width => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellRendererToggle <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererToggleLeaf <: GtkCellRendererToggle
            handle::Ptr{GObject}
            function GtkCellRendererToggleLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererToggleLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererToggleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererToggleLeaf, args))
            end
            w = GtkCellRendererToggleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererToggle] = GtkCellRendererToggleLeaf
        function GtkCellRendererToggle(args...; kwargs...)
            GtkCellRendererToggleLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellRendererToggleLeaf) = begin
                    [:handle, :width, :cell_background_rgba, :active, :inconsistent, :visible, :height, :is_expanded, :cell_background, :editing, :xalign, :radio, :mode, :activatable, :cell_background_set, :sensitive, :ypad, :is_expander, :xpad, :yalign]
                end
            function Base.getproperty(o::GtkCellRendererToggleLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :active => (:Bool, 0, 3), :inconsistent => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :is_expanded => (:Bool, 0, 3), :editing => (:Bool, 0, 1), :xalign => (:Float32, 0, 3), :radio => (:Bool, 0, 3), :mode => (:CellRendererMode, 0, 3), :activatable => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :is_expander => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :width => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellRendererToggleLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:yalign => (:Float32, 0, 3), :cell_background_rgba => (:GdkRGBA, 0, 3), :active => (:Bool, 0, 3), :inconsistent => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :height => (:Int32, 0, 3), :is_expanded => (:Bool, 0, 3), :cell_background => (:String, 0, 2), :xalign => (:Float32, 0, 3), :radio => (:Bool, 0, 3), :mode => (:CellRendererMode, 0, 3), :activatable => (:Bool, 0, 3), :cell_background_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :ypad => (:UInt32, 0, 3), :is_expander => (:Bool, 0, 3), :xpad => (:UInt32, 0, 3), :width => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCellView <: GtkWidget end
    end
    begin
        mutable struct GtkCellViewLeaf <: GtkCellView
            handle::Ptr{GObject}
            function GtkCellViewLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCellViewLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellViewLeaf, args))
            end
            w = GtkCellViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellView] = GtkCellViewLeaf
        function GtkCellView(args...; kwargs...)
            GtkCellViewLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCellViewLeaf) = begin
                    [:handle, :draw_sensitive, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :fit_model, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :cell_area, :height_request, :layout_manager, :hexpand_set, :model, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :cell_area_context]
                end
            function Base.getproperty(o::GtkCellViewLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:draw_sensitive => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :fit_model => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :cell_area => (:GtkCellArea, 0, 11), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :model => (:GtkTreeModel, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :cell_area_context => (:GtkCellAreaContext, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCellViewLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:draw_sensitive => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :fit_model => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :cell_area => (:GtkCellArea, 0, 11), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :model => (:GtkTreeModel, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :cell_area_context => (:GtkCellAreaContext, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCenterBox <: GtkWidget end
    end
    begin
        mutable struct GtkCenterBoxLeaf <: GtkCenterBox
            handle::Ptr{GObject}
            function GtkCenterBoxLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCenterBoxLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCenterBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCenterBoxLeaf, args))
            end
            w = GtkCenterBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCenterBox] = GtkCenterBoxLeaf
        function GtkCenterBox(args...; kwargs...)
            GtkCenterBoxLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCenterBoxLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :baseline_position, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkCenterBoxLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCenterBoxLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCenterLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkCenterLayoutLeaf <: GtkCenterLayout
            handle::Ptr{GObject}
            function GtkCenterLayoutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCenterLayoutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCenterLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCenterLayoutLeaf, args))
            end
            w = GtkCenterLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCenterLayout] = GtkCenterLayoutLeaf
        function GtkCenterLayout(args...; kwargs...)
            GtkCenterLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCheckButton <: GtkWidget end
    end
    begin
        mutable struct GtkCheckButtonLeaf <: GtkCheckButton
            handle::Ptr{GObject}
            function GtkCheckButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCheckButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCheckButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCheckButtonLeaf, args))
            end
            w = GtkCheckButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCheckButton] = GtkCheckButtonLeaf
        function GtkCheckButton(args...; kwargs...)
            GtkCheckButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkCheckButtonLeaf) = begin
                    [:handle, :action_target, :group, :css_classes, :active, :visible, :inconsistent, :focusable, :has_default, :valign, :vexpand_set, :label, :use_underline, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :action_name, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkCheckButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_target => (:GVariant, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :active => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :inconsistent => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :label => (:String, 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkCheckButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_target => (:GVariant, 0, 3), :group => (:GtkCheckButton, 0, 2), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :active => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :inconsistent => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :label => (:String, 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkColorButton <: GtkWidget end
    end
    begin
        mutable struct GtkColorButtonLeaf <: GtkColorButton
            handle::Ptr{GObject}
            function GtkColorButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkColorButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColorButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColorButtonLeaf, args))
            end
            w = GtkColorButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColorButton] = GtkColorButtonLeaf
        function GtkColorButton(args...; kwargs...)
            GtkColorButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkColorButtonLeaf) = begin
                    [:handle, :use_alpha, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :show_editor, :has_tooltip, :overflow, :accessible_role, :title, :margin_start, :margin_end, :hexpand, :rgba, :receives_default, :tooltip_text, :halign, :can_focus, :modal, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkColorButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_alpha => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :show_editor => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :title => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :rgba => (:GdkRGBA, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkColorButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_alpha => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :show_editor => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :title => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :rgba => (:GdkRGBA, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkColorChooserDialog <: GtkDialog end
    end
    begin
        mutable struct GtkColorChooserDialogLeaf <: GtkColorChooserDialog
            handle::Ptr{GObject}
            function GtkColorChooserDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkColorChooserDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColorChooserDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColorChooserDialogLeaf, args))
            end
            w = GtkColorChooserDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColorChooserDialog] = GtkColorChooserDialogLeaf
        function GtkColorChooserDialog(args...; kwargs...)
            GtkColorChooserDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkColorChooserDialogLeaf) = begin
                    [:handle, :application, :hexpand, :halign, :name, :opacity, :use_header_bar, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :use_alpha, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :margin_end, :display, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :show_editor, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :rgba, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkColorChooserDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :use_alpha => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :show_editor => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :rgba => (:GdkRGBA, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkColorChooserDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :use_alpha => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :show_editor => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :rgba => (:GdkRGBA, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkColorChooserWidget <: GtkWidget end
    end
    begin
        mutable struct GtkColorChooserWidgetLeaf <: GtkColorChooserWidget
            handle::Ptr{GObject}
            function GtkColorChooserWidgetLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkColorChooserWidgetLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColorChooserWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColorChooserWidgetLeaf, args))
            end
            w = GtkColorChooserWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColorChooserWidget] = GtkColorChooserWidgetLeaf
        function GtkColorChooserWidget(args...; kwargs...)
            GtkColorChooserWidgetLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkColorChooserWidgetLeaf) = begin
                    [:handle, :use_alpha, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :show_editor, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :rgba, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkColorChooserWidgetLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_alpha => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :show_editor => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :rgba => (:GdkRGBA, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkColorChooserWidgetLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_alpha => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :show_editor => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :rgba => (:GdkRGBA, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkColumnView <: GtkWidget end
    end
    begin
        mutable struct GtkColumnViewLeaf <: GtkColumnView
            handle::Ptr{GObject}
            function GtkColumnViewLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkColumnViewLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColumnViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColumnViewLeaf, args))
            end
            w = GtkColumnViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColumnView] = GtkColumnViewLeaf
        function GtkColumnView(args...; kwargs...)
            GtkColumnViewLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkColumnViewLeaf) = begin
                    [:handle, :hscroll_policy, :hexpand, :show_row_separators, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :hadjustment, :columns, :overflow, :sorter, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :vscroll_policy, :margin_bottom, :show_column_separators, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :vadjustment, :model, :width_request, :cursor, :enable_rubberband, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :margin_start, :reorderable, :sensitive, :margin_top, :has_focus, :single_click_activate]
                end
            function Base.getproperty(o::GtkColumnViewLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hscroll_policy => (:ScrollablePolicy, 0, 3), :hexpand => (:Bool, 0, 3), :show_row_separators => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :hadjustment => (:GtkAdjustment, 0, 7), :columns => (:GListModel, 0, 1), :overflow => (:Overflow, 0, 3), :sorter => (:GtkSorter, 0, 1), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :show_column_separators => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :model => (:GtkSelectionModel, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :enable_rubberband => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :reorderable => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1), :single_click_activate => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkColumnViewLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :show_row_separators => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :hexpand_set => (:Bool, 0, 3), :model => (:GtkSelectionModel, 0, 3), :reorderable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :enable_rubberband => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :show_column_separators => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_top => (:Int32, 0, 3), :single_click_activate => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkColumnViewColumn <: GObject end
    end
    begin
        mutable struct GtkColumnViewColumnLeaf <: GtkColumnViewColumn
            handle::Ptr{GObject}
            function GtkColumnViewColumnLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkColumnViewColumnLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColumnViewColumnLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColumnViewColumnLeaf, args))
            end
            w = GtkColumnViewColumnLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColumnViewColumn] = GtkColumnViewColumnLeaf
        function GtkColumnViewColumn(args...; kwargs...)
            GtkColumnViewColumnLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkColumnViewColumnLeaf) = begin
                    [:handle, :factory, :expand, :column_view, :header_menu, :title, :sorter, :visible, :fixed_width, :resizable]
                end
            function Base.getproperty(o::GtkColumnViewColumnLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:factory => (:GtkListItemFactory, 0, 3), :expand => (:Bool, 0, 3), :column_view => (:GtkColumnView, 0, 1), :header_menu => (:GMenuModel, 0, 3), :title => (:String, 0, 3), :sorter => (:GtkSorter, 0, 3), :visible => (:Bool, 0, 3), :fixed_width => (:Int32, 0, 3), :resizable => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkColumnViewColumnLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:factory => (:GtkListItemFactory, 0, 3), :expand => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :header_menu => (:GMenuModel, 0, 3), :title => (:String, 0, 3), :sorter => (:GtkSorter, 0, 3), :fixed_width => (:Int32, 0, 3), :resizable => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkComboBox <: GtkWidget end
    end
    begin
        mutable struct GtkComboBoxLeaf <: GtkComboBox
            handle::Ptr{GObject}
            function GtkComboBoxLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkComboBoxLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkComboBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkComboBoxLeaf, args))
            end
            w = GtkComboBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkComboBox] = GtkComboBoxLeaf
        function GtkComboBox(args...; kwargs...)
            GtkComboBoxLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkComboBoxLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :child, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :popup_shown, :receives_default, :tooltip_text, :can_focus, :height_request, :has_entry, :hexpand_set, :margin_bottom, :editing_canceled, :root, :has_frame, :css_classes, :has_tooltip, :accessible_role, :margin_end, :active_id, :entry_text_column, :model, :width_request, :cursor, :tooltip_markup, :parent, :active, :focusable, :valign, :vexpand_set, :button_sensitivity, :margin_start, :id_column, :popup_fixed_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkComboBoxLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :popup_shown => (:Bool, 0, 1), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :has_entry => (:Bool, 0, 11), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :editing_canceled => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :has_frame => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :active_id => (:String, 0, 3), :entry_text_column => (:Int32, 0, 3), :model => (:GtkTreeModel, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :active => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :button_sensitivity => (:SensitivityType, 0, 3), :margin_start => (:Int32, 0, 3), :id_column => (:Int32, 0, 3), :popup_fixed_width => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkComboBoxLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :active => (:Int32, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :button_sensitivity => (:SensitivityType, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :active_id => (:String, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :entry_text_column => (:Int32, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :id_column => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :has_entry => (:Bool, 0, 11), :hexpand_set => (:Bool, 0, 3), :model => (:GtkTreeModel, 0, 3), :popup_fixed_width => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :editing_canceled => (:Bool, 0, 3), :has_frame => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkComboBoxText <: GtkComboBox end
    end
    begin
        mutable struct GtkComboBoxTextLeaf <: GtkComboBoxText
            handle::Ptr{GObject}
            function GtkComboBoxTextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkComboBoxTextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkComboBoxTextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkComboBoxTextLeaf, args))
            end
            w = GtkComboBoxTextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkComboBoxText] = GtkComboBoxTextLeaf
        function GtkComboBoxText(args...; kwargs...)
            GtkComboBoxTextLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkComboBoxTextLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :child, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :popup_shown, :receives_default, :tooltip_text, :can_focus, :height_request, :has_entry, :hexpand_set, :margin_bottom, :editing_canceled, :root, :has_frame, :css_classes, :has_tooltip, :accessible_role, :margin_end, :active_id, :entry_text_column, :model, :width_request, :cursor, :tooltip_markup, :parent, :active, :focusable, :valign, :vexpand_set, :button_sensitivity, :margin_start, :id_column, :popup_fixed_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkComboBoxTextLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :popup_shown => (:Bool, 0, 1), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :has_entry => (:Bool, 0, 11), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :editing_canceled => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :has_frame => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :active_id => (:String, 0, 3), :entry_text_column => (:Int32, 0, 3), :model => (:GtkTreeModel, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :active => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :button_sensitivity => (:SensitivityType, 0, 3), :margin_start => (:Int32, 0, 3), :id_column => (:Int32, 0, 3), :popup_fixed_width => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkComboBoxTextLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :active => (:Int32, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :button_sensitivity => (:SensitivityType, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :active_id => (:String, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :entry_text_column => (:Int32, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :id_column => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :has_entry => (:Bool, 0, 11), :hexpand_set => (:Bool, 0, 3), :model => (:GtkTreeModel, 0, 3), :popup_fixed_width => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :editing_canceled => (:Bool, 0, 3), :has_frame => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkConstraint <: GObject end
    end
    begin
        mutable struct GtkConstraintLeaf <: GtkConstraint
            handle::Ptr{GObject}
            function GtkConstraintLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkConstraintLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkConstraintLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkConstraintLeaf, args))
            end
            w = GtkConstraintLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkConstraint] = GtkConstraintLeaf
        function GtkConstraint(args...; kwargs...)
            GtkConstraintLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkConstraintLeaf) = begin
                    [:handle, :source_attribute, :strength, :constant, :multiplier, :target_attribute, :target, :source, :relation]
                end
            function Base.getproperty(o::GtkConstraintLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:relation => (:ConstraintRelation, 0, 11), :strength => (:Int32, 0, 11), :constant => (:Float64, 0, 11), :multiplier => (:Float64, 0, 11), :target_attribute => (:ConstraintAttribute, 0, 11), :source_attribute => (:ConstraintAttribute, 0, 11), :target => (:GtkConstraintTarget, 0, 11), :source => (:GtkConstraintTarget, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkConstraintLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:relation => (:ConstraintRelation, 0, 11), :strength => (:Int32, 0, 11), :constant => (:Float64, 0, 11), :multiplier => (:Float64, 0, 11), :target_attribute => (:ConstraintAttribute, 0, 11), :source_attribute => (:ConstraintAttribute, 0, 11), :target => (:GtkConstraintTarget, 0, 11), :source => (:GtkConstraintTarget, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkConstraintGuide <: GObject end
    end
    begin
        mutable struct GtkConstraintGuideLeaf <: GtkConstraintGuide
            handle::Ptr{GObject}
            function GtkConstraintGuideLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkConstraintGuideLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkConstraintGuideLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkConstraintGuideLeaf, args))
            end
            w = GtkConstraintGuideLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkConstraintGuide] = GtkConstraintGuideLeaf
        function GtkConstraintGuide(args...; kwargs...)
            GtkConstraintGuideLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkConstraintGuideLeaf) = begin
                    [:handle, :min_width, :nat_height, :max_height, :min_height, :strength, :name, :max_width, :nat_width]
                end
            function Base.getproperty(o::GtkConstraintGuideLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:min_width => (:Int32, 0, 3), :nat_height => (:Int32, 0, 3), :max_height => (:Int32, 0, 3), :min_height => (:Int32, 0, 3), :strength => (:ConstraintStrength, 0, 3), :name => (:String, 0, 3), :max_width => (:Int32, 0, 3), :nat_width => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkConstraintGuideLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:min_width => (:Int32, 0, 3), :nat_height => (:Int32, 0, 3), :max_height => (:Int32, 0, 3), :min_height => (:Int32, 0, 3), :strength => (:ConstraintStrength, 0, 3), :name => (:String, 0, 3), :max_width => (:Int32, 0, 3), :nat_width => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkConstraintLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkConstraintLayoutLeaf <: GtkConstraintLayout
            handle::Ptr{GObject}
            function GtkConstraintLayoutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkConstraintLayoutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkConstraintLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkConstraintLayoutLeaf, args))
            end
            w = GtkConstraintLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkConstraintLayout] = GtkConstraintLayoutLeaf
        function GtkConstraintLayout(args...; kwargs...)
            GtkConstraintLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkLayoutChild <: GObject end
    end
    begin
        mutable struct GtkLayoutChildLeaf <: GtkLayoutChild
            handle::Ptr{GObject}
            function GtkLayoutChildLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkLayoutChildLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLayoutChildLeaf, args))
            end
            w = GtkLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLayoutChild] = GtkLayoutChildLeaf
        function GtkLayoutChild(args...; kwargs...)
            GtkLayoutChildLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkLayoutChildLeaf) = begin
                    [:handle, :child_widget, :layout_manager]
                end
            function Base.getproperty(o::GtkLayoutChildLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child_widget => (:GtkWidget, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkLayoutChildLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child_widget => (:GtkWidget, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkConstraintLayoutChild <: GtkLayoutChild end
    end
    begin
        mutable struct GtkConstraintLayoutChildLeaf <: GtkConstraintLayoutChild
            handle::Ptr{GObject}
            function GtkConstraintLayoutChildLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkConstraintLayoutChildLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkConstraintLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkConstraintLayoutChildLeaf, args))
            end
            w = GtkConstraintLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkConstraintLayoutChild] = GtkConstraintLayoutChildLeaf
        function GtkConstraintLayoutChild(args...; kwargs...)
            GtkConstraintLayoutChildLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkConstraintLayoutChildLeaf) = begin
                    [:handle, :child_widget, :layout_manager]
                end
            function Base.getproperty(o::GtkConstraintLayoutChildLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child_widget => (:GtkWidget, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkConstraintLayoutChildLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child_widget => (:GtkWidget, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkCssProvider <: GObject end
    end
    begin
        mutable struct GtkCssProviderLeaf <: GtkCssProvider
            handle::Ptr{GObject}
            function GtkCssProviderLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCssProviderLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCssProviderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCssProviderLeaf, args))
            end
            w = GtkCssProviderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCssProvider] = GtkCssProviderLeaf
        function GtkCssProvider(args...; kwargs...)
            GtkCssProviderLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCustomFilter <: GtkFilter end
    end
    begin
        mutable struct GtkCustomFilterLeaf <: GtkCustomFilter
            handle::Ptr{GObject}
            function GtkCustomFilterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCustomFilterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCustomFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCustomFilterLeaf, args))
            end
            w = GtkCustomFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCustomFilter] = GtkCustomFilterLeaf
        function GtkCustomFilter(args...; kwargs...)
            GtkCustomFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCustomLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkCustomLayoutLeaf <: GtkCustomLayout
            handle::Ptr{GObject}
            function GtkCustomLayoutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCustomLayoutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCustomLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCustomLayoutLeaf, args))
            end
            w = GtkCustomLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCustomLayout] = GtkCustomLayoutLeaf
        function GtkCustomLayout(args...; kwargs...)
            GtkCustomLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSorter <: GObject end
    end
    begin
        mutable struct GtkSorterLeaf <: GtkSorter
            handle::Ptr{GObject}
            function GtkSorterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSorterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSorterLeaf, args))
            end
            w = GtkSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSorter] = GtkSorterLeaf
        function GtkSorter(args...; kwargs...)
            GtkSorterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCustomSorter <: GtkSorter end
    end
    begin
        mutable struct GtkCustomSorterLeaf <: GtkCustomSorter
            handle::Ptr{GObject}
            function GtkCustomSorterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkCustomSorterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCustomSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCustomSorterLeaf, args))
            end
            w = GtkCustomSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCustomSorter] = GtkCustomSorterLeaf
        function GtkCustomSorter(args...; kwargs...)
            GtkCustomSorterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDirectoryList <: GObject end
    end
    begin
        mutable struct GtkDirectoryListLeaf <: GtkDirectoryList
            handle::Ptr{GObject}
            function GtkDirectoryListLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkDirectoryListLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDirectoryListLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDirectoryListLeaf, args))
            end
            w = GtkDirectoryListLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDirectoryList] = GtkDirectoryListLeaf
        function GtkDirectoryList(args...; kwargs...)
            GtkDirectoryListLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkDirectoryListLeaf) = begin
                    [:handle, :attributes, :file, :io_priority, :error, :loading, :monitored]
                end
            function Base.getproperty(o::GtkDirectoryListLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:attributes => (:String, 0, 3), :file => (:GFile, 0, 3), :io_priority => (:Int32, 0, 3), :error => (:GError, 0, 1), :loading => (:Bool, 0, 1), :monitored => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkDirectoryListLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:attributes => (:String, 0, 3), :file => (:GFile, 0, 3), :io_priority => (:Int32, 0, 3), :monitored => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkDragIcon <: GtkWidget end
    end
    begin
        mutable struct GtkDragIconLeaf <: GtkDragIcon
            handle::Ptr{GObject}
            function GtkDragIconLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkDragIconLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDragIconLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDragIconLeaf, args))
            end
            w = GtkDragIconLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDragIcon] = GtkDragIconLeaf
        function GtkDragIcon(args...; kwargs...)
            GtkDragIconLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkDragIconLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkDragIconLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkDragIconLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEventController <: GObject end
    end
    begin
        mutable struct GtkEventControllerLeaf <: GtkEventController
            handle::Ptr{GObject}
            function GtkEventControllerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerLeaf, args))
            end
            w = GtkEventControllerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventController] = GtkEventControllerLeaf
        function GtkEventController(args...; kwargs...)
            GtkEventControllerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEventControllerLeaf) = begin
                    [:handle, :propagation_limit, :widget, :name, :propagation_phase]
                end
            function Base.getproperty(o::GtkEventControllerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEventControllerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGesture <: GtkEventController end
    end
    begin
        mutable struct GtkGestureLeaf <: GtkGesture
            handle::Ptr{GObject}
            function GtkGestureLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGestureLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureLeaf, args))
            end
            w = GtkGestureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGesture] = GtkGestureLeaf
        function GtkGesture(args...; kwargs...)
            GtkGestureLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGestureLeaf) = begin
                    [:handle, :propagation_limit, :widget, :name, :n_points, :propagation_phase]
                end
            function Base.getproperty(o::GtkGestureLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGestureLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGestureSingle <: GtkGesture end
    end
    begin
        mutable struct GtkGestureSingleLeaf <: GtkGestureSingle
            handle::Ptr{GObject}
            function GtkGestureSingleLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGestureSingleLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureSingleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureSingleLeaf, args))
            end
            w = GtkGestureSingleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureSingle] = GtkGestureSingleLeaf
        function GtkGestureSingle(args...; kwargs...)
            GtkGestureSingleLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGestureSingleLeaf) = begin
                    [:handle, :exclusive, :propagation_limit, :widget, :name, :n_points, :touch_only, :button, :propagation_phase]
                end
            function Base.getproperty(o::GtkGestureSingleLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGestureSingleLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkDragSource <: GtkGestureSingle end
    end
    begin
        mutable struct GtkDragSourceLeaf <: GtkDragSource
            handle::Ptr{GObject}
            function GtkDragSourceLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkDragSourceLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDragSourceLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDragSourceLeaf, args))
            end
            w = GtkDragSourceLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDragSource] = GtkDragSourceLeaf
        function GtkDragSource(args...; kwargs...)
            GtkDragSourceLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkDragSourceLeaf) = begin
                    [:handle, :exclusive, :propagation_limit, :widget, :actions, :name, :n_points, :touch_only, :content, :button, :propagation_phase]
                end
            function Base.getproperty(o::GtkDragSourceLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :actions => (:Int32, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :content => (:GdkContentProvider, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkDragSourceLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :actions => (:Int32, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :content => (:GdkContentProvider, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkDrawingArea <: GtkWidget end
    end
    begin
        mutable struct GtkDrawingAreaLeaf <: GtkDrawingArea
            handle::Ptr{GObject}
            function GtkDrawingAreaLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkDrawingAreaLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDrawingAreaLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDrawingAreaLeaf, args))
            end
            w = GtkDrawingAreaLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDrawingArea] = GtkDrawingAreaLeaf
        function GtkDrawingArea(args...; kwargs...)
            GtkDrawingAreaLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkDrawingAreaLeaf) = begin
                    [:handle, :css_classes, :content_width, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :content_height, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkDrawingAreaLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :content_width => (:Int32, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :content_height => (:Int32, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkDrawingAreaLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :content_width => (:Int32, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :content_height => (:Int32, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkDropControllerMotion <: GtkEventController end
    end
    begin
        mutable struct GtkDropControllerMotionLeaf <: GtkDropControllerMotion
            handle::Ptr{GObject}
            function GtkDropControllerMotionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkDropControllerMotionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDropControllerMotionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDropControllerMotionLeaf, args))
            end
            w = GtkDropControllerMotionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDropControllerMotion] = GtkDropControllerMotionLeaf
        function GtkDropControllerMotion(args...; kwargs...)
            GtkDropControllerMotionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkDropControllerMotionLeaf) = begin
                    [:handle, :propagation_limit, :widget, :is_pointer, :name, :drop, :contains_pointer, :propagation_phase]
                end
            function Base.getproperty(o::GtkDropControllerMotionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :is_pointer => (:Bool, 0, 1), :name => (:String, 0, 3), :drop => (:GdkDrop, 0, 1), :contains_pointer => (:Bool, 0, 1), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkDropControllerMotionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkDropDown <: GtkWidget end
    end
    begin
        mutable struct GtkDropDownLeaf <: GtkDropDown
            handle::Ptr{GObject}
            function GtkDropDownLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkDropDownLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDropDownLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDropDownLeaf, args))
            end
            w = GtkDropDownLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDropDown] = GtkDropDownLeaf
        function GtkDropDown(args...; kwargs...)
            GtkDropDownLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkDropDownLeaf) = begin
                    [:handle, :factory, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :list_factory, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :expression, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :selected_item, :model, :sensitive, :width_request, :enable_search, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :selected]
                end
            function Base.getproperty(o::GtkDropDownLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:factory => (:GtkListItemFactory, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :list_factory => (:GtkListItemFactory, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :expression => (:GtkExpression, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :selected_item => (:GObject, 0, 1), :model => (:GListModel, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :enable_search => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :selected => (:UInt32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkDropDownLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:factory => (:GtkListItemFactory, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :list_factory => (:GtkListItemFactory, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :expression => (:GtkExpression, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :model => (:GListModel, 0, 3), :enable_search => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :selected => (:UInt32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkDropTarget <: GtkEventController end
    end
    begin
        mutable struct GtkDropTargetLeaf <: GtkDropTarget
            handle::Ptr{GObject}
            function GtkDropTargetLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkDropTargetLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDropTargetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDropTargetLeaf, args))
            end
            w = GtkDropTargetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDropTarget] = GtkDropTargetLeaf
        function GtkDropTarget(args...; kwargs...)
            GtkDropTargetLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkDropTargetLeaf) = begin
                    [:handle, :propagation_limit, :value, :widget, :actions, :name, :preload, :current_drop, :formats, :propagation_phase]
                end
            function Base.getproperty(o::GtkDropTargetLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :value => (:GValue, 0, 1), :widget => (:GtkWidget, 0, 1), :actions => (:Int32, 0, 3), :name => (:String, 0, 3), :preload => (:Bool, 0, 3), :current_drop => (:GdkDrop, 0, 1), :formats => (:GdkContentFormats, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkDropTargetLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :actions => (:Int32, 0, 3), :preload => (:Bool, 0, 3), :name => (:String, 0, 3), :formats => (:GdkContentFormats, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkDropTargetAsync <: GtkEventController end
    end
    begin
        mutable struct GtkDropTargetAsyncLeaf <: GtkDropTargetAsync
            handle::Ptr{GObject}
            function GtkDropTargetAsyncLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkDropTargetAsyncLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDropTargetAsyncLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDropTargetAsyncLeaf, args))
            end
            w = GtkDropTargetAsyncLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDropTargetAsync] = GtkDropTargetAsyncLeaf
        function GtkDropTargetAsync(args...; kwargs...)
            GtkDropTargetAsyncLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkDropTargetAsyncLeaf) = begin
                    [:handle, :propagation_limit, :widget, :actions, :name, :formats, :propagation_phase]
                end
            function Base.getproperty(o::GtkDropTargetAsyncLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :actions => (:Int32, 0, 3), :name => (:String, 0, 3), :formats => (:GdkContentFormats, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkDropTargetAsyncLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :actions => (:Int32, 0, 3), :name => (:String, 0, 3), :formats => (:GdkContentFormats, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEditableLabel <: GtkWidget end
    end
    begin
        mutable struct GtkEditableLabelLeaf <: GtkEditableLabel
            handle::Ptr{GObject}
            function GtkEditableLabelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEditableLabelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEditableLabelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEditableLabelLeaf, args))
            end
            w = GtkEditableLabelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEditableLabel] = GtkEditableLabelLeaf
        function GtkEditableLabel(args...; kwargs...)
            GtkEditableLabelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEditableLabelLeaf) = begin
                    [:handle, :text, :xalign, :selection_bound, :cursor_position, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :max_width_chars, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :enable_undo, :has_tooltip, :accessible_role, :editing, :margin_end, :editable, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :width_chars, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkEditableLabelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:text => (:String, 0, 3), :xalign => (:Float32, 0, 3), :selection_bound => (:Int32, 0, 1), :cursor_position => (:Int32, 0, 1), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :enable_undo => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :editing => (:Bool, 0, 1), :margin_end => (:Int32, 0, 3), :editable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEditableLabelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :text => (:String, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :enable_undo => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :has_tooltip => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :xalign => (:Float32, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPopover <: GtkWidget end
    end
    begin
        mutable struct GtkPopoverLeaf <: GtkPopover
            handle::Ptr{GObject}
            function GtkPopoverLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPopoverLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPopoverLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPopoverLeaf, args))
            end
            w = GtkPopoverLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPopover] = GtkPopoverLeaf
        function GtkPopover(args...; kwargs...)
            GtkPopoverLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPopoverLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :child, :focus_on_click, :vexpand, :can_target, :css_name, :mnemonics_visible, :scale_factor, :pointing_to, :position, :visible, :has_default, :has_arrow, :overflow, :default_widget, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :cascade_popdown, :margin_start, :autohide, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkPopoverLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :pointing_to => (:GdkRectangle, 0, 3), :position => (:PositionType, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :has_arrow => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :cascade_popdown => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :autohide => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPopoverLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pointing_to => (:GdkRectangle, 0, 3), :position => (:PositionType, 0, 3), :visible => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_arrow => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :cascade_popdown => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :default_widget => (:GtkWidget, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :autohide => (:Bool, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEmojiChooser <: GtkPopover end
    end
    begin
        mutable struct GtkEmojiChooserLeaf <: GtkEmojiChooser
            handle::Ptr{GObject}
            function GtkEmojiChooserLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEmojiChooserLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEmojiChooserLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEmojiChooserLeaf, args))
            end
            w = GtkEmojiChooserLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEmojiChooser] = GtkEmojiChooserLeaf
        function GtkEmojiChooser(args...; kwargs...)
            GtkEmojiChooserLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEmojiChooserLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :child, :focus_on_click, :vexpand, :can_target, :css_name, :mnemonics_visible, :scale_factor, :pointing_to, :position, :visible, :has_default, :has_arrow, :overflow, :default_widget, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :cascade_popdown, :margin_start, :autohide, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkEmojiChooserLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :pointing_to => (:GdkRectangle, 0, 3), :position => (:PositionType, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :has_arrow => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :cascade_popdown => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :autohide => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEmojiChooserLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pointing_to => (:GdkRectangle, 0, 3), :position => (:PositionType, 0, 3), :visible => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_arrow => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :cascade_popdown => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :default_widget => (:GtkWidget, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :autohide => (:Bool, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEntry <: GtkWidget end
    end
    begin
        mutable struct GtkEntryLeaf <: GtkEntry
            handle::Ptr{GObject}
            function GtkEntryLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEntryLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEntryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEntryLeaf, args))
            end
            w = GtkEntryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEntry] = GtkEntryLeaf
        function GtkEntry(args...; kwargs...)
            GtkEntryLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEntryLeaf) = begin
                    [:handle, :placeholder_text, :text, :xalign, :progress_pulse_step, :completion, :selection_bound, :cursor_position, :extra_menu, :hexpand, :tabs, :halign, :name, :opacity, :layout_manager, :focus_on_click, :enable_emoji_completion, :vexpand, :can_target, :css_name, :invisible_char_set, :scale_factor, :activates_default, :visible, :primary_icon_sensitive, :has_default, :secondary_icon_storage_type, :buffer, :text_length, :overflow, :visibility, :progress_fraction, :max_width_chars, :receives_default, :attributes, :tooltip_text, :can_focus, :secondary_icon_tooltip_text, :input_purpose, :height_request, :hexpand_set, :primary_icon_name, :primary_icon_gicon, :margin_bottom, :editing_canceled, :root, :primary_icon_storage_type, :has_frame, :secondary_icon_activatable, :css_classes, :enable_undo, :has_tooltip, :accessible_role, :margin_end, :scroll_offset, :truncate_multiline, :overwrite_mode, :primary_icon_activatable, :secondary_icon_name, :editable, :secondary_icon_sensitive, :width_request, :cursor, :tooltip_markup, :im_module, :parent, :secondary_icon_tooltip_markup, :focusable, :valign, :vexpand_set, :invisible_char, :width_chars, :show_emoji_icon, :primary_icon_paintable, :primary_icon_tooltip_text, :margin_start, :input_hints, :primary_icon_tooltip_markup, :max_length, :secondary_icon_paintable, :sensitive, :margin_top, :secondary_icon_gicon, :has_focus]
                end
            function Base.getproperty(o::GtkEntryLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :text => (:String, 0, 3), :xalign => (:Float32, 0, 3), :progress_pulse_step => (:Float64, 0, 3), :completion => (:GtkEntryCompletion, 0, 3), :selection_bound => (:Int32, 0, 1), :cursor_position => (:Int32, 0, 1), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :tabs => (:PangoTabArray, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :enable_emoji_completion => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :invisible_char_set => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :activates_default => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :primary_icon_sensitive => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :secondary_icon_storage_type => (:ImageType, 0, 1), :buffer => (:GtkEntryBuffer, 0, 7), :text_length => (:UInt32, 0, 1), :overflow => (:Overflow, 0, 3), :visibility => (:Bool, 0, 3), :progress_fraction => (:Float64, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :attributes => (:PangoAttrList, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :secondary_icon_tooltip_text => (:String, 0, 3), :input_purpose => (:InputPurpose, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :primary_icon_name => (:String, 0, 3), :primary_icon_gicon => (:GIcon, 0, 3), :margin_bottom => (:Int32, 0, 3), :editing_canceled => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :primary_icon_storage_type => (:ImageType, 0, 1), :has_frame => (:Bool, 0, 3), :secondary_icon_activatable => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :enable_undo => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :scroll_offset => (:Int32, 0, 1), :truncate_multiline => (:Bool, 0, 3), :overwrite_mode => (:Bool, 0, 3), :primary_icon_activatable => (:Bool, 0, 3), :secondary_icon_name => (:String, 0, 3), :editable => (:Bool, 0, 3), :secondary_icon_sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :im_module => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :secondary_icon_tooltip_markup => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :invisible_char => (:UInt32, 0, 3), :width_chars => (:Int32, 0, 3), :show_emoji_icon => (:Bool, 0, 3), :primary_icon_paintable => (:GdkPaintable, 0, 3), :primary_icon_tooltip_text => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :input_hints => (:Int32, 0, 3), :primary_icon_tooltip_markup => (:String, 0, 3), :max_length => (:Int32, 0, 3), :secondary_icon_paintable => (:GdkPaintable, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :secondary_icon_gicon => (:GIcon, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEntryLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :text => (:String, 0, 3), :xalign => (:Float32, 0, 3), :progress_pulse_step => (:Float64, 0, 3), :completion => (:GtkEntryCompletion, 0, 3), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :tabs => (:PangoTabArray, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :enable_emoji_completion => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :invisible_char_set => (:Bool, 0, 3), :activates_default => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :primary_icon_sensitive => (:Bool, 0, 3), :buffer => (:GtkEntryBuffer, 0, 7), :overflow => (:Overflow, 0, 3), :visibility => (:Bool, 0, 3), :progress_fraction => (:Float64, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :attributes => (:PangoAttrList, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :secondary_icon_tooltip_text => (:String, 0, 3), :input_purpose => (:InputPurpose, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :primary_icon_name => (:String, 0, 3), :primary_icon_gicon => (:GIcon, 0, 3), :margin_bottom => (:Int32, 0, 3), :editing_canceled => (:Bool, 0, 3), :has_frame => (:Bool, 0, 3), :secondary_icon_activatable => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :enable_undo => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :truncate_multiline => (:Bool, 0, 3), :overwrite_mode => (:Bool, 0, 3), :primary_icon_activatable => (:Bool, 0, 3), :secondary_icon_name => (:String, 0, 3), :editable => (:Bool, 0, 3), :secondary_icon_sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :im_module => (:String, 0, 3), :secondary_icon_tooltip_markup => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :invisible_char => (:UInt32, 0, 3), :width_chars => (:Int32, 0, 3), :show_emoji_icon => (:Bool, 0, 3), :primary_icon_paintable => (:GdkPaintable, 0, 3), :primary_icon_tooltip_text => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :input_hints => (:Int32, 0, 3), :primary_icon_tooltip_markup => (:String, 0, 3), :max_length => (:Int32, 0, 3), :secondary_icon_paintable => (:GdkPaintable, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :secondary_icon_gicon => (:GIcon, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEntryBuffer <: GObject end
    end
    begin
        mutable struct GtkEntryBufferLeaf <: GtkEntryBuffer
            handle::Ptr{GObject}
            function GtkEntryBufferLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEntryBufferLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEntryBufferLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEntryBufferLeaf, args))
            end
            w = GtkEntryBufferLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEntryBuffer] = GtkEntryBufferLeaf
        function GtkEntryBuffer(args...; kwargs...)
            GtkEntryBufferLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEntryBufferLeaf) = begin
                    [:handle, :max_length, :text, :length]
                end
            function Base.getproperty(o::GtkEntryBufferLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:max_length => (:Int32, 0, 3), :text => (:String, 0, 3), :length => (:UInt32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEntryBufferLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:max_length => (:Int32, 0, 3), :text => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEntryCompletion <: GObject end
    end
    begin
        mutable struct GtkEntryCompletionLeaf <: GtkEntryCompletion
            handle::Ptr{GObject}
            function GtkEntryCompletionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEntryCompletionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEntryCompletionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEntryCompletionLeaf, args))
            end
            w = GtkEntryCompletionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEntryCompletion] = GtkEntryCompletionLeaf
        function GtkEntryCompletion(args...; kwargs...)
            GtkEntryCompletionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEntryCompletionLeaf) = begin
                    [:handle, :inline_selection, :cell_area, :minimum_key_length, :popup_set_width, :text_column, :popup_completion, :model, :popup_single_match, :inline_completion]
                end
            function Base.getproperty(o::GtkEntryCompletionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:inline_selection => (:Bool, 0, 3), :cell_area => (:GtkCellArea, 0, 11), :minimum_key_length => (:Int32, 0, 3), :popup_set_width => (:Bool, 0, 3), :text_column => (:Int32, 0, 3), :popup_completion => (:Bool, 0, 3), :model => (:GtkTreeModel, 0, 3), :popup_single_match => (:Bool, 0, 3), :inline_completion => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEntryCompletionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:inline_selection => (:Bool, 0, 3), :cell_area => (:GtkCellArea, 0, 11), :minimum_key_length => (:Int32, 0, 3), :popup_set_width => (:Bool, 0, 3), :text_column => (:Int32, 0, 3), :popup_completion => (:Bool, 0, 3), :model => (:GtkTreeModel, 0, 3), :popup_single_match => (:Bool, 0, 3), :inline_completion => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEventControllerFocus <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerFocusLeaf <: GtkEventControllerFocus
            handle::Ptr{GObject}
            function GtkEventControllerFocusLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerFocusLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerFocusLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerFocusLeaf, args))
            end
            w = GtkEventControllerFocusLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerFocus] = GtkEventControllerFocusLeaf
        function GtkEventControllerFocus(args...; kwargs...)
            GtkEventControllerFocusLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEventControllerFocusLeaf) = begin
                    [:handle, :propagation_limit, :is_focus, :widget, :contains_focus, :name, :propagation_phase]
                end
            function Base.getproperty(o::GtkEventControllerFocusLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :is_focus => (:Bool, 0, 1), :widget => (:GtkWidget, 0, 1), :contains_focus => (:Bool, 0, 1), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEventControllerFocusLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEventControllerKey <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerKeyLeaf <: GtkEventControllerKey
            handle::Ptr{GObject}
            function GtkEventControllerKeyLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerKeyLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerKeyLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerKeyLeaf, args))
            end
            w = GtkEventControllerKeyLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerKey] = GtkEventControllerKeyLeaf
        function GtkEventControllerKey(args...; kwargs...)
            GtkEventControllerKeyLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEventControllerKeyLeaf) = begin
                    [:handle, :propagation_limit, :widget, :name, :propagation_phase]
                end
            function Base.getproperty(o::GtkEventControllerKeyLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEventControllerKeyLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEventControllerLegacy <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerLegacyLeaf <: GtkEventControllerLegacy
            handle::Ptr{GObject}
            function GtkEventControllerLegacyLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerLegacyLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerLegacyLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerLegacyLeaf, args))
            end
            w = GtkEventControllerLegacyLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerLegacy] = GtkEventControllerLegacyLeaf
        function GtkEventControllerLegacy(args...; kwargs...)
            GtkEventControllerLegacyLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEventControllerLegacyLeaf) = begin
                    [:handle, :propagation_limit, :widget, :name, :propagation_phase]
                end
            function Base.getproperty(o::GtkEventControllerLegacyLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEventControllerLegacyLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEventControllerMotion <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerMotionLeaf <: GtkEventControllerMotion
            handle::Ptr{GObject}
            function GtkEventControllerMotionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerMotionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerMotionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerMotionLeaf, args))
            end
            w = GtkEventControllerMotionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerMotion] = GtkEventControllerMotionLeaf
        function GtkEventControllerMotion(args...; kwargs...)
            GtkEventControllerMotionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEventControllerMotionLeaf) = begin
                    [:handle, :propagation_limit, :widget, :is_pointer, :name, :contains_pointer, :propagation_phase]
                end
            function Base.getproperty(o::GtkEventControllerMotionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :is_pointer => (:Bool, 0, 1), :name => (:String, 0, 3), :contains_pointer => (:Bool, 0, 1), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEventControllerMotionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEventControllerScroll <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerScrollLeaf <: GtkEventControllerScroll
            handle::Ptr{GObject}
            function GtkEventControllerScrollLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerScrollLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerScrollLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerScrollLeaf, args))
            end
            w = GtkEventControllerScrollLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerScroll] = GtkEventControllerScrollLeaf
        function GtkEventControllerScroll(args...; kwargs...)
            GtkEventControllerScrollLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkEventControllerScrollLeaf) = begin
                    [:handle, :propagation_limit, :widget, :flags, :name, :propagation_phase]
                end
            function Base.getproperty(o::GtkEventControllerScrollLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :flags => (:Int32, 0, 3), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkEventControllerScrollLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :flags => (:Int32, 0, 3), :name => (:String, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkEveryFilter <: GtkMultiFilter end
    end
    begin
        mutable struct GtkEveryFilterLeaf <: GtkEveryFilter
            handle::Ptr{GObject}
            function GtkEveryFilterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkEveryFilterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEveryFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEveryFilterLeaf, args))
            end
            w = GtkEveryFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEveryFilter] = GtkEveryFilterLeaf
        function GtkEveryFilter(args...; kwargs...)
            GtkEveryFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkExpander <: GtkWidget end
    end
    begin
        mutable struct GtkExpanderLeaf <: GtkExpander
            handle::Ptr{GObject}
            function GtkExpanderLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkExpanderLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkExpanderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkExpanderLeaf, args))
            end
            w = GtkExpanderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkExpander] = GtkExpanderLeaf
        function GtkExpander(args...; kwargs...)
            GtkExpanderLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkExpanderLeaf) = begin
                    [:handle, :css_classes, :visible, :label, :focusable, :has_default, :valign, :vexpand_set, :use_underline, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :expanded, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :use_markup, :hexpand_set, :resize_toplevel, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :label_widget]
                end
            function Base.getproperty(o::GtkExpanderLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :label => (:String, 0, 7), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :use_underline => (:Bool, 0, 7), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :expanded => (:Bool, 0, 7), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :use_markup => (:Bool, 0, 7), :hexpand_set => (:Bool, 0, 3), :resize_toplevel => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :label_widget => (:GtkWidget, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkExpanderLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :label => (:String, 0, 7), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :use_underline => (:Bool, 0, 7), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :expanded => (:Bool, 0, 7), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :use_markup => (:Bool, 0, 7), :hexpand_set => (:Bool, 0, 3), :resize_toplevel => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :label_widget => (:GtkWidget, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFileChooserDialog <: GtkDialog end
    end
    begin
        mutable struct GtkFileChooserDialogLeaf <: GtkFileChooserDialog
            handle::Ptr{GObject}
            function GtkFileChooserDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFileChooserDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFileChooserDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFileChooserDialogLeaf, args))
            end
            w = GtkFileChooserDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFileChooserDialog] = GtkFileChooserDialogLeaf
        function GtkFileChooserDialog(args...; kwargs...)
            GtkFileChooserDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFileChooserDialogLeaf) = begin
                    [:handle, :application, :filter, :hexpand, :halign, :name, :opacity, :use_header_bar, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :visible, :create_folders, :has_default, :resizable, :overflow, :title, :shortcut_folders, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :margin_end, :display, :width_request, :cursor, :focus_visible, :tooltip_markup, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :action, :margin_start, :select_multiple, :hide_on_close, :focus_widget, :filters, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkFileChooserDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :filter => (:GtkFileFilter, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :create_folders => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :shortcut_folders => (:GListModel, 0, 1), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :focus_visible => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :action => (:FileChooserAction, 0, 3), :margin_start => (:Int32, 0, 3), :select_multiple => (:Bool, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :filters => (:GListModel, 0, 1), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFileChooserDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :filter => (:GtkFileFilter, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :create_folders => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :focus_visible => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :action => (:FileChooserAction, 0, 3), :margin_start => (:Int32, 0, 3), :select_multiple => (:Bool, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkNativeDialog <: GObject end
    end
    begin
        mutable struct GtkNativeDialogLeaf <: GtkNativeDialog
            handle::Ptr{GObject}
            function GtkNativeDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkNativeDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNativeDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNativeDialogLeaf, args))
            end
            w = GtkNativeDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNativeDialog] = GtkNativeDialogLeaf
        function GtkNativeDialog(args...; kwargs...)
            GtkNativeDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkNativeDialogLeaf) = begin
                    [:handle, :transient_for, :modal, :visible, :title]
                end
            function Base.getproperty(o::GtkNativeDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:transient_for => (:GtkWindow, 0, 7), :modal => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :title => (:String, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkNativeDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:transient_for => (:GtkWindow, 0, 7), :modal => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :title => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFileChooserNative <: GtkNativeDialog end
    end
    begin
        mutable struct GtkFileChooserNativeLeaf <: GtkFileChooserNative
            handle::Ptr{GObject}
            function GtkFileChooserNativeLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFileChooserNativeLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFileChooserNativeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFileChooserNativeLeaf, args))
            end
            w = GtkFileChooserNativeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFileChooserNative] = GtkFileChooserNativeLeaf
        function GtkFileChooserNative(args...; kwargs...)
            GtkFileChooserNativeLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFileChooserNativeLeaf) = begin
                    [:handle, :visible, :create_folders, :transient_for, :filter, :title, :action, :shortcut_folders, :select_multiple, :filters, :modal, :accept_label, :cancel_label]
                end
            function Base.getproperty(o::GtkFileChooserNativeLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:visible => (:Bool, 0, 3), :create_folders => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :filter => (:GtkFileFilter, 0, 3), :title => (:String, 0, 3), :action => (:FileChooserAction, 0, 3), :shortcut_folders => (:GListModel, 0, 1), :select_multiple => (:Bool, 0, 3), :filters => (:GListModel, 0, 1), :modal => (:Bool, 0, 3), :accept_label => (:String, 0, 3), :cancel_label => (:String, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFileChooserNativeLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:transient_for => (:GtkWindow, 0, 7), :filter => (:GtkFileFilter, 0, 3), :modal => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :create_folders => (:Bool, 0, 3), :title => (:String, 0, 3), :action => (:FileChooserAction, 0, 3), :accept_label => (:String, 0, 3), :select_multiple => (:Bool, 0, 3), :cancel_label => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFileChooserWidget <: GtkWidget end
    end
    begin
        mutable struct GtkFileChooserWidgetLeaf <: GtkFileChooserWidget
            handle::Ptr{GObject}
            function GtkFileChooserWidgetLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFileChooserWidgetLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFileChooserWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFileChooserWidgetLeaf, args))
            end
            w = GtkFileChooserWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFileChooserWidget] = GtkFileChooserWidgetLeaf
        function GtkFileChooserWidget(args...; kwargs...)
            GtkFileChooserWidgetLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFileChooserWidgetLeaf) = begin
                    [:handle, :subtitle, :filter, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :search_mode, :vexpand, :can_target, :css_name, :scale_factor, :visible, :create_folders, :has_default, :overflow, :shortcut_folders, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :action, :margin_start, :select_multiple, :filters, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkFileChooserWidgetLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:subtitle => (:String, 0, 1), :filter => (:GtkFileFilter, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :search_mode => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :create_folders => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :shortcut_folders => (:GListModel, 0, 1), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :action => (:FileChooserAction, 0, 3), :margin_start => (:Int32, 0, 3), :select_multiple => (:Bool, 0, 3), :filters => (:GListModel, 0, 1), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFileChooserWidgetLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :create_folders => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :filter => (:GtkFileFilter, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :action => (:FileChooserAction, 0, 3), :margin_end => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :select_multiple => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :search_mode => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_bottom => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFileFilter <: GtkFilter end
    end
    begin
        mutable struct GtkFileFilterLeaf <: GtkFileFilter
            handle::Ptr{GObject}
            function GtkFileFilterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFileFilterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFileFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFileFilterLeaf, args))
            end
            w = GtkFileFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFileFilter] = GtkFileFilterLeaf
        function GtkFileFilter(args...; kwargs...)
            GtkFileFilterLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFileFilterLeaf) = begin
                    [:handle, :name]
                end
            function Base.getproperty(o::GtkFileFilterLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:name => (:String, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFileFilterLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:name => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFilterListModel <: GObject end
    end
    begin
        mutable struct GtkFilterListModelLeaf <: GtkFilterListModel
            handle::Ptr{GObject}
            function GtkFilterListModelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFilterListModelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFilterListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFilterListModelLeaf, args))
            end
            w = GtkFilterListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFilterListModel] = GtkFilterListModelLeaf
        function GtkFilterListModel(args...; kwargs...)
            GtkFilterListModelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFilterListModelLeaf) = begin
                    [:handle, :filter, :pending, :model, :incremental]
                end
            function Base.getproperty(o::GtkFilterListModelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:filter => (:GtkFilter, 0, 3), :pending => (:UInt32, 0, 1), :model => (:GListModel, 0, 3), :incremental => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFilterListModelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:filter => (:GtkFilter, 0, 3), :model => (:GListModel, 0, 3), :incremental => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFixed <: GtkWidget end
    end
    begin
        mutable struct GtkFixedLeaf <: GtkFixed
            handle::Ptr{GObject}
            function GtkFixedLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFixedLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFixedLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFixedLeaf, args))
            end
            w = GtkFixedLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFixed] = GtkFixedLeaf
        function GtkFixed(args...; kwargs...)
            GtkFixedLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFixedLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkFixedLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFixedLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFixedLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkFixedLayoutLeaf <: GtkFixedLayout
            handle::Ptr{GObject}
            function GtkFixedLayoutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFixedLayoutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFixedLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFixedLayoutLeaf, args))
            end
            w = GtkFixedLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFixedLayout] = GtkFixedLayoutLeaf
        function GtkFixedLayout(args...; kwargs...)
            GtkFixedLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFixedLayoutChild <: GtkLayoutChild end
    end
    begin
        mutable struct GtkFixedLayoutChildLeaf <: GtkFixedLayoutChild
            handle::Ptr{GObject}
            function GtkFixedLayoutChildLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFixedLayoutChildLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFixedLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFixedLayoutChildLeaf, args))
            end
            w = GtkFixedLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFixedLayoutChild] = GtkFixedLayoutChildLeaf
        function GtkFixedLayoutChild(args...; kwargs...)
            GtkFixedLayoutChildLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFixedLayoutChildLeaf) = begin
                    [:handle, :child_widget, :layout_manager, :transform]
                end
            function Base.getproperty(o::GtkFixedLayoutChildLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child_widget => (:GtkWidget, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 11), :transform => (:GskTransform, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFixedLayoutChildLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child_widget => (:GtkWidget, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 11), :transform => (:GskTransform, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFlattenListModel <: GObject end
    end
    begin
        mutable struct GtkFlattenListModelLeaf <: GtkFlattenListModel
            handle::Ptr{GObject}
            function GtkFlattenListModelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFlattenListModelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFlattenListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFlattenListModelLeaf, args))
            end
            w = GtkFlattenListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFlattenListModel] = GtkFlattenListModelLeaf
        function GtkFlattenListModel(args...; kwargs...)
            GtkFlattenListModelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFlattenListModelLeaf) = begin
                    [:handle, :model]
                end
            function Base.getproperty(o::GtkFlattenListModelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GListModel, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFlattenListModelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GListModel, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFlowBox <: GtkWidget end
    end
    begin
        mutable struct GtkFlowBoxLeaf <: GtkFlowBox
            handle::Ptr{GObject}
            function GtkFlowBoxLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFlowBoxLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFlowBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFlowBoxLeaf, args))
            end
            w = GtkFlowBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFlowBox] = GtkFlowBoxLeaf
        function GtkFlowBox(args...; kwargs...)
            GtkFlowBoxLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFlowBoxLeaf) = begin
                    [:handle, :hexpand, :halign, :activate_on_single_click, :row_spacing, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :homogeneous, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :max_children_per_line, :column_spacing, :width_request, :cursor, :tooltip_markup, :min_children_per_line, :parent, :selection_mode, :focusable, :valign, :vexpand_set, :orientation, :margin_start, :accept_unpaired_release, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkFlowBoxLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :activate_on_single_click => (:Bool, 0, 3), :row_spacing => (:UInt32, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :homogeneous => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :max_children_per_line => (:UInt32, 0, 3), :column_spacing => (:UInt32, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :min_children_per_line => (:UInt32, 0, 3), :parent => (:GtkWidget, 0, 1), :selection_mode => (:SelectionMode, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :margin_start => (:Int32, 0, 3), :accept_unpaired_release => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFlowBoxLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :homogeneous => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :accept_unpaired_release => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :max_children_per_line => (:UInt32, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :activate_on_single_click => (:Bool, 0, 3), :row_spacing => (:UInt32, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :can_focus => (:Bool, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :column_spacing => (:UInt32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :min_children_per_line => (:UInt32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :margin_top => (:Int32, 0, 3), :selection_mode => (:SelectionMode, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFlowBoxChild <: GtkWidget end
    end
    begin
        mutable struct GtkFlowBoxChildLeaf <: GtkFlowBoxChild
            handle::Ptr{GObject}
            function GtkFlowBoxChildLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFlowBoxChildLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFlowBoxChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFlowBoxChildLeaf, args))
            end
            w = GtkFlowBoxChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFlowBoxChild] = GtkFlowBoxChildLeaf
        function GtkFlowBoxChild(args...; kwargs...)
            GtkFlowBoxChildLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFlowBoxChildLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkFlowBoxChildLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFlowBoxChildLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFontButton <: GtkWidget end
    end
    begin
        mutable struct GtkFontButtonLeaf <: GtkFontButton
            handle::Ptr{GObject}
            function GtkFontButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFontButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFontButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFontButtonLeaf, args))
            end
            w = GtkFontButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFontButton] = GtkFontButtonLeaf
        function GtkFontButton(args...; kwargs...)
            GtkFontButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFontButtonLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :level, :focus_on_click, :vexpand, :can_target, :css_name, :preview_text, :scale_factor, :visible, :has_default, :overflow, :title, :use_size, :receives_default, :tooltip_text, :can_focus, :modal, :show_preview_entry, :height_request, :hexpand_set, :margin_bottom, :root, :use_font, :css_classes, :has_tooltip, :accessible_role, :font_desc, :margin_end, :width_request, :cursor, :tooltip_markup, :font_features, :language, :parent, :focusable, :valign, :vexpand_set, :font, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkFontButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :level => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :preview_text => (:String, 0, 3), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :use_size => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :show_preview_entry => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :use_font => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :margin_end => (:Int32, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :font_features => (:String, 0, 1), :language => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :font => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFontButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_font => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :font => (:String, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :title => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :use_size => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :show_preview_entry => (:Bool, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :level => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_bottom => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :language => (:String, 0, 3), :margin_top => (:Int32, 0, 3), :preview_text => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFontChooserDialog <: GtkDialog end
    end
    begin
        mutable struct GtkFontChooserDialogLeaf <: GtkFontChooserDialog
            handle::Ptr{GObject}
            function GtkFontChooserDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFontChooserDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFontChooserDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFontChooserDialogLeaf, args))
            end
            w = GtkFontChooserDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFontChooserDialog] = GtkFontChooserDialogLeaf
        function GtkFontChooserDialog(args...; kwargs...)
            GtkFontChooserDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFontChooserDialogLeaf) = begin
                    [:handle, :application, :hexpand, :halign, :name, :opacity, :use_header_bar, :layout_manager, :default_height, :child, :level, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :preview_text, :scale_factor, :fullscreened, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :show_preview_entry, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :font_desc, :margin_end, :display, :width_request, :cursor, :focus_visible, :font_features, :language, :tooltip_markup, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :font, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkFontChooserDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :level => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :preview_text => (:String, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :show_preview_entry => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :focus_visible => (:Bool, 0, 3), :font_features => (:String, 0, 1), :language => (:String, 0, 3), :tooltip_markup => (:String, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :font => (:String, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFontChooserDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :level => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :preview_text => (:String, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :show_preview_entry => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :focus_visible => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :language => (:String, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :font => (:String, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFontChooserWidget <: GtkWidget end
    end
    begin
        mutable struct GtkFontChooserWidgetLeaf <: GtkFontChooserWidget
            handle::Ptr{GObject}
            function GtkFontChooserWidgetLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFontChooserWidgetLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFontChooserWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFontChooserWidgetLeaf, args))
            end
            w = GtkFontChooserWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFontChooserWidget] = GtkFontChooserWidgetLeaf
        function GtkFontChooserWidget(args...; kwargs...)
            GtkFontChooserWidgetLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFontChooserWidgetLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :level, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :preview_text, :visible, :has_default, :overflow, :receives_default, :tooltip_text, :can_focus, :show_preview_entry, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :font_desc, :tweak_action, :margin_end, :width_request, :cursor, :tooltip_markup, :font_features, :language, :parent, :focusable, :valign, :vexpand_set, :font, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkFontChooserWidgetLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :level => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :preview_text => (:String, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :show_preview_entry => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :tweak_action => (:GAction, 0, 1), :margin_end => (:Int32, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :font_features => (:String, 0, 1), :language => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :font => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFontChooserWidgetLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :font => (:String, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :show_preview_entry => (:Bool, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :level => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_bottom => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :language => (:String, 0, 3), :margin_top => (:Int32, 0, 3), :preview_text => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkFrame <: GtkWidget end
    end
    begin
        mutable struct GtkFrameLeaf <: GtkFrame
            handle::Ptr{GObject}
            function GtkFrameLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkFrameLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFrameLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFrameLeaf, args))
            end
            w = GtkFrameLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFrame] = GtkFrameLeaf
        function GtkFrame(args...; kwargs...)
            GtkFrameLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkFrameLeaf) = begin
                    [:handle, :scale_factor, :css_classes, :visible, :label, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :label_xalign, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :label_widget]
                end
            function Base.getproperty(o::GtkFrameLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:label_widget => (:GtkWidget, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :label_xalign => (:Float32, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :scale_factor => (:Int32, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkFrameLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :label_xalign => (:Float32, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :label_widget => (:GtkWidget, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGLArea <: GtkWidget end
    end
    begin
        mutable struct GtkGLAreaLeaf <: GtkGLArea
            handle::Ptr{GObject}
            function GtkGLAreaLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGLAreaLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGLAreaLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGLAreaLeaf, args))
            end
            w = GtkGLAreaLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGLArea] = GtkGLAreaLeaf
        function GtkGLArea(args...; kwargs...)
            GtkGLAreaLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGLAreaLeaf) = begin
                    [:handle, :parent, :has_focus, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :auto_render, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :context, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :has_depth_buffer, :tooltip_markup, :margin_bottom, :root, :vexpand, :has_stencil_buffer, :can_target, :css_name, :use_es, :scale_factor]
                end
            function Base.getproperty(o::GtkGLAreaLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_es => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :auto_render => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :context => (:GdkGLContext, 0, 1), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :has_depth_buffer => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :parent => (:GtkWidget, 0, 1), :root => (:GtkRoot, 0, 1), :vexpand => (:Bool, 0, 3), :has_focus => (:Bool, 0, 1), :has_stencil_buffer => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGLAreaLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :auto_render => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :has_depth_buffer => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :has_stencil_buffer => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :use_es => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGestureClick <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureClickLeaf <: GtkGestureClick
            handle::Ptr{GObject}
            function GtkGestureClickLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGestureClickLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureClickLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureClickLeaf, args))
            end
            w = GtkGestureClickLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureClick] = GtkGestureClickLeaf
        function GtkGestureClick(args...; kwargs...)
            GtkGestureClickLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGestureClickLeaf) = begin
                    [:handle, :exclusive, :propagation_limit, :widget, :name, :n_points, :touch_only, :button, :propagation_phase]
                end
            function Base.getproperty(o::GtkGestureClickLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGestureClickLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGestureDrag <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureDragLeaf <: GtkGestureDrag
            handle::Ptr{GObject}
            function GtkGestureDragLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGestureDragLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureDragLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureDragLeaf, args))
            end
            w = GtkGestureDragLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureDrag] = GtkGestureDragLeaf
        function GtkGestureDrag(args...; kwargs...)
            GtkGestureDragLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGestureDragLeaf) = begin
                    [:handle, :exclusive, :propagation_limit, :widget, :name, :n_points, :touch_only, :button, :propagation_phase]
                end
            function Base.getproperty(o::GtkGestureDragLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGestureDragLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGestureLongPress <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureLongPressLeaf <: GtkGestureLongPress
            handle::Ptr{GObject}
            function GtkGestureLongPressLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGestureLongPressLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureLongPressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureLongPressLeaf, args))
            end
            w = GtkGestureLongPressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureLongPress] = GtkGestureLongPressLeaf
        function GtkGestureLongPress(args...; kwargs...)
            GtkGestureLongPressLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGestureLongPressLeaf) = begin
                    [:handle, :exclusive, :propagation_limit, :widget, :name, :n_points, :touch_only, :delay_factor, :button, :propagation_phase]
                end
            function Base.getproperty(o::GtkGestureLongPressLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :delay_factor => (:Float64, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGestureLongPressLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :delay_factor => (:Float64, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGesturePan <: GtkGestureDrag end
    end
    begin
        mutable struct GtkGesturePanLeaf <: GtkGesturePan
            handle::Ptr{GObject}
            function GtkGesturePanLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGesturePanLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGesturePanLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGesturePanLeaf, args))
            end
            w = GtkGesturePanLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGesturePan] = GtkGesturePanLeaf
        function GtkGesturePan(args...; kwargs...)
            GtkGesturePanLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGesturePanLeaf) = begin
                    [:handle, :exclusive, :propagation_limit, :widget, :name, :n_points, :touch_only, :orientation, :button, :propagation_phase]
                end
            function Base.getproperty(o::GtkGesturePanLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGesturePanLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGestureRotate <: GtkGesture end
    end
    begin
        mutable struct GtkGestureRotateLeaf <: GtkGestureRotate
            handle::Ptr{GObject}
            function GtkGestureRotateLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGestureRotateLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureRotateLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureRotateLeaf, args))
            end
            w = GtkGestureRotateLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureRotate] = GtkGestureRotateLeaf
        function GtkGestureRotate(args...; kwargs...)
            GtkGestureRotateLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGestureRotateLeaf) = begin
                    [:handle, :propagation_limit, :widget, :name, :n_points, :propagation_phase]
                end
            function Base.getproperty(o::GtkGestureRotateLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGestureRotateLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGestureStylus <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureStylusLeaf <: GtkGestureStylus
            handle::Ptr{GObject}
            function GtkGestureStylusLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGestureStylusLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureStylusLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureStylusLeaf, args))
            end
            w = GtkGestureStylusLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureStylus] = GtkGestureStylusLeaf
        function GtkGestureStylus(args...; kwargs...)
            GtkGestureStylusLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGestureStylusLeaf) = begin
                    [:handle, :exclusive, :propagation_limit, :widget, :name, :n_points, :touch_only, :button, :propagation_phase]
                end
            function Base.getproperty(o::GtkGestureStylusLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGestureStylusLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGestureSwipe <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureSwipeLeaf <: GtkGestureSwipe
            handle::Ptr{GObject}
            function GtkGestureSwipeLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGestureSwipeLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureSwipeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureSwipeLeaf, args))
            end
            w = GtkGestureSwipeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureSwipe] = GtkGestureSwipeLeaf
        function GtkGestureSwipe(args...; kwargs...)
            GtkGestureSwipeLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGestureSwipeLeaf) = begin
                    [:handle, :exclusive, :propagation_limit, :widget, :name, :n_points, :touch_only, :button, :propagation_phase]
                end
            function Base.getproperty(o::GtkGestureSwipeLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGestureSwipeLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exclusive => (:Bool, 0, 3), :propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :touch_only => (:Bool, 0, 3), :button => (:UInt32, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGestureZoom <: GtkGesture end
    end
    begin
        mutable struct GtkGestureZoomLeaf <: GtkGestureZoom
            handle::Ptr{GObject}
            function GtkGestureZoomLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGestureZoomLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureZoomLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureZoomLeaf, args))
            end
            w = GtkGestureZoomLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureZoom] = GtkGestureZoomLeaf
        function GtkGestureZoom(args...; kwargs...)
            GtkGestureZoomLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGestureZoomLeaf) = begin
                    [:handle, :propagation_limit, :widget, :name, :n_points, :propagation_phase]
                end
            function Base.getproperty(o::GtkGestureZoomLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGestureZoomLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :n_points => (:UInt32, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGrid <: GtkWidget end
    end
    begin
        mutable struct GtkGridLeaf <: GtkGrid
            handle::Ptr{GObject}
            function GtkGridLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGridLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGridLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGridLeaf, args))
            end
            w = GtkGridLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGrid] = GtkGridLeaf
        function GtkGrid(args...; kwargs...)
            GtkGridLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGridLeaf) = begin
                    [:handle, :css_classes, :row_homogeneous, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :baseline_row, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :row_spacing, :name, :opacity, :column_spacing, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :column_homogeneous, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkGridLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :row_homogeneous => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :baseline_row => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :row_spacing => (:Int32, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :column_spacing => (:Int32, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :column_homogeneous => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGridLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :row_homogeneous => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :baseline_row => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :row_spacing => (:Int32, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :column_spacing => (:Int32, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :column_homogeneous => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGridLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkGridLayoutLeaf <: GtkGridLayout
            handle::Ptr{GObject}
            function GtkGridLayoutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGridLayoutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGridLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGridLayoutLeaf, args))
            end
            w = GtkGridLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGridLayout] = GtkGridLayoutLeaf
        function GtkGridLayout(args...; kwargs...)
            GtkGridLayoutLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGridLayoutLeaf) = begin
                    [:handle, :column_homogeneous, :row_homogeneous, :baseline_row, :row_spacing, :column_spacing]
                end
            function Base.getproperty(o::GtkGridLayoutLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:column_homogeneous => (:Bool, 0, 3), :row_homogeneous => (:Bool, 0, 3), :baseline_row => (:Int32, 0, 3), :row_spacing => (:Int32, 0, 3), :column_spacing => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGridLayoutLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:column_homogeneous => (:Bool, 0, 3), :row_homogeneous => (:Bool, 0, 3), :baseline_row => (:Int32, 0, 3), :row_spacing => (:Int32, 0, 3), :column_spacing => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGridLayoutChild <: GtkLayoutChild end
    end
    begin
        mutable struct GtkGridLayoutChildLeaf <: GtkGridLayoutChild
            handle::Ptr{GObject}
            function GtkGridLayoutChildLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGridLayoutChildLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGridLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGridLayoutChildLeaf, args))
            end
            w = GtkGridLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGridLayoutChild] = GtkGridLayoutChildLeaf
        function GtkGridLayoutChild(args...; kwargs...)
            GtkGridLayoutChildLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGridLayoutChildLeaf) = begin
                    [:handle, :column_span, :child_widget, :row, :column, :layout_manager, :row_span]
                end
            function Base.getproperty(o::GtkGridLayoutChildLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:column_span => (:Int32, 0, 3), :child_widget => (:GtkWidget, 0, 11), :row => (:Int32, 0, 3), :column => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 11), :row_span => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGridLayoutChildLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:column_span => (:Int32, 0, 3), :child_widget => (:GtkWidget, 0, 11), :row => (:Int32, 0, 3), :column => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 11), :row_span => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkListBase <: GtkWidget end
    end
    begin
        mutable struct GtkListBaseLeaf <: GtkListBase
            handle::Ptr{GObject}
            function GtkListBaseLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkListBaseLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListBaseLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListBaseLeaf, args))
            end
            w = GtkListBaseLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListBase] = GtkListBaseLeaf
        function GtkListBase(args...; kwargs...)
            GtkListBaseLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkListBaseLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :hadjustment, :vexpand_set, :orientation, :has_tooltip, :overflow, :hscroll_policy, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :vadjustment, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :vscroll_policy, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkListBaseLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkListBaseLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkGridView <: GtkListBase end
    end
    begin
        mutable struct GtkGridViewLeaf <: GtkGridView
            handle::Ptr{GObject}
            function GtkGridViewLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkGridViewLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGridViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGridViewLeaf, args))
            end
            w = GtkGridViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGridView] = GtkGridViewLeaf
        function GtkGridView(args...; kwargs...)
            GtkGridViewLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkGridViewLeaf) = begin
                    [:handle, :factory, :hscroll_policy, :hexpand, :halign, :name, :opacity, :layout_manager, :max_columns, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :hadjustment, :overflow, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :vscroll_policy, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :vadjustment, :model, :width_request, :cursor, :enable_rubberband, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :orientation, :margin_start, :min_columns, :sensitive, :margin_top, :has_focus, :single_click_activate]
                end
            function Base.getproperty(o::GtkGridViewLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:factory => (:GtkListItemFactory, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :max_columns => (:UInt32, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :hadjustment => (:GtkAdjustment, 0, 7), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :model => (:GtkSelectionModel, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :enable_rubberband => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :margin_start => (:Int32, 0, 3), :min_columns => (:UInt32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1), :single_click_activate => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkGridViewLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:factory => (:GtkListItemFactory, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :min_columns => (:UInt32, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :hexpand_set => (:Bool, 0, 3), :model => (:GtkSelectionModel, 0, 3), :max_columns => (:UInt32, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :enable_rubberband => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :tooltip_markup => (:String, 0, 3), :margin_top => (:Int32, 0, 3), :single_click_activate => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkHeaderBar <: GtkWidget end
    end
    begin
        mutable struct GtkHeaderBarLeaf <: GtkHeaderBar
            handle::Ptr{GObject}
            function GtkHeaderBarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkHeaderBarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkHeaderBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkHeaderBarLeaf, args))
            end
            w = GtkHeaderBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkHeaderBar] = GtkHeaderBarLeaf
        function GtkHeaderBar(args...; kwargs...)
            GtkHeaderBarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkHeaderBarLeaf) = begin
                    [:handle, :decoration_layout, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :show_title_buttons, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :title_widget, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkHeaderBarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:decoration_layout => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :show_title_buttons => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :title_widget => (:GtkWidget, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkHeaderBarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:decoration_layout => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :show_title_buttons => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :title_widget => (:GtkWidget, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkIMContext <: GObject end
    end
    begin
        mutable struct GtkIMContextLeaf <: GtkIMContext
            handle::Ptr{GObject}
            function GtkIMContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkIMContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIMContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIMContextLeaf, args))
            end
            w = GtkIMContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIMContext] = GtkIMContextLeaf
        function GtkIMContext(args...; kwargs...)
            GtkIMContextLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkIMContextLeaf) = begin
                    [:handle, :input_hints, :input_purpose]
                end
            function Base.getproperty(o::GtkIMContextLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:input_hints => (:Int32, 0, 3), :input_purpose => (:InputPurpose, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkIMContextLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:input_hints => (:Int32, 0, 3), :input_purpose => (:InputPurpose, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkIMContextSimple <: GtkIMContext end
    end
    begin
        mutable struct GtkIMContextSimpleLeaf <: GtkIMContextSimple
            handle::Ptr{GObject}
            function GtkIMContextSimpleLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkIMContextSimpleLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIMContextSimpleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIMContextSimpleLeaf, args))
            end
            w = GtkIMContextSimpleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIMContextSimple] = GtkIMContextSimpleLeaf
        function GtkIMContextSimple(args...; kwargs...)
            GtkIMContextSimpleLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkIMContextSimpleLeaf) = begin
                    [:handle, :input_hints, :input_purpose]
                end
            function Base.getproperty(o::GtkIMContextSimpleLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:input_hints => (:Int32, 0, 3), :input_purpose => (:InputPurpose, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkIMContextSimpleLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:input_hints => (:Int32, 0, 3), :input_purpose => (:InputPurpose, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkIMMulticontext <: GtkIMContext end
    end
    begin
        mutable struct GtkIMMulticontextLeaf <: GtkIMMulticontext
            handle::Ptr{GObject}
            function GtkIMMulticontextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkIMMulticontextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIMMulticontextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIMMulticontextLeaf, args))
            end
            w = GtkIMMulticontextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIMMulticontext] = GtkIMMulticontextLeaf
        function GtkIMMulticontext(args...; kwargs...)
            GtkIMMulticontextLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkIMMulticontextLeaf) = begin
                    [:handle, :input_hints, :input_purpose]
                end
            function Base.getproperty(o::GtkIMMulticontextLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:input_hints => (:Int32, 0, 3), :input_purpose => (:InputPurpose, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkIMMulticontextLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:input_hints => (:Int32, 0, 3), :input_purpose => (:InputPurpose, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkIconPaintable <: GObject end
    end
    begin
        mutable struct GtkIconPaintableLeaf <: GtkIconPaintable
            handle::Ptr{GObject}
            function GtkIconPaintableLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkIconPaintableLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIconPaintableLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIconPaintableLeaf, args))
            end
            w = GtkIconPaintableLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIconPaintable] = GtkIconPaintableLeaf
        function GtkIconPaintable(args...; kwargs...)
            GtkIconPaintableLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkIconPaintableLeaf) = begin
                    [:handle, :is_symbolic, :file, :icon_name]
                end
            function Base.getproperty(o::GtkIconPaintableLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:icon_name => (:String, 0, 11), :file => (:GFile, 0, 11), :is_symbolic => (:Bool, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkIconPaintableLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:icon_name => (:String, 0, 11), :file => (:GFile, 0, 11), :is_symbolic => (:Bool, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkIconTheme <: GObject end
    end
    begin
        mutable struct GtkIconThemeLeaf <: GtkIconTheme
            handle::Ptr{GObject}
            function GtkIconThemeLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkIconThemeLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIconThemeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIconThemeLeaf, args))
            end
            w = GtkIconThemeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIconTheme] = GtkIconThemeLeaf
        function GtkIconTheme(args...; kwargs...)
            GtkIconThemeLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkIconThemeLeaf) = begin
                    [:handle, :theme_name, :search_path, :icon_names, :resource_path, :display]
                end
            function Base.getproperty(o::GtkIconThemeLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:theme_name => (:String, 0, 3), :search_path => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :icon_names => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 1), :resource_path => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :display => (:GdkDisplay, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkIconThemeLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:theme_name => (:String, 0, 3), :search_path => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :resource_path => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :display => (:GdkDisplay, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkIconView <: GtkWidget end
    end
    begin
        mutable struct GtkIconViewLeaf <: GtkIconView
            handle::Ptr{GObject}
            function GtkIconViewLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkIconViewLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIconViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIconViewLeaf, args))
            end
            w = GtkIconViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIconView] = GtkIconViewLeaf
        function GtkIconView(args...; kwargs...)
            GtkIconViewLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkIconViewLeaf) = begin
                    [:handle, :tooltip_column, :hscroll_policy, :hexpand, :halign, :activate_on_single_click, :row_spacing, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :margin, :scale_factor, :visible, :has_default, :hadjustment, :columns, :markup_column, :overflow, :receives_default, :tooltip_text, :can_focus, :cell_area, :height_request, :hexpand_set, :item_padding, :vscroll_policy, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :column_spacing, :item_orientation, :vadjustment, :model, :width_request, :cursor, :tooltip_markup, :parent, :selection_mode, :spacing, :focusable, :valign, :vexpand_set, :item_width, :text_column, :margin_start, :pixbuf_column, :reorderable, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkIconViewLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:tooltip_column => (:Int32, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :activate_on_single_click => (:Bool, 0, 3), :row_spacing => (:Int32, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :margin => (:Int32, 0, 3), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :hadjustment => (:GtkAdjustment, 0, 7), :columns => (:Int32, 0, 3), :markup_column => (:Int32, 0, 3), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :cell_area => (:GtkCellArea, 0, 11), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :item_padding => (:Int32, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :column_spacing => (:Int32, 0, 3), :item_orientation => (:Orientation, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :model => (:GtkTreeModel, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :selection_mode => (:SelectionMode, 0, 3), :spacing => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :item_width => (:Int32, 0, 3), :text_column => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :pixbuf_column => (:Int32, 0, 3), :reorderable => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkIconViewLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:tooltip_column => (:Int32, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :activate_on_single_click => (:Bool, 0, 3), :row_spacing => (:Int32, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :margin => (:Int32, 0, 3), :visible => (:Bool, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :columns => (:Int32, 0, 3), :markup_column => (:Int32, 0, 3), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :cell_area => (:GtkCellArea, 0, 11), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :item_padding => (:Int32, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :column_spacing => (:Int32, 0, 3), :item_orientation => (:Orientation, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :model => (:GtkTreeModel, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :selection_mode => (:SelectionMode, 0, 3), :spacing => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :item_width => (:Int32, 0, 3), :text_column => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :pixbuf_column => (:Int32, 0, 3), :reorderable => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkImage <: GtkWidget end
    end
    begin
        mutable struct GtkImageLeaf <: GtkImage
            handle::Ptr{GObject}
            function GtkImageLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkImageLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkImageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkImageLeaf, args))
            end
            w = GtkImageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkImage] = GtkImageLeaf
        function GtkImage(args...; kwargs...)
            GtkImageLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkImageLeaf) = begin
                    [:handle, :use_fallback, :storage_type, :icon_size, :hexpand, :halign, :name, :opacity, :layout_manager, :paintable, :focus_on_click, :vexpand, :can_target, :css_name, :resource, :scale_factor, :visible, :has_default, :overflow, :file, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :icon_name, :css_classes, :pixel_size, :has_tooltip, :accessible_role, :margin_end, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :gicon, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkImageLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_fallback => (:Bool, 0, 3), :storage_type => (:ImageType, 0, 1), :icon_size => (:IconSize, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :paintable => (:GdkPaintable, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :resource => (:String, 0, 3), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :file => (:String, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :pixel_size => (:Int32, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :gicon => (:GIcon, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkImageLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :use_fallback => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :pixel_size => (:Int32, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :file => (:String, 0, 3), :gicon => (:GIcon, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :icon_size => (:IconSize, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :paintable => (:GdkPaintable, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :resource => (:String, 0, 3), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkInfoBar <: GtkWidget end
    end
    begin
        mutable struct GtkInfoBarLeaf <: GtkInfoBar
            handle::Ptr{GObject}
            function GtkInfoBarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkInfoBarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkInfoBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkInfoBarLeaf, args))
            end
            w = GtkInfoBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkInfoBar] = GtkInfoBarLeaf
        function GtkInfoBar(args...; kwargs...)
            GtkInfoBarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkInfoBarLeaf) = begin
                    [:handle, :root, :show_close_button, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :message_type, :revealed, :vexpand, :can_target, :css_name, :scale_factor, :parent, :has_focus]
                end
            function Base.getproperty(o::GtkInfoBarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:has_focus => (:Bool, 0, 1), :show_close_button => (:Bool, 0, 7), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :message_type => (:MessageType, 0, 7), :root => (:GtkRoot, 0, 1), :revealed => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :parent => (:GtkWidget, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkInfoBarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:show_close_button => (:Bool, 0, 7), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :message_type => (:MessageType, 0, 7), :revealed => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkKeyvalTrigger <: GtkShortcutTrigger end
    end
    begin
        mutable struct GtkKeyvalTriggerLeaf <: GtkKeyvalTrigger
            handle::Ptr{GObject}
            function GtkKeyvalTriggerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkKeyvalTriggerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkKeyvalTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkKeyvalTriggerLeaf, args))
            end
            w = GtkKeyvalTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkKeyvalTrigger] = GtkKeyvalTriggerLeaf
        function GtkKeyvalTrigger(args...; kwargs...)
            GtkKeyvalTriggerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkKeyvalTriggerLeaf) = begin
                    [:handle, :keyval, :modifiers]
                end
            function Base.getproperty(o::GtkKeyvalTriggerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:keyval => (:UInt32, 0, 11), :modifiers => (:Int32, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkKeyvalTriggerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:keyval => (:UInt32, 0, 11), :modifiers => (:Int32, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkLabel <: GtkWidget end
    end
    begin
        mutable struct GtkLabelLeaf <: GtkLabel
            handle::Ptr{GObject}
            function GtkLabelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkLabelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLabelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLabelLeaf, args))
            end
            w = GtkLabelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLabel] = GtkLabelLeaf
        function GtkLabel(args...; kwargs...)
            GtkLabelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkLabelLeaf) = begin
                    [:handle, :justify, :xalign, :extra_menu, :hexpand, :halign, :name, :opacity, :layout_manager, :use_markup, :ellipsize, :focus_on_click, :vexpand, :can_target, :css_name, :single_line_mode, :scale_factor, :visible, :has_default, :overflow, :receives_default, :max_width_chars, :tooltip_text, :attributes, :can_focus, :height_request, :hexpand_set, :lines, :margin_bottom, :root, :yalign, :mnemonic_widget, :css_classes, :use_underline, :has_tooltip, :accessible_role, :margin_end, :selectable, :width_request, :cursor, :tooltip_markup, :parent, :wrap_mode, :label, :focusable, :valign, :vexpand_set, :wrap, :width_chars, :margin_start, :mnemonic_keyval, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkLabelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:justify => (:Justification, 0, 3), :xalign => (:Float32, 0, 3), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :use_markup => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :single_line_mode => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :tooltip_text => (:String, 0, 3), :attributes => (:PangoAttrList, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :lines => (:Int32, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :yalign => (:Float32, 0, 3), :mnemonic_widget => (:GtkWidget, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :selectable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :wrap_mode => (:WrapMode, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :wrap => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :mnemonic_keyval => (:UInt32, 0, 1), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkLabelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:justify => (:Justification, 0, 3), :xalign => (:Float32, 0, 3), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :use_markup => (:Bool, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :single_line_mode => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :tooltip_text => (:String, 0, 3), :attributes => (:PangoAttrList, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :lines => (:Int32, 0, 3), :margin_bottom => (:Int32, 0, 3), :yalign => (:Float32, 0, 3), :mnemonic_widget => (:GtkWidget, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :selectable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :wrap => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkLevelBar <: GtkWidget end
    end
    begin
        mutable struct GtkLevelBarLeaf <: GtkLevelBar
            handle::Ptr{GObject}
            function GtkLevelBarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkLevelBarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLevelBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLevelBarLeaf, args))
            end
            w = GtkLevelBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLevelBar] = GtkLevelBarLeaf
        function GtkLevelBar(args...; kwargs...)
            GtkLevelBarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkLevelBarLeaf) = begin
                    [:handle, :max_value, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :mode, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :inverted, :hexpand_set, :min_value, :sensitive, :width_request, :value, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :scale_factor, :has_focus, :root]
                end
            function Base.getproperty(o::GtkLevelBarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :mode => (:LevelBarMode, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :inverted => (:Bool, 0, 3), :hexpand_set => (:Bool, 0, 3), :min_value => (:Float64, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :value => (:Float64, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :scale_factor => (:Int32, 0, 1), :has_focus => (:Bool, 0, 1), :max_value => (:Float64, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkLevelBarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :mode => (:LevelBarMode, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :inverted => (:Bool, 0, 3), :hexpand_set => (:Bool, 0, 3), :min_value => (:Float64, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :value => (:Float64, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :max_value => (:Float64, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkLinkButton <: GtkButton end
    end
    begin
        mutable struct GtkLinkButtonLeaf <: GtkLinkButton
            handle::Ptr{GObject}
            function GtkLinkButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkLinkButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLinkButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLinkButtonLeaf, args))
            end
            w = GtkLinkButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLinkButton] = GtkLinkButtonLeaf
        function GtkLinkButton(args...; kwargs...)
            GtkLinkButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkLinkButtonLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :child, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :uri, :has_frame, :icon_name, :css_classes, :use_underline, :has_tooltip, :accessible_role, :margin_end, :action_name, :width_request, :cursor, :tooltip_markup, :parent, :action_target, :label, :focusable, :valign, :vexpand_set, :visited, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkLinkButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :uri => (:String, 0, 3), :has_frame => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :action_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :action_target => (:GVariant, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :visited => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkLinkButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_target => (:GVariant, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :visited => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :uri => (:String, 0, 3), :has_frame => (:Bool, 0, 3), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkListBox <: GtkWidget end
    end
    begin
        mutable struct GtkListBoxLeaf <: GtkListBox
            handle::Ptr{GObject}
            function GtkListBoxLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkListBoxLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListBoxLeaf, args))
            end
            w = GtkListBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListBox] = GtkListBoxLeaf
        function GtkListBox(args...; kwargs...)
            GtkListBoxLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkListBoxLeaf) = begin
                    [:handle, :root, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :accept_unpaired_release, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :activate_on_single_click, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :show_separators, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :scale_factor, :selection_mode, :has_focus]
                end
            function Base.getproperty(o::GtkListBoxLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:has_focus => (:Bool, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :accept_unpaired_release => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :activate_on_single_click => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :show_separators => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :scale_factor => (:Int32, 0, 1), :selection_mode => (:SelectionMode, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkListBoxLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :accept_unpaired_release => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :activate_on_single_click => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :show_separators => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :selection_mode => (:SelectionMode, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkListBoxRow <: GtkWidget end
    end
    begin
        mutable struct GtkListBoxRowLeaf <: GtkListBoxRow
            handle::Ptr{GObject}
            function GtkListBoxRowLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkListBoxRowLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListBoxRowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListBoxRowLeaf, args))
            end
            w = GtkListBoxRowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListBoxRow] = GtkListBoxRowLeaf
        function GtkListBoxRow(args...; kwargs...)
            GtkListBoxRowLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkListBoxRowLeaf) = begin
                    [:handle, :action_target, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :selectable, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :activatable, :hexpand_set, :action_name, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkListBoxRowLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_target => (:GVariant, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :selectable => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :activatable => (:Bool, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkListBoxRowLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_target => (:GVariant, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :selectable => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :activatable => (:Bool, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkListItem <: GObject end
    end
    begin
        mutable struct GtkListItemLeaf <: GtkListItem
            handle::Ptr{GObject}
            function GtkListItemLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkListItemLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListItemLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListItemLeaf, args))
            end
            w = GtkListItemLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListItem] = GtkListItemLeaf
        function GtkListItem(args...; kwargs...)
            GtkListItemLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkListItemLeaf) = begin
                    [:handle, :child, :item, :selected, :position, :activatable, :selectable]
                end
            function Base.getproperty(o::GtkListItemLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child => (:GtkWidget, 0, 3), :item => (:GObject, 0, 1), :selected => (:Bool, 0, 1), :position => (:UInt32, 0, 1), :activatable => (:Bool, 0, 3), :selectable => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkListItemLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child => (:GtkWidget, 0, 3), :activatable => (:Bool, 0, 3), :selectable => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkListStore <: GObject end
    end
    begin
        mutable struct GtkListStoreLeaf <: GtkListStore
            handle::Ptr{GObject}
            function GtkListStoreLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkListStoreLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListStoreLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListStoreLeaf, args))
            end
            w = GtkListStoreLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListStore] = GtkListStoreLeaf
        function GtkListStore(args...; kwargs...)
            GtkListStoreLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkListView <: GtkListBase end
    end
    begin
        mutable struct GtkListViewLeaf <: GtkListView
            handle::Ptr{GObject}
            function GtkListViewLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkListViewLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListViewLeaf, args))
            end
            w = GtkListViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListView] = GtkListViewLeaf
        function GtkListView(args...; kwargs...)
            GtkListViewLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkListViewLeaf) = begin
                    [:handle, :factory, :hscroll_policy, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :hadjustment, :overflow, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :show_separators, :vscroll_policy, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :vadjustment, :model, :width_request, :cursor, :enable_rubberband, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :orientation, :margin_start, :sensitive, :margin_top, :has_focus, :single_click_activate]
                end
            function Base.getproperty(o::GtkListViewLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:factory => (:GtkListItemFactory, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :hadjustment => (:GtkAdjustment, 0, 7), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :show_separators => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :model => (:GtkSelectionModel, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :enable_rubberband => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1), :single_click_activate => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkListViewLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:factory => (:GtkListItemFactory, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :hexpand_set => (:Bool, 0, 3), :model => (:GtkSelectionModel, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :show_separators => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :enable_rubberband => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_top => (:Int32, 0, 3), :single_click_activate => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkLockButton <: GtkButton end
    end
    begin
        mutable struct GtkLockButtonLeaf <: GtkLockButton
            handle::Ptr{GObject}
            function GtkLockButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkLockButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLockButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLockButtonLeaf, args))
            end
            w = GtkLockButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLockButton] = GtkLockButtonLeaf
        function GtkLockButton(args...; kwargs...)
            GtkLockButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkLockButtonLeaf) = begin
                    [:handle, :tooltip_lock, :hexpand, :halign, :name, :opacity, :layout_manager, :child, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :text_lock, :overflow, :receives_default, :tooltip_text, :can_focus, :tooltip_not_authorized, :height_request, :hexpand_set, :permission, :tooltip_unlock, :margin_bottom, :root, :has_frame, :icon_name, :css_classes, :use_underline, :has_tooltip, :accessible_role, :margin_end, :action_name, :width_request, :cursor, :tooltip_markup, :parent, :action_target, :label, :focusable, :valign, :vexpand_set, :margin_start, :text_unlock, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkLockButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:tooltip_lock => (:String, 0, 7), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :text_lock => (:String, 0, 7), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :tooltip_not_authorized => (:String, 0, 7), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :permission => (:GPermission, 0, 3), :tooltip_unlock => (:String, 0, 7), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :has_frame => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :action_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :action_target => (:GVariant, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :text_unlock => (:String, 0, 7), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkLockButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:tooltip_lock => (:String, 0, 7), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :visible => (:Bool, 0, 3), :text_lock => (:String, 0, 7), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :tooltip_not_authorized => (:String, 0, 7), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :permission => (:GPermission, 0, 3), :tooltip_unlock => (:String, 0, 7), :margin_bottom => (:Int32, 0, 3), :has_frame => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :action_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :action_target => (:GVariant, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :text_unlock => (:String, 0, 7), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMapListModel <: GObject end
    end
    begin
        mutable struct GtkMapListModelLeaf <: GtkMapListModel
            handle::Ptr{GObject}
            function GtkMapListModelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMapListModelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMapListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMapListModelLeaf, args))
            end
            w = GtkMapListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMapListModel] = GtkMapListModelLeaf
        function GtkMapListModel(args...; kwargs...)
            GtkMapListModelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkMapListModelLeaf) = begin
                    [:handle, :has_map, :model]
                end
            function Base.getproperty(o::GtkMapListModelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:has_map => (:Bool, 0, 1), :model => (:GListModel, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkMapListModelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GListModel, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMediaControls <: GtkWidget end
    end
    begin
        mutable struct GtkMediaControlsLeaf <: GtkMediaControls
            handle::Ptr{GObject}
            function GtkMediaControlsLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMediaControlsLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMediaControlsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMediaControlsLeaf, args))
            end
            w = GtkMediaControlsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMediaControls] = GtkMediaControlsLeaf
        function GtkMediaControls(args...; kwargs...)
            GtkMediaControlsLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkMediaControlsLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :media_stream, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkMediaControlsLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :media_stream => (:GtkMediaStream, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkMediaControlsLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :media_stream => (:GtkMediaStream, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMediaStream <: GObject end
    end
    begin
        mutable struct GtkMediaStreamLeaf <: GtkMediaStream
            handle::Ptr{GObject}
            function GtkMediaStreamLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMediaStreamLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMediaStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMediaStreamLeaf, args))
            end
            w = GtkMediaStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMediaStream] = GtkMediaStreamLeaf
        function GtkMediaStream(args...; kwargs...)
            GtkMediaStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkMediaStreamLeaf) = begin
                    [:handle, :duration, :muted, :timestamp, :playing, :loop, :error, :volume, :seekable, :ended, :has_audio, :prepared, :has_video, :seeking]
                end
            function Base.getproperty(o::GtkMediaStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:duration => (:Int64, 0, 1), :muted => (:Bool, 0, 3), :timestamp => (:Int64, 0, 1), :playing => (:Bool, 0, 3), :loop => (:Bool, 0, 3), :error => (:GError, 0, 1), :volume => (:Float64, 0, 3), :seekable => (:Bool, 0, 1), :ended => (:Bool, 0, 1), :has_audio => (:Bool, 0, 1), :prepared => (:Bool, 0, 3), :has_video => (:Bool, 0, 1), :seeking => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkMediaStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:volume => (:Float64, 0, 3), :playing => (:Bool, 0, 3), :loop => (:Bool, 0, 3), :muted => (:Bool, 0, 3), :prepared => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMediaFile <: GtkMediaStream end
    end
    begin
        mutable struct GtkMediaFileLeaf <: GtkMediaFile
            handle::Ptr{GObject}
            function GtkMediaFileLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMediaFileLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMediaFileLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMediaFileLeaf, args))
            end
            w = GtkMediaFileLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMediaFile] = GtkMediaFileLeaf
        function GtkMediaFile(args...; kwargs...)
            GtkMediaFileLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkMediaFileLeaf) = begin
                    [:handle, :input_stream, :duration, :muted, :timestamp, :playing, :file, :loop, :error, :volume, :seekable, :ended, :has_audio, :prepared, :has_video, :seeking]
                end
            function Base.getproperty(o::GtkMediaFileLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:input_stream => (:GInputStream, 0, 3), :duration => (:Int64, 0, 1), :muted => (:Bool, 0, 3), :timestamp => (:Int64, 0, 1), :playing => (:Bool, 0, 3), :file => (:GFile, 0, 3), :loop => (:Bool, 0, 3), :error => (:GError, 0, 1), :volume => (:Float64, 0, 3), :seekable => (:Bool, 0, 1), :ended => (:Bool, 0, 1), :has_audio => (:Bool, 0, 1), :prepared => (:Bool, 0, 3), :has_video => (:Bool, 0, 1), :seeking => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkMediaFileLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:volume => (:Float64, 0, 3), :playing => (:Bool, 0, 3), :file => (:GFile, 0, 3), :loop => (:Bool, 0, 3), :input_stream => (:GInputStream, 0, 3), :muted => (:Bool, 0, 3), :prepared => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMenuButton <: GtkWidget end
    end
    begin
        mutable struct GtkMenuButtonLeaf <: GtkMenuButton
            handle::Ptr{GObject}
            function GtkMenuButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMenuButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMenuButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMenuButtonLeaf, args))
            end
            w = GtkMenuButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMenuButton] = GtkMenuButtonLeaf
        function GtkMenuButton(args...; kwargs...)
            GtkMenuButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkMenuButtonLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :menu_model, :margin_bottom, :root, :always_show_arrow, :has_frame, :icon_name, :css_classes, :use_underline, :has_tooltip, :accessible_role, :margin_end, :primary, :width_request, :cursor, :tooltip_markup, :parent, :direction, :label, :focusable, :valign, :vexpand_set, :popover, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkMenuButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :menu_model => (:GMenuModel, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :always_show_arrow => (:Bool, 0, 3), :has_frame => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :primary => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :direction => (:ArrowType, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :popover => (:GtkPopover, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkMenuButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :use_underline => (:Bool, 0, 3), :popover => (:GtkPopover, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :primary => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :menu_model => (:GMenuModel, 0, 3), :margin_bottom => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :always_show_arrow => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :direction => (:ArrowType, 0, 3), :has_frame => (:Bool, 0, 3), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMessageDialog <: GtkDialog end
    end
    begin
        mutable struct GtkMessageDialogLeaf <: GtkMessageDialog
            handle::Ptr{GObject}
            function GtkMessageDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMessageDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMessageDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMessageDialogLeaf, args))
            end
            w = GtkMessageDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMessageDialog] = GtkMessageDialogLeaf
        function GtkMessageDialog(args...; kwargs...)
            GtkMessageDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkMessageDialogLeaf) = begin
                    [:handle, :text, :application, :hexpand, :halign, :name, :opacity, :use_header_bar, :layout_manager, :use_markup, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :visible, :secondary_use_markup, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :message_area, :can_focus, :modal, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :margin_end, :buttons, :display, :width_request, :secondary_text, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :message_type, :has_focus]
                end
            function Base.getproperty(o::GtkMessageDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:text => (:String, 0, 3), :application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :use_markup => (:Bool, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :secondary_use_markup => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :message_area => (:GtkWidget, 0, 1), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :secondary_text => (:String, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :message_type => (:MessageType, 0, 7), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkMessageDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:text => (:String, 0, 3), :application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :use_markup => (:Bool, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :secondary_use_markup => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :buttons => (:ButtonsType, 0, 10), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :secondary_text => (:String, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :message_type => (:MessageType, 0, 7))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMnemonicAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkMnemonicActionLeaf <: GtkMnemonicAction
            handle::Ptr{GObject}
            function GtkMnemonicActionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMnemonicActionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMnemonicActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMnemonicActionLeaf, args))
            end
            w = GtkMnemonicActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMnemonicAction] = GtkMnemonicActionLeaf
        function GtkMnemonicAction(args...; kwargs...)
            GtkMnemonicActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMnemonicTrigger <: GtkShortcutTrigger end
    end
    begin
        mutable struct GtkMnemonicTriggerLeaf <: GtkMnemonicTrigger
            handle::Ptr{GObject}
            function GtkMnemonicTriggerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMnemonicTriggerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMnemonicTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMnemonicTriggerLeaf, args))
            end
            w = GtkMnemonicTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMnemonicTrigger] = GtkMnemonicTriggerLeaf
        function GtkMnemonicTrigger(args...; kwargs...)
            GtkMnemonicTriggerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkMnemonicTriggerLeaf) = begin
                    [:handle, :keyval]
                end
            function Base.getproperty(o::GtkMnemonicTriggerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:keyval => (:UInt32, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkMnemonicTriggerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:keyval => (:UInt32, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMountOperation <: GMountOperation end
    end
    begin
        mutable struct GtkMountOperationLeaf <: GtkMountOperation
            handle::Ptr{GObject}
            function GtkMountOperationLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMountOperationLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMountOperationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMountOperationLeaf, args))
            end
            w = GtkMountOperationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMountOperation] = GtkMountOperationLeaf
        function GtkMountOperation(args...; kwargs...)
            GtkMountOperationLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkMountOperationLeaf) = begin
                    [:handle, :pim, :domain, :choice, :is_tcrypt_hidden_volume, :anonymous, :password_save, :display, :username, :is_tcrypt_system_volume, :password, :parent, :is_showing]
                end
            function Base.getproperty(o::GtkMountOperationLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pim => (:UInt32, 0, 3), :domain => (:String, 0, 3), :choice => (:Int32, 0, 3), :is_tcrypt_hidden_volume => (:Bool, 0, 3), :anonymous => (:Bool, 0, 3), :password_save => (:PasswordSave, 0, 3), :display => (:GdkDisplay, 0, 3), :username => (:String, 0, 3), :is_tcrypt_system_volume => (:Bool, 0, 3), :password => (:String, 0, 3), :parent => (:GtkWindow, 0, 3), :is_showing => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkMountOperationLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pim => (:UInt32, 0, 3), :domain => (:String, 0, 3), :choice => (:Int32, 0, 3), :is_tcrypt_hidden_volume => (:Bool, 0, 3), :anonymous => (:Bool, 0, 3), :password_save => (:PasswordSave, 0, 3), :display => (:GdkDisplay, 0, 3), :username => (:String, 0, 3), :is_tcrypt_system_volume => (:Bool, 0, 3), :password => (:String, 0, 3), :parent => (:GtkWindow, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMultiSelection <: GObject end
    end
    begin
        mutable struct GtkMultiSelectionLeaf <: GtkMultiSelection
            handle::Ptr{GObject}
            function GtkMultiSelectionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMultiSelectionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMultiSelectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMultiSelectionLeaf, args))
            end
            w = GtkMultiSelectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMultiSelection] = GtkMultiSelectionLeaf
        function GtkMultiSelection(args...; kwargs...)
            GtkMultiSelectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkMultiSelectionLeaf) = begin
                    [:handle, :model]
                end
            function Base.getproperty(o::GtkMultiSelectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GListModel, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkMultiSelectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GListModel, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkMultiSorter <: GtkSorter end
    end
    begin
        mutable struct GtkMultiSorterLeaf <: GtkMultiSorter
            handle::Ptr{GObject}
            function GtkMultiSorterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkMultiSorterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMultiSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMultiSorterLeaf, args))
            end
            w = GtkMultiSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMultiSorter] = GtkMultiSorterLeaf
        function GtkMultiSorter(args...; kwargs...)
            GtkMultiSorterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNamedAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkNamedActionLeaf <: GtkNamedAction
            handle::Ptr{GObject}
            function GtkNamedActionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkNamedActionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNamedActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNamedActionLeaf, args))
            end
            w = GtkNamedActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNamedAction] = GtkNamedActionLeaf
        function GtkNamedAction(args...; kwargs...)
            GtkNamedActionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkNamedActionLeaf) = begin
                    [:handle, :action_name]
                end
            function Base.getproperty(o::GtkNamedActionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_name => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkNamedActionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkNeverTrigger <: GtkShortcutTrigger end
    end
    begin
        mutable struct GtkNeverTriggerLeaf <: GtkNeverTrigger
            handle::Ptr{GObject}
            function GtkNeverTriggerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkNeverTriggerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNeverTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNeverTriggerLeaf, args))
            end
            w = GtkNeverTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNeverTrigger] = GtkNeverTriggerLeaf
        function GtkNeverTrigger(args...; kwargs...)
            GtkNeverTriggerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNoSelection <: GObject end
    end
    begin
        mutable struct GtkNoSelectionLeaf <: GtkNoSelection
            handle::Ptr{GObject}
            function GtkNoSelectionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkNoSelectionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNoSelectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNoSelectionLeaf, args))
            end
            w = GtkNoSelectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNoSelection] = GtkNoSelectionLeaf
        function GtkNoSelection(args...; kwargs...)
            GtkNoSelectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkNoSelectionLeaf) = begin
                    [:handle, :model]
                end
            function Base.getproperty(o::GtkNoSelectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GListModel, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkNoSelectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GListModel, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkNotebook <: GtkWidget end
    end
    begin
        mutable struct GtkNotebookLeaf <: GtkNotebook
            handle::Ptr{GObject}
            function GtkNotebookLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkNotebookLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNotebookLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNotebookLeaf, args))
            end
            w = GtkNotebookLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNotebook] = GtkNotebookLeaf
        function GtkNotebook(args...; kwargs...)
            GtkNotebookLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkNotebookLeaf) = begin
                    [:handle, :pages, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :tab_pos, :show_border, :receives_default, :tooltip_text, :can_focus, :enable_popup, :height_request, :hexpand_set, :margin_bottom, :root, :scrollable, :css_classes, :has_tooltip, :accessible_role, :page, :margin_end, :show_tabs, :group_name, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkNotebookLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pages => (:GListModel, 0, 1), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :tab_pos => (:PositionType, 0, 3), :show_border => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :enable_popup => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :scrollable => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :page => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :show_tabs => (:Bool, 0, 3), :group_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkNotebookLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scrollable => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :page => (:Int32, 0, 3), :tab_pos => (:PositionType, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :show_border => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :enable_popup => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :show_tabs => (:Bool, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :group_name => (:String, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkNotebookPage <: GObject end
    end
    begin
        mutable struct GtkNotebookPageLeaf <: GtkNotebookPage
            handle::Ptr{GObject}
            function GtkNotebookPageLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkNotebookPageLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNotebookPageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNotebookPageLeaf, args))
            end
            w = GtkNotebookPageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNotebookPage] = GtkNotebookPageLeaf
        function GtkNotebookPage(args...; kwargs...)
            GtkNotebookPageLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkNotebookPageLeaf) = begin
                    [:handle, :child, :tab_expand, :tab_fill, :tab_label, :detachable, :position, :menu_label, :tab, :reorderable, :menu]
                end
            function Base.getproperty(o::GtkNotebookPageLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child => (:GtkWidget, 0, 11), :tab_expand => (:Bool, 0, 3), :tab_fill => (:Bool, 0, 3), :tab_label => (:String, 0, 3), :detachable => (:Bool, 0, 3), :position => (:Int32, 0, 3), :menu_label => (:String, 0, 3), :tab => (:GtkWidget, 0, 11), :reorderable => (:Bool, 0, 3), :menu => (:GtkWidget, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkNotebookPageLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child => (:GtkWidget, 0, 11), :tab_expand => (:Bool, 0, 3), :tab_fill => (:Bool, 0, 3), :tab_label => (:String, 0, 3), :detachable => (:Bool, 0, 3), :position => (:Int32, 0, 3), :menu_label => (:String, 0, 3), :tab => (:GtkWidget, 0, 11), :reorderable => (:Bool, 0, 3), :menu => (:GtkWidget, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkNothingAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkNothingActionLeaf <: GtkNothingAction
            handle::Ptr{GObject}
            function GtkNothingActionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkNothingActionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNothingActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNothingActionLeaf, args))
            end
            w = GtkNothingActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNothingAction] = GtkNothingActionLeaf
        function GtkNothingAction(args...; kwargs...)
            GtkNothingActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNumericSorter <: GtkSorter end
    end
    begin
        mutable struct GtkNumericSorterLeaf <: GtkNumericSorter
            handle::Ptr{GObject}
            function GtkNumericSorterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkNumericSorterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNumericSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNumericSorterLeaf, args))
            end
            w = GtkNumericSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNumericSorter] = GtkNumericSorterLeaf
        function GtkNumericSorter(args...; kwargs...)
            GtkNumericSorterLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkNumericSorterLeaf) = begin
                    [:handle, :sort_order, :expression]
                end
            function Base.getproperty(o::GtkNumericSorterLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:sort_order => (:SortType, 0, 3), :expression => (:GtkExpression, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkNumericSorterLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:sort_order => (:SortType, 0, 3), :expression => (:GtkExpression, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkOverlay <: GtkWidget end
    end
    begin
        mutable struct GtkOverlayLeaf <: GtkOverlay
            handle::Ptr{GObject}
            function GtkOverlayLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkOverlayLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkOverlayLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkOverlayLeaf, args))
            end
            w = GtkOverlayLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkOverlay] = GtkOverlayLeaf
        function GtkOverlay(args...; kwargs...)
            GtkOverlayLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkOverlayLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkOverlayLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkOverlayLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkOverlayLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkOverlayLayoutLeaf <: GtkOverlayLayout
            handle::Ptr{GObject}
            function GtkOverlayLayoutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkOverlayLayoutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkOverlayLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkOverlayLayoutLeaf, args))
            end
            w = GtkOverlayLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkOverlayLayout] = GtkOverlayLayoutLeaf
        function GtkOverlayLayout(args...; kwargs...)
            GtkOverlayLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkOverlayLayoutChild <: GtkLayoutChild end
    end
    begin
        mutable struct GtkOverlayLayoutChildLeaf <: GtkOverlayLayoutChild
            handle::Ptr{GObject}
            function GtkOverlayLayoutChildLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkOverlayLayoutChildLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkOverlayLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkOverlayLayoutChildLeaf, args))
            end
            w = GtkOverlayLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkOverlayLayoutChild] = GtkOverlayLayoutChildLeaf
        function GtkOverlayLayoutChild(args...; kwargs...)
            GtkOverlayLayoutChildLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkOverlayLayoutChildLeaf) = begin
                    [:handle, :clip_overlay, :child_widget, :layout_manager, :measure]
                end
            function Base.getproperty(o::GtkOverlayLayoutChildLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:clip_overlay => (:Bool, 0, 3), :child_widget => (:GtkWidget, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 11), :measure => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkOverlayLayoutChildLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:clip_overlay => (:Bool, 0, 3), :child_widget => (:GtkWidget, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 11), :measure => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPadController <: GtkEventController end
    end
    begin
        mutable struct GtkPadControllerLeaf <: GtkPadController
            handle::Ptr{GObject}
            function GtkPadControllerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPadControllerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPadControllerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPadControllerLeaf, args))
            end
            w = GtkPadControllerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPadController] = GtkPadControllerLeaf
        function GtkPadController(args...; kwargs...)
            GtkPadControllerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPadControllerLeaf) = begin
                    [:handle, :pad, :propagation_limit, :widget, :name, :action_group, :propagation_phase]
                end
            function Base.getproperty(o::GtkPadControllerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pad => (:GdkDevice, 0, 11), :propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :action_group => (:GActionGroup, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPadControllerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pad => (:GdkDevice, 0, 11), :propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :action_group => (:GActionGroup, 0, 11), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPageSetup <: GObject end
    end
    begin
        mutable struct GtkPageSetupLeaf <: GtkPageSetup
            handle::Ptr{GObject}
            function GtkPageSetupLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPageSetupLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPageSetupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPageSetupLeaf, args))
            end
            w = GtkPageSetupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPageSetup] = GtkPageSetupLeaf
        function GtkPageSetup(args...; kwargs...)
            GtkPageSetupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPageSetupUnixDialog <: GtkDialog end
    end
    begin
        mutable struct GtkPageSetupUnixDialogLeaf <: GtkPageSetupUnixDialog
            handle::Ptr{GObject}
            function GtkPageSetupUnixDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPageSetupUnixDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPageSetupUnixDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPageSetupUnixDialogLeaf, args))
            end
            w = GtkPageSetupUnixDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPageSetupUnixDialog] = GtkPageSetupUnixDialogLeaf
        function GtkPageSetupUnixDialog(args...; kwargs...)
            GtkPageSetupUnixDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPageSetupUnixDialogLeaf) = begin
                    [:handle, :application, :hexpand, :halign, :name, :opacity, :use_header_bar, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :margin_end, :display, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkPageSetupUnixDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :focus_visible => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPageSetupUnixDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPaned <: GtkWidget end
    end
    begin
        mutable struct GtkPanedLeaf <: GtkPaned
            handle::Ptr{GObject}
            function GtkPanedLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPanedLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPanedLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPanedLeaf, args))
            end
            w = GtkPanedLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPaned] = GtkPanedLeaf
        function GtkPaned(args...; kwargs...)
            GtkPanedLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPanedLeaf) = begin
                    [:handle, :end_child, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :position, :visible, :has_default, :position_set, :overflow, :min_position, :shrink_start_child, :receives_default, :tooltip_text, :can_focus, :shrink_end_child, :height_request, :hexpand_set, :max_position, :margin_bottom, :root, :css_classes, :start_child, :has_tooltip, :accessible_role, :resize_end_child, :margin_end, :wide_handle, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :orientation, :resize_start_child, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkPanedLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:end_child => (:GtkWidget, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :position => (:Int32, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :position_set => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :min_position => (:Int32, 0, 1), :shrink_start_child => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :shrink_end_child => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :max_position => (:Int32, 0, 1), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :start_child => (:GtkWidget, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :resize_end_child => (:Bool, 0, 3), :margin_end => (:Int32, 0, 3), :wide_handle => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :resize_start_child => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPanedLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :position => (:Int32, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :position_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :end_child => (:GtkWidget, 0, 3), :start_child => (:GtkWidget, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :resize_start_child => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :resize_end_child => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :shrink_start_child => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :wide_handle => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :shrink_end_child => (:Bool, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPasswordEntry <: GtkWidget end
    end
    begin
        mutable struct GtkPasswordEntryLeaf <: GtkPasswordEntry
            handle::Ptr{GObject}
            function GtkPasswordEntryLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPasswordEntryLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPasswordEntryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPasswordEntryLeaf, args))
            end
            w = GtkPasswordEntryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPasswordEntry] = GtkPasswordEntryLeaf
        function GtkPasswordEntry(args...; kwargs...)
            GtkPasswordEntryLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPasswordEntryLeaf) = begin
                    [:handle, :placeholder_text, :text, :xalign, :selection_bound, :cursor_position, :extra_menu, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :activates_default, :visible, :has_default, :overflow, :max_width_chars, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :enable_undo, :has_tooltip, :accessible_role, :margin_end, :editable, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :width_chars, :margin_start, :show_peek_icon, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkPasswordEntryLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :text => (:String, 0, 3), :xalign => (:Float32, 0, 3), :selection_bound => (:Int32, 0, 1), :cursor_position => (:Int32, 0, 1), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :activates_default => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :enable_undo => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :editable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :show_peek_icon => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPasswordEntryLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:activates_default => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :placeholder_text => (:String, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :text => (:String, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :enable_undo => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :has_tooltip => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :xalign => (:Float32, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :show_peek_icon => (:Bool, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPasswordEntryBuffer <: GtkEntryBuffer end
    end
    begin
        mutable struct GtkPasswordEntryBufferLeaf <: GtkPasswordEntryBuffer
            handle::Ptr{GObject}
            function GtkPasswordEntryBufferLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPasswordEntryBufferLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPasswordEntryBufferLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPasswordEntryBufferLeaf, args))
            end
            w = GtkPasswordEntryBufferLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPasswordEntryBuffer] = GtkPasswordEntryBufferLeaf
        function GtkPasswordEntryBuffer(args...; kwargs...)
            GtkPasswordEntryBufferLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPasswordEntryBufferLeaf) = begin
                    [:handle, :max_length, :text, :length]
                end
            function Base.getproperty(o::GtkPasswordEntryBufferLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:max_length => (:Int32, 0, 3), :text => (:String, 0, 3), :length => (:UInt32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPasswordEntryBufferLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:max_length => (:Int32, 0, 3), :text => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPicture <: GtkWidget end
    end
    begin
        mutable struct GtkPictureLeaf <: GtkPicture
            handle::Ptr{GObject}
            function GtkPictureLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPictureLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPictureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPictureLeaf, args))
            end
            w = GtkPictureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPicture] = GtkPictureLeaf
        function GtkPicture(args...; kwargs...)
            GtkPictureLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPictureLeaf) = begin
                    [:handle, :root, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :file, :accessible_role, :margin_start, :margin_end, :hexpand, :alternative_text, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :paintable, :focus_on_click, :cursor, :margin_top, :keep_aspect_ratio, :tooltip_markup, :margin_bottom, :vexpand, :can_shrink, :can_target, :css_name, :scale_factor, :parent, :has_focus]
                end
            function Base.getproperty(o::GtkPictureLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:has_focus => (:Bool, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :file => (:GFile, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :alternative_text => (:String, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :paintable => (:GdkPaintable, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :keep_aspect_ratio => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :vexpand => (:Bool, 0, 3), :can_shrink => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :parent => (:GtkWidget, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPictureLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :file => (:GFile, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :alternative_text => (:String, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :paintable => (:GdkPaintable, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :keep_aspect_ratio => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_shrink => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPopoverMenu <: GtkPopover end
    end
    begin
        mutable struct GtkPopoverMenuLeaf <: GtkPopoverMenu
            handle::Ptr{GObject}
            function GtkPopoverMenuLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPopoverMenuLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPopoverMenuLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPopoverMenuLeaf, args))
            end
            w = GtkPopoverMenuLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPopoverMenu] = GtkPopoverMenuLeaf
        function GtkPopoverMenu(args...; kwargs...)
            GtkPopoverMenuLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPopoverMenuLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :child, :focus_on_click, :vexpand, :can_target, :css_name, :mnemonics_visible, :scale_factor, :pointing_to, :position, :visible, :has_default, :has_arrow, :overflow, :default_widget, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :visible_submenu, :menu_model, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :cascade_popdown, :margin_start, :autohide, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkPopoverMenuLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :pointing_to => (:GdkRectangle, 0, 3), :position => (:PositionType, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :has_arrow => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :visible_submenu => (:String, 0, 3), :menu_model => (:GMenuModel, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :cascade_popdown => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :autohide => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPopoverMenuLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pointing_to => (:GdkRectangle, 0, 3), :position => (:PositionType, 0, 3), :visible => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_arrow => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :cascade_popdown => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :default_widget => (:GtkWidget, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :autohide => (:Bool, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :visible_submenu => (:String, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :menu_model => (:GMenuModel, 0, 3), :margin_bottom => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPopoverMenuBar <: GtkWidget end
    end
    begin
        mutable struct GtkPopoverMenuBarLeaf <: GtkPopoverMenuBar
            handle::Ptr{GObject}
            function GtkPopoverMenuBarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPopoverMenuBarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPopoverMenuBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPopoverMenuBarLeaf, args))
            end
            w = GtkPopoverMenuBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPopoverMenuBar] = GtkPopoverMenuBarLeaf
        function GtkPopoverMenuBar(args...; kwargs...)
            GtkPopoverMenuBarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPopoverMenuBarLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :menu_model]
                end
            function Base.getproperty(o::GtkPopoverMenuBarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :menu_model => (:GMenuModel, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPopoverMenuBarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :menu_model => (:GMenuModel, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPrintContext <: GObject end
    end
    begin
        mutable struct GtkPrintContextLeaf <: GtkPrintContext
            handle::Ptr{GObject}
            function GtkPrintContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPrintContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrintContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrintContextLeaf, args))
            end
            w = GtkPrintContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrintContext] = GtkPrintContextLeaf
        function GtkPrintContext(args...; kwargs...)
            GtkPrintContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPrintJob <: GObject end
    end
    begin
        mutable struct GtkPrintJobLeaf <: GtkPrintJob
            handle::Ptr{GObject}
            function GtkPrintJobLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPrintJobLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrintJobLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrintJobLeaf, args))
            end
            w = GtkPrintJobLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrintJob] = GtkPrintJobLeaf
        function GtkPrintJob(args...; kwargs...)
            GtkPrintJobLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPrintJobLeaf) = begin
                    [:handle, :track_print_status, :page_setup, :settings, :title, :printer]
                end
            function Base.getproperty(o::GtkPrintJobLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:track_print_status => (:Bool, 0, 3), :page_setup => (:GtkPageSetup, 0, 11), :settings => (:GtkPrintSettings, 0, 11), :title => (:String, 0, 11), :printer => (:GtkPrinter, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPrintJobLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:track_print_status => (:Bool, 0, 3), :page_setup => (:GtkPageSetup, 0, 11), :settings => (:GtkPrintSettings, 0, 11), :title => (:String, 0, 11), :printer => (:GtkPrinter, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPrintOperation <: GObject end
    end
    begin
        mutable struct GtkPrintOperationLeaf <: GtkPrintOperation
            handle::Ptr{GObject}
            function GtkPrintOperationLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPrintOperationLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrintOperationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrintOperationLeaf, args))
            end
            w = GtkPrintOperationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrintOperation] = GtkPrintOperationLeaf
        function GtkPrintOperation(args...; kwargs...)
            GtkPrintOperationLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPrintOperationLeaf) = begin
                    [:handle, :has_selection, :track_print_status, :use_full_page, :status_string, :current_page, :allow_async, :show_progress, :print_settings, :default_page_setup, :job_name, :export_filename, :embed_page_setup, :status, :unit, :support_selection, :custom_tab_label, :n_pages_to_print, :n_pages]
                end
            function Base.getproperty(o::GtkPrintOperationLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:has_selection => (:Bool, 0, 3), :track_print_status => (:Bool, 0, 3), :use_full_page => (:Bool, 0, 3), :status_string => (:String, 0, 1), :current_page => (:Int32, 0, 3), :show_progress => (:Bool, 0, 3), :allow_async => (:Bool, 0, 3), :print_settings => (:GtkPrintSettings, 0, 3), :default_page_setup => (:GtkPageSetup, 0, 3), :job_name => (:String, 0, 3), :export_filename => (:String, 0, 3), :embed_page_setup => (:Bool, 0, 3), :status => (:PrintStatus, 0, 1), :unit => (:Unit, 0, 3), :support_selection => (:Bool, 0, 3), :custom_tab_label => (:String, 0, 3), :n_pages_to_print => (:Int32, 0, 1), :n_pages => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPrintOperationLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:has_selection => (:Bool, 0, 3), :track_print_status => (:Bool, 0, 3), :use_full_page => (:Bool, 0, 3), :current_page => (:Int32, 0, 3), :show_progress => (:Bool, 0, 3), :allow_async => (:Bool, 0, 3), :print_settings => (:GtkPrintSettings, 0, 3), :default_page_setup => (:GtkPageSetup, 0, 3), :job_name => (:String, 0, 3), :export_filename => (:String, 0, 3), :embed_page_setup => (:Bool, 0, 3), :unit => (:Unit, 0, 3), :support_selection => (:Bool, 0, 3), :custom_tab_label => (:String, 0, 3), :n_pages => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPrintSettings <: GObject end
    end
    begin
        mutable struct GtkPrintSettingsLeaf <: GtkPrintSettings
            handle::Ptr{GObject}
            function GtkPrintSettingsLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPrintSettingsLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrintSettingsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrintSettingsLeaf, args))
            end
            w = GtkPrintSettingsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrintSettings] = GtkPrintSettingsLeaf
        function GtkPrintSettings(args...; kwargs...)
            GtkPrintSettingsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPrintUnixDialog <: GtkDialog end
    end
    begin
        mutable struct GtkPrintUnixDialogLeaf <: GtkPrintUnixDialog
            handle::Ptr{GObject}
            function GtkPrintUnixDialogLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPrintUnixDialogLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrintUnixDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrintUnixDialogLeaf, args))
            end
            w = GtkPrintUnixDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrintUnixDialog] = GtkPrintUnixDialogLeaf
        function GtkPrintUnixDialog(args...; kwargs...)
            GtkPrintUnixDialogLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPrintUnixDialogLeaf) = begin
                    [:handle, :application, :hexpand, :embed_page_setup, :halign, :name, :opacity, :use_header_bar, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :has_selection, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :page_setup, :has_tooltip, :transient_for, :print_settings, :accessible_role, :margin_end, :support_selection, :display, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :current_page, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :manual_capabilities, :default_width, :sensitive, :margin_top, :has_focus, :selected_printer]
                end
            function Base.getproperty(o::GtkPrintUnixDialogLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :embed_page_setup => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :has_selection => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :page_setup => (:GtkPageSetup, 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :print_settings => (:GtkPrintSettings, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :support_selection => (:Bool, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :current_page => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :manual_capabilities => (:Int32, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1), :selected_printer => (:GtkPrinter, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPrintUnixDialogLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :embed_page_setup => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :use_header_bar => (:Int32, 0, 11), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :has_selection => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :page_setup => (:GtkPageSetup, 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :print_settings => (:GtkPrintSettings, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :support_selection => (:Bool, 0, 3), :display => (:GdkDisplay, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :current_page => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :manual_capabilities => (:Int32, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkPrinter <: GObject end
    end
    begin
        mutable struct GtkPrinterLeaf <: GtkPrinter
            handle::Ptr{GObject}
            function GtkPrinterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkPrinterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrinterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrinterLeaf, args))
            end
            w = GtkPrinterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrinter] = GtkPrinterLeaf
        function GtkPrinter(args...; kwargs...)
            GtkPrinterLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkPrinterLeaf) = begin
                    [:handle, :accepts_ps, :accepts_pdf, :location, :job_count, :name, :paused, :accepting_jobs, :is_virtual, :state_message, :icon_name]
                end
            function Base.getproperty(o::GtkPrinterLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:accepts_ps => (:Bool, 0, 11), :icon_name => (:String, 0, 1), :location => (:String, 0, 1), :job_count => (:Int32, 0, 1), :name => (:String, 0, 11), :paused => (:Bool, 0, 1), :accepting_jobs => (:Bool, 0, 1), :is_virtual => (:Bool, 0, 11), :state_message => (:String, 0, 1), :accepts_pdf => (:Bool, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkPrinterLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:accepts_ps => (:Bool, 0, 11), :name => (:String, 0, 11), :is_virtual => (:Bool, 0, 11), :accepts_pdf => (:Bool, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkProgressBar <: GtkWidget end
    end
    begin
        mutable struct GtkProgressBarLeaf <: GtkProgressBar
            handle::Ptr{GObject}
            function GtkProgressBarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkProgressBarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkProgressBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkProgressBarLeaf, args))
            end
            w = GtkProgressBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkProgressBar] = GtkProgressBarLeaf
        function GtkProgressBar(args...; kwargs...)
            GtkProgressBarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkProgressBarLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :text, :pulse_step, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :fraction, :hexpand, :show_text, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :inverted, :hexpand_set, :sensitive, :width_request, :ellipsize, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkProgressBarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :text => (:String, 0, 3), :pulse_step => (:Float64, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :fraction => (:Float64, 0, 3), :hexpand => (:Bool, 0, 3), :show_text => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :inverted => (:Bool, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkProgressBarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :text => (:String, 0, 3), :orientation => (:Orientation, 0, 3), :pulse_step => (:Float64, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :fraction => (:Float64, 0, 3), :hexpand => (:Bool, 0, 3), :show_text => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :inverted => (:Bool, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :ellipsize => (:EllipsizeMode, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkRange <: GtkWidget end
    end
    begin
        mutable struct GtkRangeLeaf <: GtkRange
            handle::Ptr{GObject}
            function GtkRangeLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkRangeLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkRangeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkRangeLeaf, args))
            end
            w = GtkRangeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkRange] = GtkRangeLeaf
        function GtkRange(args...; kwargs...)
            GtkRangeLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkRangeLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :show_fill_level, :margin_start, :margin_end, :adjustment, :hexpand, :restrict_to_fill_level, :receives_default, :round_digits, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :inverted, :hexpand_set, :fill_level, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkRangeLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :show_fill_level => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 7), :hexpand => (:Bool, 0, 3), :restrict_to_fill_level => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :round_digits => (:Int32, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :inverted => (:Bool, 0, 3), :hexpand_set => (:Bool, 0, 3), :fill_level => (:Float64, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkRangeLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :show_fill_level => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 7), :hexpand => (:Bool, 0, 3), :restrict_to_fill_level => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :round_digits => (:Int32, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :inverted => (:Bool, 0, 3), :hexpand_set => (:Bool, 0, 3), :fill_level => (:Float64, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkRecentManager <: GObject end
    end
    begin
        mutable struct GtkRecentManagerLeaf <: GtkRecentManager
            handle::Ptr{GObject}
            function GtkRecentManagerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkRecentManagerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkRecentManagerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkRecentManagerLeaf, args))
            end
            w = GtkRecentManagerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkRecentManager] = GtkRecentManagerLeaf
        function GtkRecentManager(args...; kwargs...)
            GtkRecentManagerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkRecentManagerLeaf) = begin
                    [:handle, :filename, :size]
                end
            function Base.getproperty(o::GtkRecentManagerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:filename => (:String, 0, 11), :size => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkRecentManagerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:filename => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkRevealer <: GtkWidget end
    end
    begin
        mutable struct GtkRevealerLeaf <: GtkRevealer
            handle::Ptr{GObject}
            function GtkRevealerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkRevealerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkRevealerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkRevealerLeaf, args))
            end
            w = GtkRevealerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkRevealer] = GtkRevealerLeaf
        function GtkRevealer(args...; kwargs...)
            GtkRevealerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkRevealerLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :transition_duration, :accessible_role, :margin_start, :margin_end, :reveal_child, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :transition_type, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :child_revealed]
                end
            function Base.getproperty(o::GtkRevealerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :transition_duration => (:UInt32, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :reveal_child => (:Bool, 0, 7), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :transition_type => (:RevealerTransitionType, 0, 7), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :child_revealed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkRevealerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :transition_duration => (:UInt32, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :reveal_child => (:Bool, 0, 7), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :transition_type => (:RevealerTransitionType, 0, 7), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkScale <: GtkRange end
    end
    begin
        mutable struct GtkScaleLeaf <: GtkScale
            handle::Ptr{GObject}
            function GtkScaleLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkScaleLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkScaleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkScaleLeaf, args))
            end
            w = GtkScaleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkScale] = GtkScaleLeaf
        function GtkScale(args...; kwargs...)
            GtkScaleLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkScaleLeaf) = begin
                    [:handle, :draw_value, :restrict_to_fill_level, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :digits, :scale_factor, :visible, :has_default, :overflow, :receives_default, :tooltip_text, :can_focus, :height_request, :fill_level, :hexpand_set, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :show_fill_level, :margin_end, :round_digits, :width_request, :cursor, :tooltip_markup, :parent, :has_origin, :value_pos, :focusable, :valign, :vexpand_set, :orientation, :margin_start, :adjustment, :inverted, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkScaleLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:draw_value => (:Bool, 0, 3), :restrict_to_fill_level => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :digits => (:Int32, 0, 3), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :fill_level => (:Float64, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :show_fill_level => (:Bool, 0, 3), :margin_end => (:Int32, 0, 3), :round_digits => (:Int32, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :has_origin => (:Bool, 0, 3), :value_pos => (:PositionType, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :margin_start => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 7), :inverted => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkScaleLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:has_origin => (:Bool, 0, 3), :value_pos => (:PositionType, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :draw_value => (:Bool, 0, 3), :show_fill_level => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :restrict_to_fill_level => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :adjustment => (:GtkAdjustment, 0, 7), :receives_default => (:Bool, 0, 3), :round_digits => (:Int32, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :fill_level => (:Float64, 0, 3), :hexpand_set => (:Bool, 0, 3), :inverted => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :digits => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkScaleButton <: GtkWidget end
    end
    begin
        mutable struct GtkScaleButtonLeaf <: GtkScaleButton
            handle::Ptr{GObject}
            function GtkScaleButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkScaleButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkScaleButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkScaleButtonLeaf, args))
            end
            w = GtkScaleButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkScaleButton] = GtkScaleButtonLeaf
        function GtkScaleButton(args...; kwargs...)
            GtkScaleButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkScaleButtonLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :adjustment, :hexpand, :icons, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :value]
                end
            function Base.getproperty(o::GtkScaleButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 3), :hexpand => (:Bool, 0, 3), :icons => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :value => (:Float64, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkScaleButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 3), :hexpand => (:Bool, 0, 3), :icons => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :value => (:Float64, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkScrollbar <: GtkWidget end
    end
    begin
        mutable struct GtkScrollbarLeaf <: GtkScrollbar
            handle::Ptr{GObject}
            function GtkScrollbarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkScrollbarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkScrollbarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkScrollbarLeaf, args))
            end
            w = GtkScrollbarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkScrollbar] = GtkScrollbarLeaf
        function GtkScrollbar(args...; kwargs...)
            GtkScrollbarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkScrollbarLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :adjustment, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkScrollbarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 7), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkScrollbarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 7), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkScrolledWindow <: GtkWidget end
    end
    begin
        mutable struct GtkScrolledWindowLeaf <: GtkScrolledWindow
            handle::Ptr{GObject}
            function GtkScrolledWindowLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkScrolledWindowLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkScrolledWindowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkScrolledWindowLeaf, args))
            end
            w = GtkScrolledWindowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkScrolledWindow] = GtkScrolledWindowLeaf
        function GtkScrolledWindow(args...; kwargs...)
            GtkScrolledWindowLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkScrolledWindowLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :child, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :hadjustment, :overflow, :hscrollbar_policy, :receives_default, :propagate_natural_width, :tooltip_text, :can_focus, :min_content_height, :min_content_width, :height_request, :hexpand_set, :margin_bottom, :root, :has_frame, :vscrollbar_policy, :css_classes, :max_content_width, :has_tooltip, :accessible_role, :margin_end, :vadjustment, :width_request, :cursor, :tooltip_markup, :kinetic_scrolling, :parent, :overlay_scrolling, :focusable, :valign, :vexpand_set, :max_content_height, :propagate_natural_height, :margin_start, :sensitive, :margin_top, :has_focus, :window_placement]
                end
            function Base.getproperty(o::GtkScrolledWindowLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :hadjustment => (:GtkAdjustment, 0, 7), :overflow => (:Overflow, 0, 3), :hscrollbar_policy => (:PolicyType, 0, 3), :receives_default => (:Bool, 0, 3), :propagate_natural_width => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :min_content_height => (:Int32, 0, 3), :min_content_width => (:Int32, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :has_frame => (:Bool, 0, 3), :vscrollbar_policy => (:PolicyType, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :max_content_width => (:Int32, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :kinetic_scrolling => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :overlay_scrolling => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :max_content_height => (:Int32, 0, 3), :propagate_natural_height => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1), :window_placement => (:CornerType, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkScrolledWindowLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :visible => (:Bool, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :overflow => (:Overflow, 0, 3), :hscrollbar_policy => (:PolicyType, 0, 3), :receives_default => (:Bool, 0, 3), :propagate_natural_width => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :min_content_height => (:Int32, 0, 3), :min_content_width => (:Int32, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :has_frame => (:Bool, 0, 3), :vscrollbar_policy => (:PolicyType, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :max_content_width => (:Int32, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :kinetic_scrolling => (:Bool, 0, 3), :overlay_scrolling => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :max_content_height => (:Int32, 0, 3), :propagate_natural_height => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :window_placement => (:CornerType, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSearchBar <: GtkWidget end
    end
    begin
        mutable struct GtkSearchBarLeaf <: GtkSearchBar
            handle::Ptr{GObject}
            function GtkSearchBarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSearchBarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSearchBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSearchBarLeaf, args))
            end
            w = GtkSearchBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSearchBar] = GtkSearchBarLeaf
        function GtkSearchBar(args...; kwargs...)
            GtkSearchBarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSearchBarLeaf) = begin
                    [:handle, :show_close_button, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :key_capture_widget, :search_mode_enabled, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkSearchBarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:show_close_button => (:Bool, 0, 7), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :key_capture_widget => (:GtkWidget, 0, 7), :search_mode_enabled => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 7), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSearchBarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:show_close_button => (:Bool, 0, 7), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :key_capture_widget => (:GtkWidget, 0, 7), :search_mode_enabled => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 7), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSearchEntry <: GtkWidget end
    end
    begin
        mutable struct GtkSearchEntryLeaf <: GtkSearchEntry
            handle::Ptr{GObject}
            function GtkSearchEntryLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSearchEntryLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSearchEntryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSearchEntryLeaf, args))
            end
            w = GtkSearchEntryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSearchEntry] = GtkSearchEntryLeaf
        function GtkSearchEntry(args...; kwargs...)
            GtkSearchEntryLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSearchEntryLeaf) = begin
                    [:handle, :placeholder_text, :text, :xalign, :selection_bound, :cursor_position, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :activates_default, :visible, :has_default, :overflow, :max_width_chars, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :enable_undo, :has_tooltip, :accessible_role, :margin_end, :editable, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :width_chars, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkSearchEntryLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :text => (:String, 0, 3), :xalign => (:Float32, 0, 3), :selection_bound => (:Int32, 0, 1), :cursor_position => (:Int32, 0, 1), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :activates_default => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :enable_undo => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :editable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSearchEntryLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:activates_default => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :placeholder_text => (:String, 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :text => (:String, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :enable_undo => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :has_tooltip => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :xalign => (:Float32, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSelectionFilterModel <: GObject end
    end
    begin
        mutable struct GtkSelectionFilterModelLeaf <: GtkSelectionFilterModel
            handle::Ptr{GObject}
            function GtkSelectionFilterModelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSelectionFilterModelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSelectionFilterModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSelectionFilterModelLeaf, args))
            end
            w = GtkSelectionFilterModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSelectionFilterModel] = GtkSelectionFilterModelLeaf
        function GtkSelectionFilterModel(args...; kwargs...)
            GtkSelectionFilterModelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSelectionFilterModelLeaf) = begin
                    [:handle, :model]
                end
            function Base.getproperty(o::GtkSelectionFilterModelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GtkSelectionModel, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSelectionFilterModelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GtkSelectionModel, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSeparator <: GtkWidget end
    end
    begin
        mutable struct GtkSeparatorLeaf <: GtkSeparator
            handle::Ptr{GObject}
            function GtkSeparatorLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSeparatorLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSeparatorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSeparatorLeaf, args))
            end
            w = GtkSeparatorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSeparator] = GtkSeparatorLeaf
        function GtkSeparator(args...; kwargs...)
            GtkSeparatorLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSeparatorLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkSeparatorLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSeparatorLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSettings <: GObject end
    end
    begin
        mutable struct GtkSettingsLeaf <: GtkSettings
            handle::Ptr{GObject}
            function GtkSettingsLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSettingsLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSettingsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSettingsLeaf, args))
            end
            w = GtkSettingsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSettings] = GtkSettingsLeaf
        function GtkSettings(args...; kwargs...)
            GtkSettingsLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSettingsLeaf) = begin
                    [:handle, :gtk_double_click_distance, :gtk_enable_primary_paste, :gtk_error_bell, :gtk_shell_shows_app_menu, :gtk_dnd_drag_threshold, :gtk_recent_files_max_age, :gtk_cursor_blink_time, :gtk_decoration_layout, :gtk_entry_select_on_focus, :gtk_double_click_time, :gtk_xft_hintstyle, :gtk_enable_accels, :gtk_xft_antialias, :gtk_long_press_time, :gtk_cursor_blink, :gtk_shell_shows_menubar, :gtk_alternative_sort_arrows, :gtk_icon_theme_name, :gtk_split_cursor, :gtk_cursor_theme_size, :gtk_theme_name, :gtk_alternative_button_order, :gtk_primary_button_warps_slider, :gtk_font_name, :gtk_shell_shows_desktop, :gtk_im_module, :gtk_dialogs_use_header, :gtk_entry_password_hint_timeout, :gtk_enable_event_sounds, :gtk_cursor_blink_timeout, :gtk_recent_files_enabled, :gtk_enable_input_feedback_sounds, :gtk_titlebar_right_click, :gtk_enable_animations, :gtk_cursor_theme_name, :gtk_overlay_scrolling, :gtk_titlebar_middle_click, :gtk_label_select_on_focus, :gtk_sound_theme_name, :gtk_titlebar_double_click, :gtk_fontconfig_timestamp, :gtk_keynav_use_caret, :gtk_xft_rgba, :gtk_cursor_aspect_ratio, :gtk_xft_hinting, :gtk_print_backends, :gtk_xft_dpi, :gtk_application_prefer_dark_theme, :gtk_print_preview_command]
                end
            function Base.getproperty(o::GtkSettingsLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:gtk_print_preview_command => (:String, 0, 3), :gtk_enable_primary_paste => (:Bool, 0, 3), :gtk_error_bell => (:Bool, 0, 3), :gtk_shell_shows_app_menu => (:Bool, 0, 3), :gtk_dnd_drag_threshold => (:Int32, 0, 3), :gtk_recent_files_max_age => (:Int32, 0, 3), :gtk_cursor_blink_time => (:Int32, 0, 3), :gtk_decoration_layout => (:String, 0, 3), :gtk_entry_select_on_focus => (:Bool, 0, 3), :gtk_double_click_time => (:Int32, 0, 3), :gtk_xft_hintstyle => (:String, 0, 3), :gtk_enable_accels => (:Bool, 0, 3), :gtk_xft_antialias => (:Int32, 0, 3), :gtk_long_press_time => (:UInt32, 0, 3), :gtk_cursor_blink => (:Bool, 0, 3), :gtk_shell_shows_menubar => (:Bool, 0, 3), :gtk_alternative_sort_arrows => (:Bool, 0, 3), :gtk_icon_theme_name => (:String, 0, 3), :gtk_split_cursor => (:Bool, 0, 3), :gtk_cursor_theme_size => (:Int32, 0, 3), :gtk_theme_name => (:String, 0, 3), :gtk_alternative_button_order => (:Bool, 0, 3), :gtk_primary_button_warps_slider => (:Bool, 0, 3), :gtk_font_name => (:String, 0, 3), :gtk_shell_shows_desktop => (:Bool, 0, 3), :gtk_im_module => (:String, 0, 3), :gtk_dialogs_use_header => (:Bool, 0, 3), :gtk_entry_password_hint_timeout => (:UInt32, 0, 3), :gtk_enable_event_sounds => (:Bool, 0, 3), :gtk_cursor_blink_timeout => (:Int32, 0, 3), :gtk_recent_files_enabled => (:Bool, 0, 3), :gtk_enable_input_feedback_sounds => (:Bool, 0, 3), :gtk_titlebar_right_click => (:String, 0, 3), :gtk_enable_animations => (:Bool, 0, 3), :gtk_cursor_theme_name => (:String, 0, 3), :gtk_overlay_scrolling => (:Bool, 0, 3), :gtk_titlebar_middle_click => (:String, 0, 3), :gtk_label_select_on_focus => (:Bool, 0, 3), :gtk_sound_theme_name => (:String, 0, 3), :gtk_titlebar_double_click => (:String, 0, 3), :gtk_fontconfig_timestamp => (:UInt32, 0, 3), :gtk_keynav_use_caret => (:Bool, 0, 3), :gtk_xft_rgba => (:String, 0, 3), :gtk_cursor_aspect_ratio => (:Float64, 0, 3), :gtk_xft_hinting => (:Int32, 0, 3), :gtk_print_backends => (:String, 0, 3), :gtk_xft_dpi => (:Int32, 0, 3), :gtk_application_prefer_dark_theme => (:Bool, 0, 3), :gtk_double_click_distance => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSettingsLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:gtk_print_preview_command => (:String, 0, 3), :gtk_enable_primary_paste => (:Bool, 0, 3), :gtk_error_bell => (:Bool, 0, 3), :gtk_shell_shows_app_menu => (:Bool, 0, 3), :gtk_dnd_drag_threshold => (:Int32, 0, 3), :gtk_recent_files_max_age => (:Int32, 0, 3), :gtk_cursor_blink_time => (:Int32, 0, 3), :gtk_decoration_layout => (:String, 0, 3), :gtk_entry_select_on_focus => (:Bool, 0, 3), :gtk_double_click_time => (:Int32, 0, 3), :gtk_xft_hintstyle => (:String, 0, 3), :gtk_enable_accels => (:Bool, 0, 3), :gtk_xft_antialias => (:Int32, 0, 3), :gtk_long_press_time => (:UInt32, 0, 3), :gtk_cursor_blink => (:Bool, 0, 3), :gtk_shell_shows_menubar => (:Bool, 0, 3), :gtk_alternative_sort_arrows => (:Bool, 0, 3), :gtk_icon_theme_name => (:String, 0, 3), :gtk_split_cursor => (:Bool, 0, 3), :gtk_cursor_theme_size => (:Int32, 0, 3), :gtk_theme_name => (:String, 0, 3), :gtk_alternative_button_order => (:Bool, 0, 3), :gtk_primary_button_warps_slider => (:Bool, 0, 3), :gtk_font_name => (:String, 0, 3), :gtk_shell_shows_desktop => (:Bool, 0, 3), :gtk_im_module => (:String, 0, 3), :gtk_dialogs_use_header => (:Bool, 0, 3), :gtk_entry_password_hint_timeout => (:UInt32, 0, 3), :gtk_enable_event_sounds => (:Bool, 0, 3), :gtk_cursor_blink_timeout => (:Int32, 0, 3), :gtk_recent_files_enabled => (:Bool, 0, 3), :gtk_enable_input_feedback_sounds => (:Bool, 0, 3), :gtk_titlebar_right_click => (:String, 0, 3), :gtk_enable_animations => (:Bool, 0, 3), :gtk_cursor_theme_name => (:String, 0, 3), :gtk_overlay_scrolling => (:Bool, 0, 3), :gtk_titlebar_middle_click => (:String, 0, 3), :gtk_label_select_on_focus => (:Bool, 0, 3), :gtk_sound_theme_name => (:String, 0, 3), :gtk_titlebar_double_click => (:String, 0, 3), :gtk_fontconfig_timestamp => (:UInt32, 0, 3), :gtk_keynav_use_caret => (:Bool, 0, 3), :gtk_xft_rgba => (:String, 0, 3), :gtk_cursor_aspect_ratio => (:Float64, 0, 3), :gtk_xft_hinting => (:Int32, 0, 3), :gtk_print_backends => (:String, 0, 3), :gtk_xft_dpi => (:Int32, 0, 3), :gtk_application_prefer_dark_theme => (:Bool, 0, 3), :gtk_double_click_distance => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkShortcut <: GObject end
    end
    begin
        mutable struct GtkShortcutLeaf <: GtkShortcut
            handle::Ptr{GObject}
            function GtkShortcutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkShortcutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutLeaf, args))
            end
            w = GtkShortcutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcut] = GtkShortcutLeaf
        function GtkShortcut(args...; kwargs...)
            GtkShortcutLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkShortcutLeaf) = begin
                    [:handle, :trigger, :action, :arguments]
                end
            function Base.getproperty(o::GtkShortcutLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:trigger => (:GtkShortcutTrigger, 0, 3), :action => (:GtkShortcutAction, 0, 3), :arguments => (:GVariant, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkShortcutLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:trigger => (:GtkShortcutTrigger, 0, 3), :action => (:GtkShortcutAction, 0, 3), :arguments => (:GVariant, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkShortcutController <: GtkEventController end
    end
    begin
        mutable struct GtkShortcutControllerLeaf <: GtkShortcutController
            handle::Ptr{GObject}
            function GtkShortcutControllerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkShortcutControllerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutControllerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutControllerLeaf, args))
            end
            w = GtkShortcutControllerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutController] = GtkShortcutControllerLeaf
        function GtkShortcutController(args...; kwargs...)
            GtkShortcutControllerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkShortcutControllerLeaf) = begin
                    [:handle, :propagation_limit, :widget, :name, :mnemonic_modifiers, :model, :scope, :propagation_phase]
                end
            function Base.getproperty(o::GtkShortcutControllerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :widget => (:GtkWidget, 0, 1), :name => (:String, 0, 3), :mnemonic_modifiers => (:Int32, 0, 3), :scope => (:ShortcutScope, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkShortcutControllerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:propagation_limit => (:PropagationLimit, 0, 3), :name => (:String, 0, 3), :mnemonic_modifiers => (:Int32, 0, 3), :model => (:GListModel, 0, 10), :scope => (:ShortcutScope, 0, 3), :propagation_phase => (:PropagationPhase, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkShortcutLabel <: GtkWidget end
    end
    begin
        mutable struct GtkShortcutLabelLeaf <: GtkShortcutLabel
            handle::Ptr{GObject}
            function GtkShortcutLabelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkShortcutLabelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutLabelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutLabelLeaf, args))
            end
            w = GtkShortcutLabelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutLabel] = GtkShortcutLabelLeaf
        function GtkShortcutLabel(args...; kwargs...)
            GtkShortcutLabelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkShortcutLabelLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :disabled_text, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :accelerator, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkShortcutLabelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :disabled_text => (:String, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :accelerator => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkShortcutLabelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :disabled_text => (:String, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :accelerator => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkShortcutsGroup <: GtkBox end
    end
    begin
        mutable struct GtkShortcutsGroupLeaf <: GtkShortcutsGroup
            handle::Ptr{GObject}
            function GtkShortcutsGroupLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsGroupLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutsGroupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutsGroupLeaf, args))
            end
            w = GtkShortcutsGroupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutsGroup] = GtkShortcutsGroupLeaf
        function GtkShortcutsGroup(args...; kwargs...)
            GtkShortcutsGroupLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkShortcutsGroupLeaf) = begin
                    [:handle, :height, :hexpand, :halign, :name, :opacity, :layout_manager, :view, :focus_on_click, :vexpand, :title_size_group, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :homogeneous, :title, :receives_default, :tooltip_text, :can_focus, :height_request, :baseline_position, :hexpand_set, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :width_request, :cursor, :tooltip_markup, :parent, :spacing, :focusable, :valign, :vexpand_set, :orientation, :accel_size_group, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkShortcutsGroupLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :height => (:UInt32, 0, 1), :spacing => (:Int32, 0, 3), :has_default => (:Bool, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :homogeneous => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :title => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :view => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :root => (:GtkRoot, 0, 1), :parent => (:GtkWidget, 0, 1), :scale_factor => (:Int32, 0, 1), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkShortcutsGroupLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :spacing => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accel_size_group => (:GtkSizeGroup, 0, 2), :homogeneous => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :title => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :view => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :title_size_group => (:GtkSizeGroup, 0, 2), :margin_bottom => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkShortcutsSection <: GtkBox end
    end
    begin
        mutable struct GtkShortcutsSectionLeaf <: GtkShortcutsSection
            handle::Ptr{GObject}
            function GtkShortcutsSectionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsSectionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutsSectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutsSectionLeaf, args))
            end
            w = GtkShortcutsSectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutsSection] = GtkShortcutsSectionLeaf
        function GtkShortcutsSection(args...; kwargs...)
            GtkShortcutsSectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkShortcutsSectionLeaf) = begin
                    [:handle, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :homogeneous, :title, :receives_default, :tooltip_text, :max_height, :can_focus, :height_request, :baseline_position, :hexpand_set, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :section_name, :view_name, :width_request, :cursor, :tooltip_markup, :parent, :spacing, :focusable, :valign, :vexpand_set, :orientation, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkShortcutsSectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :homogeneous => (:Bool, 0, 3), :title => (:String, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :max_height => (:UInt32, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :section_name => (:String, 0, 3), :view_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :spacing => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkShortcutsSectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :spacing => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :homogeneous => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :title => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :max_height => (:UInt32, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :section_name => (:String, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :baseline_position => (:BaselinePosition, 0, 3), :hexpand_set => (:Bool, 0, 3), :view_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkShortcutsShortcut <: GtkWidget end
    end
    begin
        mutable struct GtkShortcutsShortcutLeaf <: GtkShortcutsShortcut
            handle::Ptr{GObject}
            function GtkShortcutsShortcutLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsShortcutLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutsShortcutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutsShortcutLeaf, args))
            end
            w = GtkShortcutsShortcutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutsShortcut] = GtkShortcutsShortcutLeaf
        function GtkShortcutsShortcut(args...; kwargs...)
            GtkShortcutsShortcutLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkShortcutsShortcutLeaf) = begin
                    [:handle, :subtitle_set, :subtitle, :hexpand, :halign, :name, :opacity, :icon, :layout_manager, :focus_on_click, :vexpand, :title_size_group, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :title, :icon_set, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :shortcut_type, :css_classes, :has_tooltip, :accessible_role, :margin_end, :action_name, :width_request, :accelerator, :cursor, :tooltip_markup, :parent, :direction, :focusable, :valign, :vexpand_set, :accel_size_group, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkShortcutsShortcutLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:subtitle_set => (:Bool, 0, 3), :subtitle => (:String, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :icon => (:GIcon, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :icon_set => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :shortcut_type => (:ShortcutType, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :action_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :accelerator => (:String, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :direction => (:TextDirection, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkShortcutsShortcutLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:subtitle_set => (:Bool, 0, 3), :shortcut_type => (:ShortcutType, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :subtitle => (:String, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accel_size_group => (:GtkSizeGroup, 0, 2), :accessible_role => (:AccessibleRole, 0, 3), :title => (:String, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :icon_set => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :icon => (:GIcon, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :accelerator => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :title_size_group => (:GtkSizeGroup, 0, 2), :margin_bottom => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :margin_top => (:Int32, 0, 3), :direction => (:TextDirection, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkShortcutsWindow <: GtkWindow end
    end
    begin
        mutable struct GtkShortcutsWindowLeaf <: GtkShortcutsWindow
            handle::Ptr{GObject}
            function GtkShortcutsWindowLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsWindowLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutsWindowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutsWindowLeaf, args))
            end
            w = GtkShortcutsWindowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutsWindow] = GtkShortcutsWindowLeaf
        function GtkShortcutsWindow(args...; kwargs...)
            GtkShortcutsWindowLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkShortcutsWindowLeaf) = begin
                    [:handle, :application, :hexpand, :halign, :name, :opacity, :layout_manager, :default_height, :child, :focus_on_click, :vexpand, :is_active, :can_target, :css_name, :mnemonics_visible, :scale_factor, :fullscreened, :visible, :has_default, :resizable, :overflow, :title, :default_widget, :receives_default, :tooltip_text, :can_focus, :modal, :height_request, :hexpand_set, :margin_bottom, :decorated, :root, :icon_name, :css_classes, :has_tooltip, :transient_for, :accessible_role, :margin_end, :section_name, :display, :view_name, :width_request, :cursor, :tooltip_markup, :focus_visible, :deletable, :parent, :focusable, :valign, :vexpand_set, :destroy_with_parent, :maximized, :startup_id, :margin_start, :hide_on_close, :focus_widget, :handle_menubar_accel, :default_width, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkShortcutsWindowLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :is_active => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :section_name => (:String, 0, 3), :display => (:GdkDisplay, 0, 3), :view_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkShortcutsWindowLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:application => (:GtkApplication, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :default_height => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :mnemonics_visible => (:Bool, 0, 3), :fullscreened => (:Bool, 0, 7), :visible => (:Bool, 0, 3), :resizable => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :title => (:String, 0, 3), :default_widget => (:GtkWidget, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :modal => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :decorated => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :transient_for => (:GtkWindow, 0, 7), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :section_name => (:String, 0, 3), :display => (:GdkDisplay, 0, 3), :view_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focus_visible => (:Bool, 0, 3), :deletable => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :destroy_with_parent => (:Bool, 0, 3), :maximized => (:Bool, 0, 7), :startup_id => (:String, 0, 2), :margin_start => (:Int32, 0, 3), :hide_on_close => (:Bool, 0, 3), :focus_widget => (:GtkWidget, 0, 3), :handle_menubar_accel => (:Bool, 0, 3), :default_width => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSignalAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkSignalActionLeaf <: GtkSignalAction
            handle::Ptr{GObject}
            function GtkSignalActionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSignalActionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSignalActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSignalActionLeaf, args))
            end
            w = GtkSignalActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSignalAction] = GtkSignalActionLeaf
        function GtkSignalAction(args...; kwargs...)
            GtkSignalActionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSignalActionLeaf) = begin
                    [:handle, :signal_name]
                end
            function Base.getproperty(o::GtkSignalActionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:signal_name => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSignalActionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:signal_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSignalListItemFactory <: GtkListItemFactory end
    end
    begin
        mutable struct GtkSignalListItemFactoryLeaf <: GtkSignalListItemFactory
            handle::Ptr{GObject}
            function GtkSignalListItemFactoryLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSignalListItemFactoryLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSignalListItemFactoryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSignalListItemFactoryLeaf, args))
            end
            w = GtkSignalListItemFactoryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSignalListItemFactory] = GtkSignalListItemFactoryLeaf
        function GtkSignalListItemFactory(args...; kwargs...)
            GtkSignalListItemFactoryLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSingleSelection <: GObject end
    end
    begin
        mutable struct GtkSingleSelectionLeaf <: GtkSingleSelection
            handle::Ptr{GObject}
            function GtkSingleSelectionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSingleSelectionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSingleSelectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSingleSelectionLeaf, args))
            end
            w = GtkSingleSelectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSingleSelection] = GtkSingleSelectionLeaf
        function GtkSingleSelection(args...; kwargs...)
            GtkSingleSelectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSingleSelectionLeaf) = begin
                    [:handle, :autoselect, :can_unselect, :selected, :model, :selected_item]
                end
            function Base.getproperty(o::GtkSingleSelectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:autoselect => (:Bool, 0, 3), :can_unselect => (:Bool, 0, 3), :selected => (:UInt32, 0, 3), :model => (:GListModel, 0, 3), :selected_item => (:GObject, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSingleSelectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:autoselect => (:Bool, 0, 3), :can_unselect => (:Bool, 0, 3), :selected => (:UInt32, 0, 3), :model => (:GListModel, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSizeGroup <: GObject end
    end
    begin
        mutable struct GtkSizeGroupLeaf <: GtkSizeGroup
            handle::Ptr{GObject}
            function GtkSizeGroupLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSizeGroupLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSizeGroupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSizeGroupLeaf, args))
            end
            w = GtkSizeGroupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSizeGroup] = GtkSizeGroupLeaf
        function GtkSizeGroup(args...; kwargs...)
            GtkSizeGroupLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSizeGroupLeaf) = begin
                    [:handle, :mode]
                end
            function Base.getproperty(o::GtkSizeGroupLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:mode => (:SizeGroupMode, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSizeGroupLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:mode => (:SizeGroupMode, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSliceListModel <: GObject end
    end
    begin
        mutable struct GtkSliceListModelLeaf <: GtkSliceListModel
            handle::Ptr{GObject}
            function GtkSliceListModelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSliceListModelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSliceListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSliceListModelLeaf, args))
            end
            w = GtkSliceListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSliceListModel] = GtkSliceListModelLeaf
        function GtkSliceListModel(args...; kwargs...)
            GtkSliceListModelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSliceListModelLeaf) = begin
                    [:handle, :offset, :size, :model]
                end
            function Base.getproperty(o::GtkSliceListModelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:offset => (:UInt32, 0, 3), :size => (:UInt32, 0, 3), :model => (:GListModel, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSliceListModelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:offset => (:UInt32, 0, 3), :size => (:UInt32, 0, 3), :model => (:GListModel, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSnapshot <: GdkSnapshot end
    end
    begin
        mutable struct GtkSnapshotLeaf <: GtkSnapshot
            handle::Ptr{GObject}
            function GtkSnapshotLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSnapshotLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSnapshotLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSnapshotLeaf, args))
            end
            w = GtkSnapshotLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSnapshot] = GtkSnapshotLeaf
        function GtkSnapshot(args...; kwargs...)
            GtkSnapshotLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSortListModel <: GObject end
    end
    begin
        mutable struct GtkSortListModelLeaf <: GtkSortListModel
            handle::Ptr{GObject}
            function GtkSortListModelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSortListModelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSortListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSortListModelLeaf, args))
            end
            w = GtkSortListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSortListModel] = GtkSortListModelLeaf
        function GtkSortListModel(args...; kwargs...)
            GtkSortListModelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSortListModelLeaf) = begin
                    [:handle, :sorter, :pending, :model, :incremental]
                end
            function Base.getproperty(o::GtkSortListModelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:sorter => (:GtkSorter, 0, 3), :pending => (:UInt32, 0, 1), :model => (:GListModel, 0, 3), :incremental => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSortListModelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:sorter => (:GtkSorter, 0, 3), :model => (:GListModel, 0, 3), :incremental => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSpinButton <: GtkWidget end
    end
    begin
        mutable struct GtkSpinButtonLeaf <: GtkSpinButton
            handle::Ptr{GObject}
            function GtkSpinButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSpinButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSpinButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSpinButtonLeaf, args))
            end
            w = GtkSpinButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSpinButton] = GtkSpinButtonLeaf
        function GtkSpinButton(args...; kwargs...)
            GtkSpinButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSpinButtonLeaf) = begin
                    [:handle, :text, :xalign, :selection_bound, :cursor_position, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :digits, :scale_factor, :visible, :numeric, :has_default, :overflow, :max_width_chars, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :climb_rate, :update_policy, :margin_bottom, :editing_canceled, :root, :css_classes, :enable_undo, :has_tooltip, :accessible_role, :snap_to_ticks, :margin_end, :editable, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :orientation, :wrap, :width_chars, :margin_start, :adjustment, :sensitive, :margin_top, :value, :has_focus]
                end
            function Base.getproperty(o::GtkSpinButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:text => (:String, 0, 3), :xalign => (:Float32, 0, 3), :selection_bound => (:Int32, 0, 1), :cursor_position => (:Int32, 0, 1), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :digits => (:UInt32, 0, 3), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :numeric => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :climb_rate => (:Float64, 0, 3), :update_policy => (:SpinButtonUpdatePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :editing_canceled => (:Bool, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :enable_undo => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :snap_to_ticks => (:Bool, 0, 3), :margin_end => (:Int32, 0, 3), :editable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :wrap => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :value => (:Float64, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSpinButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:text => (:String, 0, 3), :xalign => (:Float32, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :digits => (:UInt32, 0, 3), :visible => (:Bool, 0, 3), :numeric => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :climb_rate => (:Float64, 0, 3), :update_policy => (:SpinButtonUpdatePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :editing_canceled => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :enable_undo => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :snap_to_ticks => (:Bool, 0, 3), :margin_end => (:Int32, 0, 3), :editable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :wrap => (:Bool, 0, 3), :width_chars => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :value => (:Float64, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSpinner <: GtkWidget end
    end
    begin
        mutable struct GtkSpinnerLeaf <: GtkSpinner
            handle::Ptr{GObject}
            function GtkSpinnerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSpinnerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSpinnerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSpinnerLeaf, args))
            end
            w = GtkSpinnerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSpinner] = GtkSpinnerLeaf
        function GtkSpinner(args...; kwargs...)
            GtkSpinnerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSpinnerLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :spinning]
                end
            function Base.getproperty(o::GtkSpinnerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :spinning => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSpinnerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :spinning => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkStack <: GtkWidget end
    end
    begin
        mutable struct GtkStackLeaf <: GtkStack
            handle::Ptr{GObject}
            function GtkStackLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStackLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStackLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStackLeaf, args))
            end
            w = GtkStackLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStack] = GtkStackLeaf
        function GtkStack(args...; kwargs...)
            GtkStackLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkStackLeaf) = begin
                    [:handle, :pages, :interpolate_size, :transition_running, :vhomogeneous, :hexpand, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :hhomogeneous, :overflow, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :has_tooltip, :accessible_role, :margin_end, :transition_type, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :transition_duration, :margin_start, :visible_child_name, :sensitive, :margin_top, :visible_child, :has_focus]
                end
            function Base.getproperty(o::GtkStackLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:pages => (:GtkSelectionModel, 0, 1), :interpolate_size => (:Bool, 0, 3), :transition_running => (:Bool, 0, 1), :vhomogeneous => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :hhomogeneous => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :transition_type => (:StackTransitionType, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :transition_duration => (:UInt32, 0, 3), :margin_start => (:Int32, 0, 3), :visible_child_name => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :visible_child => (:GtkWidget, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkStackLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :interpolate_size => (:Bool, 0, 3), :hhomogeneous => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :transition_duration => (:UInt32, 0, 3), :vhomogeneous => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :transition_type => (:StackTransitionType, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :visible_child_name => (:String, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :visible_child => (:GtkWidget, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkStackPage <: GObject end
    end
    begin
        mutable struct GtkStackPageLeaf <: GtkStackPage
            handle::Ptr{GObject}
            function GtkStackPageLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStackPageLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStackPageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStackPageLeaf, args))
            end
            w = GtkStackPageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStackPage] = GtkStackPageLeaf
        function GtkStackPage(args...; kwargs...)
            GtkStackPageLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkStackPageLeaf) = begin
                    [:handle, :child, :accessible_role, :needs_attention, :name, :visible, :title, :use_underline, :icon_name]
                end
            function Base.getproperty(o::GtkStackPageLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child => (:GtkWidget, 0, 11), :accessible_role => (:AccessibleRole, 0, 3), :needs_attention => (:Bool, 0, 3), :name => (:String, 0, 3), :visible => (:Bool, 0, 3), :title => (:String, 0, 3), :use_underline => (:Bool, 0, 3), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkStackPageLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:child => (:GtkWidget, 0, 11), :accessible_role => (:AccessibleRole, 0, 3), :needs_attention => (:Bool, 0, 3), :name => (:String, 0, 3), :visible => (:Bool, 0, 3), :title => (:String, 0, 3), :use_underline => (:Bool, 0, 3), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkStackSidebar <: GtkWidget end
    end
    begin
        mutable struct GtkStackSidebarLeaf <: GtkStackSidebar
            handle::Ptr{GObject}
            function GtkStackSidebarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStackSidebarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStackSidebarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStackSidebarLeaf, args))
            end
            w = GtkStackSidebarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStackSidebar] = GtkStackSidebarLeaf
        function GtkStackSidebar(args...; kwargs...)
            GtkStackSidebarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkStackSidebarLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :stack, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkStackSidebarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :stack => (:GtkStack, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkStackSidebarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :stack => (:GtkStack, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkStackSwitcher <: GtkWidget end
    end
    begin
        mutable struct GtkStackSwitcherLeaf <: GtkStackSwitcher
            handle::Ptr{GObject}
            function GtkStackSwitcherLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStackSwitcherLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStackSwitcherLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStackSwitcherLeaf, args))
            end
            w = GtkStackSwitcherLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStackSwitcher] = GtkStackSwitcherLeaf
        function GtkStackSwitcher(args...; kwargs...)
            GtkStackSwitcherLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkStackSwitcherLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :stack, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkStackSwitcherLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :stack => (:GtkStack, 0, 7), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkStackSwitcherLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :stack => (:GtkStack, 0, 7), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkStatusbar <: GtkWidget end
    end
    begin
        mutable struct GtkStatusbarLeaf <: GtkStatusbar
            handle::Ptr{GObject}
            function GtkStatusbarLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStatusbarLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStatusbarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStatusbarLeaf, args))
            end
            w = GtkStatusbarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStatusbar] = GtkStatusbarLeaf
        function GtkStatusbar(args...; kwargs...)
            GtkStatusbarLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkStatusbarLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkStatusbarLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkStatusbarLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkStringFilter <: GtkFilter end
    end
    begin
        mutable struct GtkStringFilterLeaf <: GtkStringFilter
            handle::Ptr{GObject}
            function GtkStringFilterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStringFilterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStringFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStringFilterLeaf, args))
            end
            w = GtkStringFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStringFilter] = GtkStringFilterLeaf
        function GtkStringFilter(args...; kwargs...)
            GtkStringFilterLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkStringFilterLeaf) = begin
                    [:handle, :ignore_case, :search, :expression, :match_mode]
                end
            function Base.getproperty(o::GtkStringFilterLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:ignore_case => (:Bool, 0, 3), :search => (:String, 0, 3), :expression => (:GtkExpression, 0, 3), :match_mode => (:StringFilterMatchMode, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkStringFilterLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:ignore_case => (:Bool, 0, 3), :search => (:String, 0, 3), :expression => (:GtkExpression, 0, 3), :match_mode => (:StringFilterMatchMode, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkStringList <: GObject end
    end
    begin
        mutable struct GtkStringListLeaf <: GtkStringList
            handle::Ptr{GObject}
            function GtkStringListLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStringListLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStringListLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStringListLeaf, args))
            end
            w = GtkStringListLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStringList] = GtkStringListLeaf
        function GtkStringList(args...; kwargs...)
            GtkStringListLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStringObject <: GObject end
    end
    begin
        mutable struct GtkStringObjectLeaf <: GtkStringObject
            handle::Ptr{GObject}
            function GtkStringObjectLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStringObjectLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStringObjectLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStringObjectLeaf, args))
            end
            w = GtkStringObjectLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStringObject] = GtkStringObjectLeaf
        function GtkStringObject(args...; kwargs...)
            GtkStringObjectLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkStringObjectLeaf) = begin
                    [:handle, :string]
                end
            function Base.getproperty(o::GtkStringObjectLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:string => (:String, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkStringObjectLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkStringSorter <: GtkSorter end
    end
    begin
        mutable struct GtkStringSorterLeaf <: GtkStringSorter
            handle::Ptr{GObject}
            function GtkStringSorterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStringSorterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStringSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStringSorterLeaf, args))
            end
            w = GtkStringSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStringSorter] = GtkStringSorterLeaf
        function GtkStringSorter(args...; kwargs...)
            GtkStringSorterLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkStringSorterLeaf) = begin
                    [:handle, :ignore_case, :expression]
                end
            function Base.getproperty(o::GtkStringSorterLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:ignore_case => (:Bool, 0, 3), :expression => (:GtkExpression, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkStringSorterLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:ignore_case => (:Bool, 0, 3), :expression => (:GtkExpression, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkStyleContext <: GObject end
    end
    begin
        mutable struct GtkStyleContextLeaf <: GtkStyleContext
            handle::Ptr{GObject}
            function GtkStyleContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkStyleContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStyleContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStyleContextLeaf, args))
            end
            w = GtkStyleContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStyleContext] = GtkStyleContextLeaf
        function GtkStyleContext(args...; kwargs...)
            GtkStyleContextLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkStyleContextLeaf) = begin
                    [:handle, :display]
                end
            function Base.getproperty(o::GtkStyleContextLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:display => (:GdkDisplay, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkStyleContextLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:display => (:GdkDisplay, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkSwitch <: GtkWidget end
    end
    begin
        mutable struct GtkSwitchLeaf <: GtkSwitch
            handle::Ptr{GObject}
            function GtkSwitchLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkSwitchLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSwitchLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSwitchLeaf, args))
            end
            w = GtkSwitchLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSwitch] = GtkSwitchLeaf
        function GtkSwitch(args...; kwargs...)
            GtkSwitchLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkSwitchLeaf) = begin
                    [:handle, :action_target, :css_classes, :active, :visible, :state, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :action_name, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkSwitchLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_target => (:GVariant, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :active => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :state => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkSwitchLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:action_target => (:GVariant, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :active => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :state => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkText <: GtkWidget end
    end
    begin
        mutable struct GtkTextLeaf <: GtkText
            handle::Ptr{GObject}
            function GtkTextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextLeaf, args))
            end
            w = GtkTextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkText] = GtkTextLeaf
        function GtkText(args...; kwargs...)
            GtkTextLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTextLeaf) = begin
                    [:handle, :placeholder_text, :text, :xalign, :selection_bound, :cursor_position, :extra_menu, :hexpand, :tabs, :halign, :name, :opacity, :layout_manager, :focus_on_click, :enable_emoji_completion, :vexpand, :can_target, :css_name, :invisible_char_set, :scale_factor, :activates_default, :visible, :has_default, :buffer, :overflow, :visibility, :max_width_chars, :receives_default, :attributes, :tooltip_text, :can_focus, :input_purpose, :height_request, :hexpand_set, :margin_bottom, :root, :css_classes, :enable_undo, :has_tooltip, :accessible_role, :margin_end, :scroll_offset, :truncate_multiline, :overwrite_mode, :editable, :width_request, :cursor, :tooltip_markup, :im_module, :parent, :focusable, :valign, :vexpand_set, :invisible_char, :width_chars, :margin_start, :input_hints, :max_length, :sensitive, :propagate_text_width, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkTextLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :text => (:String, 0, 3), :xalign => (:Float32, 0, 3), :selection_bound => (:Int32, 0, 1), :cursor_position => (:Int32, 0, 1), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :tabs => (:PangoTabArray, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :enable_emoji_completion => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :invisible_char_set => (:Bool, 0, 3), :scale_factor => (:Int32, 0, 1), :activates_default => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :buffer => (:GtkEntryBuffer, 0, 7), :overflow => (:Overflow, 0, 3), :visibility => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :attributes => (:PangoAttrList, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :input_purpose => (:InputPurpose, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :enable_undo => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :scroll_offset => (:Int32, 0, 1), :truncate_multiline => (:Bool, 0, 3), :overwrite_mode => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :im_module => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :invisible_char => (:UInt32, 0, 3), :width_chars => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :input_hints => (:Int32, 0, 3), :max_length => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :propagate_text_width => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTextLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:placeholder_text => (:String, 0, 3), :text => (:String, 0, 3), :xalign => (:Float32, 0, 3), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :tabs => (:PangoTabArray, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :enable_emoji_completion => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :invisible_char_set => (:Bool, 0, 3), :activates_default => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :buffer => (:GtkEntryBuffer, 0, 7), :overflow => (:Overflow, 0, 3), :visibility => (:Bool, 0, 3), :max_width_chars => (:Int32, 0, 3), :receives_default => (:Bool, 0, 3), :attributes => (:PangoAttrList, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :input_purpose => (:InputPurpose, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :enable_undo => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :truncate_multiline => (:Bool, 0, 3), :overwrite_mode => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :im_module => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :invisible_char => (:UInt32, 0, 3), :width_chars => (:Int32, 0, 3), :margin_start => (:Int32, 0, 3), :input_hints => (:Int32, 0, 3), :max_length => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :propagate_text_width => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTextBuffer <: GObject end
    end
    begin
        mutable struct GtkTextBufferLeaf <: GtkTextBuffer
            handle::Ptr{GObject}
            function GtkTextBufferLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTextBufferLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextBufferLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextBufferLeaf, args))
            end
            w = GtkTextBufferLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextBuffer] = GtkTextBufferLeaf
        function GtkTextBuffer(args...; kwargs...)
            GtkTextBufferLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTextBufferLeaf) = begin
                    [:handle, :can_redo, :enable_undo, :has_selection, :tag_table, :text, :cursor_position, :can_undo]
                end
            function Base.getproperty(o::GtkTextBufferLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:can_undo => (:Bool, 0, 1), :enable_undo => (:Bool, 0, 3), :has_selection => (:Bool, 0, 1), :tag_table => (:GtkTextTagTable, 0, 11), :text => (:String, 0, 3), :cursor_position => (:Int32, 0, 1), :can_redo => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTextBufferLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:enable_undo => (:Bool, 0, 3), :tag_table => (:GtkTextTagTable, 0, 11), :text => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTextChildAnchor <: GObject end
    end
    begin
        mutable struct GtkTextChildAnchorLeaf <: GtkTextChildAnchor
            handle::Ptr{GObject}
            function GtkTextChildAnchorLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTextChildAnchorLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextChildAnchorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextChildAnchorLeaf, args))
            end
            w = GtkTextChildAnchorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextChildAnchor] = GtkTextChildAnchorLeaf
        function GtkTextChildAnchor(args...; kwargs...)
            GtkTextChildAnchorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTextMark <: GObject end
    end
    begin
        mutable struct GtkTextMarkLeaf <: GtkTextMark
            handle::Ptr{GObject}
            function GtkTextMarkLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTextMarkLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextMarkLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextMarkLeaf, args))
            end
            w = GtkTextMarkLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextMark] = GtkTextMarkLeaf
        function GtkTextMark(args...; kwargs...)
            GtkTextMarkLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTextMarkLeaf) = begin
                    [:handle, :left_gravity, :name]
                end
            function Base.getproperty(o::GtkTextMarkLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:left_gravity => (:Bool, 0, 11), :name => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTextMarkLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:left_gravity => (:Bool, 0, 11), :name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTextTag <: GObject end
    end
    begin
        mutable struct GtkTextTagLeaf <: GtkTextTag
            handle::Ptr{GObject}
            function GtkTextTagLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTextTagLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextTagLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextTagLeaf, args))
            end
            w = GtkTextTagLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextTag] = GtkTextTagLeaf
        function GtkTextTag(args...; kwargs...)
            GtkTextTagLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTextTagLeaf) = begin
                    [:handle, :overline_set, :foreground, :pixels_inside_wrap_set, :underline_rgba, :accumulative_margin, :size_set, :left_margin, :fallback_set, :justification_set, :strikethrough_set, :style_set, :stretch, :tabs, :indent_set, :name, :background_rgba, :background, :foreground_rgba, :show_spaces, :underline_set, :letter_spacing, :left_margin_set, :scale_set, :paragraph_background_rgba, :fallback, :allow_breaks, :pixels_inside_wrap, :scale, :stretch_set, :variant_set, :style, :strikethrough_rgba, :strikethrough, :background_set, :insert_hyphens, :pixels_below_lines, :invisible, :right_margin_set, :underline_rgba_set, :justification, :invisible_set, :indent, :font_desc, :strikethrough_rgba_set, :wrap_mode_set, :overline_rgba_set, :editable, :pixels_below_lines_set, :editable_set, :show_spaces_set, :font_features_set, :font_features, :language, :direction, :wrap_mode, :family_set, :insert_hyphens_set, :rise, :paragraph_background_set, :pixels_above_lines, :background_full_height_set, :weight, :weight_set, :size, :allow_breaks_set, :rise_set, :paragraph_background, :letter_spacing_set, :size_points, :foreground_set, :font, :language_set, :variant, :overline_rgba, :pixels_above_lines_set, :background_full_height, :overline, :right_margin, :family, :underline, :tabs_set]
                end
            function Base.getproperty(o::GtkTextTagLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:overline_set => (:Bool, 0, 3), :pixels_inside_wrap_set => (:Bool, 0, 3), :underline_rgba => (:GdkRGBA, 0, 3), :accumulative_margin => (:Bool, 0, 3), :size_set => (:Bool, 0, 3), :left_margin => (:Int32, 0, 3), :fallback_set => (:Bool, 0, 3), :justification_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :tabs => (:PangoTabArray, 0, 3), :indent_set => (:Bool, 0, 3), :name => (:String, 0, 11), :background_rgba => (:GdkRGBA, 0, 3), :show_spaces => (:Int32, 0, 3), :foreground_rgba => (:GdkRGBA, 0, 3), :underline_set => (:Bool, 0, 3), :letter_spacing => (:Int32, 0, 3), :left_margin_set => (:Bool, 0, 3), :scale_set => (:Bool, 0, 3), :paragraph_background_rgba => (:GdkRGBA, 0, 3), :fallback => (:Bool, 0, 3), :allow_breaks => (:Bool, 0, 3), :pixels_inside_wrap => (:Int32, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :style => (:Style, 0, 3), :strikethrough_rgba => (:GdkRGBA, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :insert_hyphens => (:Bool, 0, 3), :pixels_below_lines => (:Int32, 0, 3), :invisible => (:Bool, 0, 3), :right_margin_set => (:Bool, 0, 3), :underline_rgba_set => (:Bool, 0, 3), :justification => (:Justification, 0, 3), :invisible_set => (:Bool, 0, 3), :indent => (:Int32, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :strikethrough_rgba_set => (:Bool, 0, 3), :wrap_mode_set => (:Bool, 0, 3), :overline_rgba_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :pixels_below_lines_set => (:Bool, 0, 3), :editable_set => (:Bool, 0, 3), :show_spaces_set => (:Bool, 0, 3), :font_features_set => (:Bool, 0, 3), :font_features => (:String, 0, 3), :language => (:String, 0, 3), :direction => (:TextDirection, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :family_set => (:Bool, 0, 3), :insert_hyphens_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :paragraph_background_set => (:Bool, 0, 3), :pixels_above_lines => (:Int32, 0, 3), :background_full_height_set => (:Bool, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :allow_breaks_set => (:Bool, 0, 3), :rise_set => (:Bool, 0, 3), :letter_spacing_set => (:Bool, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :overline_rgba => (:GdkRGBA, 0, 3), :pixels_above_lines_set => (:Bool, 0, 3), :background_full_height => (:Bool, 0, 3), :overline => (:Overline, 0, 3), :right_margin => (:Int32, 0, 3), :family => (:String, 0, 3), :underline => (:Underline, 0, 3), :tabs_set => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTextTagLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:overline_set => (:Bool, 0, 3), :foreground => (:String, 0, 2), :pixels_inside_wrap_set => (:Bool, 0, 3), :underline_rgba => (:GdkRGBA, 0, 3), :accumulative_margin => (:Bool, 0, 3), :size_set => (:Bool, 0, 3), :left_margin => (:Int32, 0, 3), :fallback_set => (:Bool, 0, 3), :justification_set => (:Bool, 0, 3), :strikethrough_set => (:Bool, 0, 3), :style_set => (:Bool, 0, 3), :stretch => (:Stretch, 0, 3), :tabs => (:PangoTabArray, 0, 3), :indent_set => (:Bool, 0, 3), :name => (:String, 0, 11), :background_rgba => (:GdkRGBA, 0, 3), :background => (:String, 0, 2), :foreground_rgba => (:GdkRGBA, 0, 3), :show_spaces => (:Int32, 0, 3), :underline_set => (:Bool, 0, 3), :letter_spacing => (:Int32, 0, 3), :left_margin_set => (:Bool, 0, 3), :scale_set => (:Bool, 0, 3), :paragraph_background_rgba => (:GdkRGBA, 0, 3), :fallback => (:Bool, 0, 3), :allow_breaks => (:Bool, 0, 3), :pixels_inside_wrap => (:Int32, 0, 3), :scale => (:Float64, 0, 3), :stretch_set => (:Bool, 0, 3), :variant_set => (:Bool, 0, 3), :style => (:Style, 0, 3), :strikethrough_rgba => (:GdkRGBA, 0, 3), :strikethrough => (:Bool, 0, 3), :background_set => (:Bool, 0, 3), :insert_hyphens => (:Bool, 0, 3), :pixels_below_lines => (:Int32, 0, 3), :invisible => (:Bool, 0, 3), :right_margin_set => (:Bool, 0, 3), :underline_rgba_set => (:Bool, 0, 3), :justification => (:Justification, 0, 3), :invisible_set => (:Bool, 0, 3), :indent => (:Int32, 0, 3), :font_desc => (:PangoFontDescription, 0, 3), :strikethrough_rgba_set => (:Bool, 0, 3), :wrap_mode_set => (:Bool, 0, 3), :overline_rgba_set => (:Bool, 0, 3), :editable => (:Bool, 0, 3), :pixels_below_lines_set => (:Bool, 0, 3), :editable_set => (:Bool, 0, 3), :show_spaces_set => (:Bool, 0, 3), :font_features_set => (:Bool, 0, 3), :font_features => (:String, 0, 3), :language => (:String, 0, 3), :direction => (:TextDirection, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :family_set => (:Bool, 0, 3), :insert_hyphens_set => (:Bool, 0, 3), :rise => (:Int32, 0, 3), :paragraph_background_set => (:Bool, 0, 3), :pixels_above_lines => (:Int32, 0, 3), :background_full_height_set => (:Bool, 0, 3), :weight => (:Int32, 0, 3), :weight_set => (:Bool, 0, 3), :size => (:Int32, 0, 3), :allow_breaks_set => (:Bool, 0, 3), :rise_set => (:Bool, 0, 3), :paragraph_background => (:String, 0, 2), :letter_spacing_set => (:Bool, 0, 3), :size_points => (:Float64, 0, 3), :foreground_set => (:Bool, 0, 3), :font => (:String, 0, 3), :language_set => (:Bool, 0, 3), :variant => (:Variant, 0, 3), :overline_rgba => (:GdkRGBA, 0, 3), :pixels_above_lines_set => (:Bool, 0, 3), :background_full_height => (:Bool, 0, 3), :overline => (:Overline, 0, 3), :right_margin => (:Int32, 0, 3), :family => (:String, 0, 3), :underline => (:Underline, 0, 3), :tabs_set => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTextTagTable <: GObject end
    end
    begin
        mutable struct GtkTextTagTableLeaf <: GtkTextTagTable
            handle::Ptr{GObject}
            function GtkTextTagTableLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTextTagTableLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextTagTableLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextTagTableLeaf, args))
            end
            w = GtkTextTagTableLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextTagTable] = GtkTextTagTableLeaf
        function GtkTextTagTable(args...; kwargs...)
            GtkTextTagTableLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTextView <: GtkWidget end
    end
    begin
        mutable struct GtkTextViewLeaf <: GtkTextView
            handle::Ptr{GObject}
            function GtkTextViewLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTextViewLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextViewLeaf, args))
            end
            w = GtkTextViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextView] = GtkTextViewLeaf
        function GtkTextView(args...; kwargs...)
            GtkTextViewLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTextViewLeaf) = begin
                    [:handle, :top_margin, :left_margin, :hscroll_policy, :extra_menu, :hexpand, :tabs, :halign, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :bottom_margin, :pixels_inside_wrap, :visible, :has_default, :hadjustment, :accepts_tab, :buffer, :overflow, :receives_default, :tooltip_text, :can_focus, :input_purpose, :height_request, :hexpand_set, :vscroll_policy, :margin_bottom, :root, :pixels_below_lines, :css_classes, :has_tooltip, :justification, :accessible_role, :indent, :margin_end, :editable, :vadjustment, :monospace, :width_request, :cursor, :tooltip_markup, :im_module, :parent, :wrap_mode, :pixels_above_lines, :focusable, :valign, :vexpand_set, :cursor_visible, :overwrite, :margin_start, :input_hints, :sensitive, :margin_top, :right_margin, :has_focus]
                end
            function Base.getproperty(o::GtkTextViewLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:top_margin => (:Int32, 0, 3), :left_margin => (:Int32, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :tabs => (:PangoTabArray, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :bottom_margin => (:Int32, 0, 3), :pixels_inside_wrap => (:Int32, 0, 3), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :hadjustment => (:GtkAdjustment, 0, 7), :accepts_tab => (:Bool, 0, 3), :buffer => (:GtkTextBuffer, 0, 3), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :input_purpose => (:InputPurpose, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :pixels_below_lines => (:Int32, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :justification => (:Justification, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :indent => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :editable => (:Bool, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :monospace => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :im_module => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :wrap_mode => (:WrapMode, 0, 3), :pixels_above_lines => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :cursor_visible => (:Bool, 0, 3), :overwrite => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :input_hints => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :right_margin => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTextViewLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:top_margin => (:Int32, 0, 3), :left_margin => (:Int32, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :extra_menu => (:GMenuModel, 0, 3), :hexpand => (:Bool, 0, 3), :tabs => (:PangoTabArray, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :bottom_margin => (:Int32, 0, 3), :pixels_inside_wrap => (:Int32, 0, 3), :visible => (:Bool, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :accepts_tab => (:Bool, 0, 3), :buffer => (:GtkTextBuffer, 0, 3), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :input_purpose => (:InputPurpose, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :pixels_below_lines => (:Int32, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :has_tooltip => (:Bool, 0, 3), :justification => (:Justification, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :indent => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :editable => (:Bool, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :monospace => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :im_module => (:String, 0, 3), :wrap_mode => (:WrapMode, 0, 3), :pixels_above_lines => (:Int32, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :cursor_visible => (:Bool, 0, 3), :overwrite => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :input_hints => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :right_margin => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkToggleButton <: GtkButton end
    end
    begin
        mutable struct GtkToggleButtonLeaf <: GtkToggleButton
            handle::Ptr{GObject}
            function GtkToggleButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkToggleButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkToggleButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkToggleButtonLeaf, args))
            end
            w = GtkToggleButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkToggleButton] = GtkToggleButtonLeaf
        function GtkToggleButton(args...; kwargs...)
            GtkToggleButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkToggleButtonLeaf) = begin
                    [:handle, :group, :hexpand, :halign, :name, :opacity, :layout_manager, :child, :focus_on_click, :vexpand, :can_target, :css_name, :scale_factor, :visible, :has_default, :overflow, :receives_default, :tooltip_text, :can_focus, :height_request, :hexpand_set, :margin_bottom, :root, :has_frame, :icon_name, :css_classes, :use_underline, :has_tooltip, :accessible_role, :margin_end, :action_name, :width_request, :cursor, :tooltip_markup, :parent, :action_target, :active, :label, :focusable, :valign, :vexpand_set, :margin_start, :sensitive, :margin_top, :has_focus]
                end
            function Base.getproperty(o::GtkToggleButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :has_frame => (:Bool, 0, 3), :icon_name => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :action_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :action_target => (:GVariant, 0, 3), :active => (:Bool, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkToggleButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:group => (:GtkToggleButton, 0, 2), :action_target => (:GVariant, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :active => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :label => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :use_underline => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :height_request => (:Int32, 0, 3), :hexpand_set => (:Bool, 0, 3), :action_name => (:String, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :sensitive => (:Bool, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :vexpand => (:Bool, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :margin_top => (:Int32, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :has_frame => (:Bool, 0, 3), :icon_name => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTooltip <: GObject end
    end
    begin
        mutable struct GtkTooltipLeaf <: GtkTooltip
            handle::Ptr{GObject}
            function GtkTooltipLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTooltipLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTooltipLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTooltipLeaf, args))
            end
            w = GtkTooltipLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTooltip] = GtkTooltipLeaf
        function GtkTooltip(args...; kwargs...)
            GtkTooltipLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeExpander <: GtkWidget end
    end
    begin
        mutable struct GtkTreeExpanderLeaf <: GtkTreeExpander
            handle::Ptr{GObject}
            function GtkTreeExpanderLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeExpanderLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeExpanderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeExpanderLeaf, args))
            end
            w = GtkTreeExpanderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeExpander] = GtkTreeExpanderLeaf
        function GtkTreeExpander(args...; kwargs...)
            GtkTreeExpanderLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTreeExpanderLeaf) = begin
                    [:handle, :item, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :list_row, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkTreeExpanderLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:item => (:GObject, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :list_row => (:GtkTreeListRow, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTreeExpanderLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :list_row => (:GtkTreeListRow, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTreeListModel <: GObject end
    end
    begin
        mutable struct GtkTreeListModelLeaf <: GtkTreeListModel
            handle::Ptr{GObject}
            function GtkTreeListModelLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeListModelLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeListModelLeaf, args))
            end
            w = GtkTreeListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeListModel] = GtkTreeListModelLeaf
        function GtkTreeListModel(args...; kwargs...)
            GtkTreeListModelLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTreeListModelLeaf) = begin
                    [:handle, :passthrough, :autoexpand, :model]
                end
            function Base.getproperty(o::GtkTreeListModelLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:passthrough => (:Bool, 0, 11), :autoexpand => (:Bool, 0, 3), :model => (:GListModel, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTreeListModelLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:passthrough => (:Bool, 0, 11), :autoexpand => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTreeListRow <: GObject end
    end
    begin
        mutable struct GtkTreeListRowLeaf <: GtkTreeListRow
            handle::Ptr{GObject}
            function GtkTreeListRowLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeListRowLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeListRowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeListRowLeaf, args))
            end
            w = GtkTreeListRowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeListRow] = GtkTreeListRowLeaf
        function GtkTreeListRow(args...; kwargs...)
            GtkTreeListRowLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTreeListRowLeaf) = begin
                    [:handle, :expanded, :item, :children, :expandable, :depth]
                end
            function Base.getproperty(o::GtkTreeListRowLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:expanded => (:Bool, 0, 3), :item => (:GObject, 0, 1), :children => (:GListModel, 0, 1), :expandable => (:Bool, 0, 1), :depth => (:UInt32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTreeListRowLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:expanded => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTreeListRowSorter <: GtkSorter end
    end
    begin
        mutable struct GtkTreeListRowSorterLeaf <: GtkTreeListRowSorter
            handle::Ptr{GObject}
            function GtkTreeListRowSorterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeListRowSorterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeListRowSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeListRowSorterLeaf, args))
            end
            w = GtkTreeListRowSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeListRowSorter] = GtkTreeListRowSorterLeaf
        function GtkTreeListRowSorter(args...; kwargs...)
            GtkTreeListRowSorterLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTreeListRowSorterLeaf) = begin
                    [:handle, :sorter]
                end
            function Base.getproperty(o::GtkTreeListRowSorterLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:sorter => (:GtkSorter, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTreeListRowSorterLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:sorter => (:GtkSorter, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTreeModelFilter <: GObject end
    end
    begin
        mutable struct GtkTreeModelFilterLeaf <: GtkTreeModelFilter
            handle::Ptr{GObject}
            function GtkTreeModelFilterLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeModelFilterLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeModelFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeModelFilterLeaf, args))
            end
            w = GtkTreeModelFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeModelFilter] = GtkTreeModelFilterLeaf
        function GtkTreeModelFilter(args...; kwargs...)
            GtkTreeModelFilterLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTreeModelFilterLeaf) = begin
                    [:handle, :virtual_root, :child_model]
                end
            function Base.getproperty(o::GtkTreeModelFilterLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:virtual_root => (:GtkTreePath, 0, 11), :child_model => (:GtkTreeModel, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTreeModelFilterLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:virtual_root => (:GtkTreePath, 0, 11), :child_model => (:GtkTreeModel, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTreeModelSort <: GObject end
    end
    begin
        mutable struct GtkTreeModelSortLeaf <: GtkTreeModelSort
            handle::Ptr{GObject}
            function GtkTreeModelSortLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeModelSortLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeModelSortLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeModelSortLeaf, args))
            end
            w = GtkTreeModelSortLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeModelSort] = GtkTreeModelSortLeaf
        function GtkTreeModelSort(args...; kwargs...)
            GtkTreeModelSortLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTreeModelSortLeaf) = begin
                    [:handle, :model]
                end
            function Base.getproperty(o::GtkTreeModelSortLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GtkTreeModel, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTreeModelSortLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:model => (:GtkTreeModel, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTreeSelection <: GObject end
    end
    begin
        mutable struct GtkTreeSelectionLeaf <: GtkTreeSelection
            handle::Ptr{GObject}
            function GtkTreeSelectionLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeSelectionLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeSelectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeSelectionLeaf, args))
            end
            w = GtkTreeSelectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeSelection] = GtkTreeSelectionLeaf
        function GtkTreeSelection(args...; kwargs...)
            GtkTreeSelectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTreeSelectionLeaf) = begin
                    [:handle, :mode]
                end
            function Base.getproperty(o::GtkTreeSelectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:mode => (:SelectionMode, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTreeSelectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:mode => (:SelectionMode, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTreeStore <: GObject end
    end
    begin
        mutable struct GtkTreeStoreLeaf <: GtkTreeStore
            handle::Ptr{GObject}
            function GtkTreeStoreLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeStoreLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeStoreLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeStoreLeaf, args))
            end
            w = GtkTreeStoreLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeStore] = GtkTreeStoreLeaf
        function GtkTreeStore(args...; kwargs...)
            GtkTreeStoreLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeView <: GtkWidget end
    end
    begin
        mutable struct GtkTreeViewLeaf <: GtkTreeView
            handle::Ptr{GObject}
            function GtkTreeViewLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeViewLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeViewLeaf, args))
            end
            w = GtkTreeViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeView] = GtkTreeViewLeaf
        function GtkTreeView(args...; kwargs...)
            GtkTreeViewLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTreeViewLeaf) = begin
                    [:handle, :headers_visible, :tooltip_column, :search_column, :hscroll_policy, :rubber_banding, :hexpand, :halign, :activate_on_single_click, :name, :opacity, :layout_manager, :focus_on_click, :vexpand, :expander_column, :can_target, :css_name, :scale_factor, :visible, :has_default, :hadjustment, :overflow, :receives_default, :tooltip_text, :can_focus, :height_request, :enable_grid_lines, :hexpand_set, :fixed_height_mode, :vscroll_policy, :margin_bottom, :root, :hover_selection, :css_classes, :level_indentation, :has_tooltip, :accessible_role, :margin_end, :headers_clickable, :show_expanders, :vadjustment, :model, :enable_search, :width_request, :cursor, :tooltip_markup, :parent, :focusable, :valign, :vexpand_set, :hover_expand, :margin_start, :reorderable, :sensitive, :margin_top, :has_focus, :enable_tree_lines]
                end
            function Base.getproperty(o::GtkTreeViewLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:headers_visible => (:Bool, 0, 3), :tooltip_column => (:Int32, 0, 3), :search_column => (:Int32, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :rubber_banding => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :activate_on_single_click => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :expander_column => (:GtkTreeViewColumn, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1), :visible => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :hadjustment => (:GtkAdjustment, 0, 7), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :enable_grid_lines => (:TreeViewGridLines, 0, 3), :hexpand_set => (:Bool, 0, 3), :fixed_height_mode => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :root => (:GtkRoot, 0, 1), :hover_selection => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :level_indentation => (:Int32, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :headers_clickable => (:Bool, 0, 3), :show_expanders => (:Bool, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :model => (:GtkTreeModel, 0, 3), :enable_search => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :parent => (:GtkWidget, 0, 1), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :hover_expand => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :reorderable => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :has_focus => (:Bool, 0, 1), :enable_tree_lines => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTreeViewLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:headers_visible => (:Bool, 0, 3), :tooltip_column => (:Int32, 0, 3), :search_column => (:Int32, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :rubber_banding => (:Bool, 0, 3), :hexpand => (:Bool, 0, 3), :halign => (:Align, 0, 3), :activate_on_single_click => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :focus_on_click => (:Bool, 0, 3), :vexpand => (:Bool, 0, 3), :expander_column => (:GtkTreeViewColumn, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :visible => (:Bool, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :overflow => (:Overflow, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :can_focus => (:Bool, 0, 3), :height_request => (:Int32, 0, 3), :enable_grid_lines => (:TreeViewGridLines, 0, 3), :hexpand_set => (:Bool, 0, 3), :fixed_height_mode => (:Bool, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :hover_selection => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :level_indentation => (:Int32, 0, 3), :has_tooltip => (:Bool, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_end => (:Int32, 0, 3), :headers_clickable => (:Bool, 0, 3), :show_expanders => (:Bool, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :model => (:GtkTreeModel, 0, 3), :enable_search => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :cursor => (:GdkCursor, 0, 3), :tooltip_markup => (:String, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :hover_expand => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :reorderable => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :margin_top => (:Int32, 0, 3), :enable_tree_lines => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkTreeViewColumn <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkTreeViewColumnLeaf <: GtkTreeViewColumn
            handle::Ptr{GObject}
            function GtkTreeViewColumnLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkTreeViewColumnLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeViewColumnLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeViewColumnLeaf, args))
            end
            w = GtkTreeViewColumnLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeViewColumn] = GtkTreeViewColumnLeaf
        function GtkTreeViewColumn(args...; kwargs...)
            GtkTreeViewColumnLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkTreeViewColumnLeaf) = begin
                    [:handle, :clickable, :visible, :spacing, :resizable, :min_width, :sort_order, :sort_indicator, :widget, :title, :max_width, :sort_column_id, :sizing, :expand, :cell_area, :reorderable, :x_offset, :alignment, :fixed_width, :width]
                end
            function Base.getproperty(o::GtkTreeViewColumnLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:clickable => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :spacing => (:Int32, 0, 3), :resizable => (:Bool, 0, 3), :min_width => (:Int32, 0, 3), :sort_order => (:SortType, 0, 3), :sort_indicator => (:Bool, 0, 3), :widget => (:GtkWidget, 0, 3), :title => (:String, 0, 3), :max_width => (:Int32, 0, 3), :sort_column_id => (:Int32, 0, 3), :sizing => (:TreeViewColumnSizing, 0, 3), :expand => (:Bool, 0, 3), :cell_area => (:GtkCellArea, 0, 11), :reorderable => (:Bool, 0, 3), :x_offset => (:Int32, 0, 1), :alignment => (:Float32, 0, 3), :fixed_width => (:Int32, 0, 3), :width => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkTreeViewColumnLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:clickable => (:Bool, 0, 3), :visible => (:Bool, 0, 3), :spacing => (:Int32, 0, 3), :resizable => (:Bool, 0, 3), :min_width => (:Int32, 0, 3), :sort_order => (:SortType, 0, 3), :sort_indicator => (:Bool, 0, 3), :widget => (:GtkWidget, 0, 3), :title => (:String, 0, 3), :max_width => (:Int32, 0, 3), :sort_column_id => (:Int32, 0, 3), :sizing => (:TreeViewColumnSizing, 0, 3), :expand => (:Bool, 0, 3), :cell_area => (:GtkCellArea, 0, 11), :reorderable => (:Bool, 0, 3), :alignment => (:Float32, 0, 3), :fixed_width => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkVideo <: GtkWidget end
    end
    begin
        mutable struct GtkVideoLeaf <: GtkVideo
            handle::Ptr{GObject}
            function GtkVideoLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkVideoLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkVideoLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkVideoLeaf, args))
            end
            w = GtkVideoLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkVideo] = GtkVideoLeaf
        function GtkVideo(args...; kwargs...)
            GtkVideoLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkVideoLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :media_stream, :autoplay, :has_tooltip, :overflow, :file, :accessible_role, :loop, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkVideoLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :media_stream => (:GtkMediaStream, 0, 3), :autoplay => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :file => (:GFile, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :loop => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkVideoLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :media_stream => (:GtkMediaStream, 0, 3), :autoplay => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :file => (:GFile, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :loop => (:Bool, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkViewport <: GtkWidget end
    end
    begin
        mutable struct GtkViewportLeaf <: GtkViewport
            handle::Ptr{GObject}
            function GtkViewportLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkViewportLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkViewportLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkViewportLeaf, args))
            end
            w = GtkViewportLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkViewport] = GtkViewportLeaf
        function GtkViewport(args...; kwargs...)
            GtkViewportLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkViewportLeaf) = begin
                    [:handle, :scroll_to_focus, :css_classes, :visible, :focusable, :has_default, :valign, :hadjustment, :vexpand_set, :has_tooltip, :overflow, :hscroll_policy, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :vadjustment, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :vscroll_policy, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkViewportLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scroll_to_focus => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkViewportLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scroll_to_focus => (:Bool, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :hadjustment => (:GtkAdjustment, 0, 7), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :hscroll_policy => (:ScrollablePolicy, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :vadjustment => (:GtkAdjustment, 0, 7), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :vscroll_policy => (:ScrollablePolicy, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkVolumeButton <: GtkScaleButton end
    end
    begin
        mutable struct GtkVolumeButtonLeaf <: GtkVolumeButton
            handle::Ptr{GObject}
            function GtkVolumeButtonLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkVolumeButtonLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkVolumeButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkVolumeButtonLeaf, args))
            end
            w = GtkVolumeButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkVolumeButton] = GtkVolumeButtonLeaf
        function GtkVolumeButton(args...; kwargs...)
            GtkVolumeButtonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkVolumeButtonLeaf) = begin
                    [:handle, :has_focus, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :orientation, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :adjustment, :hexpand, :icons, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :value, :use_symbolic, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :root, :margin_bottom, :vexpand, :can_target, :css_name, :scale_factor, :parent]
                end
            function Base.getproperty(o::GtkVolumeButtonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:parent => (:GtkWidget, 0, 1), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 3), :hexpand => (:Bool, 0, 3), :icons => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :value => (:Float64, 0, 3), :use_symbolic => (:Bool, 0, 7), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :root => (:GtkRoot, 0, 1), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :has_focus => (:Bool, 0, 1), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkVolumeButtonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :orientation => (:Orientation, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :adjustment => (:GtkAdjustment, 0, 3), :hexpand => (:Bool, 0, 3), :icons => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :value => (:Float64, 0, 3), :use_symbolic => (:Bool, 0, 7), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkWidgetPaintable <: GObject end
    end
    begin
        mutable struct GtkWidgetPaintableLeaf <: GtkWidgetPaintable
            handle::Ptr{GObject}
            function GtkWidgetPaintableLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkWidgetPaintableLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWidgetPaintableLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWidgetPaintableLeaf, args))
            end
            w = GtkWidgetPaintableLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWidgetPaintable] = GtkWidgetPaintableLeaf
        function GtkWidgetPaintable(args...; kwargs...)
            GtkWidgetPaintableLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkWidgetPaintableLeaf) = begin
                    [:handle, :widget]
                end
            function Base.getproperty(o::GtkWidgetPaintableLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:widget => (:GtkWidget, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkWidgetPaintableLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:widget => (:GtkWidget, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkWindowControls <: GtkWidget end
    end
    begin
        mutable struct GtkWindowControlsLeaf <: GtkWindowControls
            handle::Ptr{GObject}
            function GtkWindowControlsLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkWindowControlsLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWindowControlsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWindowControlsLeaf, args))
            end
            w = GtkWindowControlsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWindowControls] = GtkWindowControlsLeaf
        function GtkWindowControls(args...; kwargs...)
            GtkWindowControlsLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkWindowControlsLeaf) = begin
                    [:handle, :decoration_layout, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :empty, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor, :side]
                end
            function Base.getproperty(o::GtkWindowControlsLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:decoration_layout => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :empty => (:Bool, 0, 1), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1), :side => (:PackType, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkWindowControlsLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:decoration_layout => (:String, 0, 3), :css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :side => (:PackType, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GtkWindowGroup <: GObject end
    end
    begin
        mutable struct GtkWindowGroupLeaf <: GtkWindowGroup
            handle::Ptr{GObject}
            function GtkWindowGroupLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkWindowGroupLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWindowGroupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWindowGroupLeaf, args))
            end
            w = GtkWindowGroupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWindowGroup] = GtkWindowGroupLeaf
        function GtkWindowGroup(args...; kwargs...)
            GtkWindowGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkWindowHandle <: GtkWidget end
    end
    begin
        mutable struct GtkWindowHandleLeaf <: GtkWindowHandle
            handle::Ptr{GObject}
            function GtkWindowHandleLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GtkWindowHandleLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWindowHandleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWindowHandleLeaf, args))
            end
            w = GtkWindowHandleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWindowHandle] = GtkWindowHandleLeaf
        function GtkWindowHandle(args...; kwargs...)
            GtkWindowHandleLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GtkWindowHandleLeaf) = begin
                    [:handle, :css_classes, :visible, :focusable, :has_default, :valign, :vexpand_set, :has_tooltip, :overflow, :accessible_role, :margin_start, :margin_end, :hexpand, :receives_default, :tooltip_text, :halign, :can_focus, :name, :opacity, :height_request, :layout_manager, :hexpand_set, :sensitive, :width_request, :child, :focus_on_click, :cursor, :margin_top, :tooltip_markup, :margin_bottom, :vexpand, :can_target, :css_name, :parent, :has_focus, :root, :scale_factor]
                end
            function Base.getproperty(o::GtkWindowHandleLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :has_default => (:Bool, 0, 1), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11), :parent => (:GtkWidget, 0, 1), :has_focus => (:Bool, 0, 1), :root => (:GtkRoot, 0, 1), :scale_factor => (:Int32, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GtkWindowHandleLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:css_classes => (:(Array{GI.TypeDesc{Type{String}}(String, :Any, :String, :(Ptr{UInt8}))}), 0, 3), :visible => (:Bool, 0, 3), :focusable => (:Bool, 0, 3), :valign => (:Align, 0, 3), :vexpand_set => (:Bool, 0, 3), :has_tooltip => (:Bool, 0, 3), :overflow => (:Overflow, 0, 3), :accessible_role => (:AccessibleRole, 0, 3), :margin_start => (:Int32, 0, 3), :margin_end => (:Int32, 0, 3), :hexpand => (:Bool, 0, 3), :receives_default => (:Bool, 0, 3), :tooltip_text => (:String, 0, 3), :halign => (:Align, 0, 3), :can_focus => (:Bool, 0, 3), :name => (:String, 0, 3), :opacity => (:Float64, 0, 3), :height_request => (:Int32, 0, 3), :layout_manager => (:GtkLayoutManager, 0, 3), :hexpand_set => (:Bool, 0, 3), :sensitive => (:Bool, 0, 3), :width_request => (:Int32, 0, 3), :child => (:GtkWidget, 0, 3), :focus_on_click => (:Bool, 0, 3), :cursor => (:GdkCursor, 0, 3), :margin_top => (:Int32, 0, 3), :tooltip_markup => (:String, 0, 3), :margin_bottom => (:Int32, 0, 3), :vexpand => (:Bool, 0, 3), :can_target => (:Bool, 0, 3), :css_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        gtype_wrapper_cache_init() = begin
                merge!(GLib.gtype_wrappers, gtype_wrapper_cache)
            end
    end
    begin
        struct GtkAccessible <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkAccessible(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkActionable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkActionable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkAppChooser <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkAppChooser(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkBuildable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkBuildable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkBuilderScope <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkBuilderScope(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkCellEditable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkCellEditable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkCellLayout <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkCellLayout(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkColorChooser <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkColorChooser(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkConstraintTarget <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkConstraintTarget(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkEditable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkEditable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkFileChooser <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkFileChooser(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkFontChooser <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkFontChooser(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkNative <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkNative(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkOrientable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkOrientable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkPrintOperationPreview <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkPrintOperationPreview(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkRoot <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkRoot(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkScrollable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkScrollable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkSelectionModel <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkSelectionModel(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkShortcutManager <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkShortcutManager(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkStyleProvider <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkStyleProvider(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkTreeDragDest <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkTreeDragDest(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkTreeDragSource <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkTreeDragSource(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkTreeModel <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkTreeModel(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkTreeSortable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkTreeSortable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    export GtkBitset, GtkBitsetIter, GtkBorder, GtkBuildableParseContext, GtkBuildableParser, GtkCssLocation, GtkCssSection, GtkCssStyleChange, GtkExpressionWatch, GtkPadActionEntry, GtkPaperSize, GtkPrintBackend, GtkRecentData, GtkRecentInfo, GtkRequestedSize, GtkRequisition, GtkTextIter, GtkTreeIter, GtkTreePath, GtkTreeRowReference, GtkATContext, GtkAboutDialog, GtkActionBar, GtkActivateAction, GtkAdjustment, GtkAlternativeTrigger, GtkAnyFilter, GtkAppChooserButton, GtkAppChooserDialog, GtkAppChooserWidget, GtkApplication, GtkApplicationWindow, GtkAspectFrame, GtkAssistant, GtkAssistantPage, GtkBinLayout, GtkBookmarkList, GtkBoolFilter, GtkBox, GtkBoxLayout, GtkBuilder, GtkBuilderCScope, GtkBuilderListItemFactory, GtkButton, GtkCalendar, GtkCallbackAction, GtkCellArea, GtkCellAreaBox, GtkCellAreaContext, GtkCellRenderer, GtkCellRendererAccel, GtkCellRendererCombo, GtkCellRendererPixbuf, GtkCellRendererProgress, GtkCellRendererSpin, GtkCellRendererSpinner, GtkCellRendererText, GtkCellRendererToggle, GtkCellView, GtkCenterBox, GtkCenterLayout, GtkCheckButton, GtkColorButton, GtkColorChooserDialog, GtkColorChooserWidget, GtkColumnView, GtkColumnViewColumn, GtkComboBox, GtkComboBoxText, GtkConstraint, GtkConstraintGuide, GtkConstraintLayout, GtkConstraintLayoutChild, GtkCssProvider, GtkCustomFilter, GtkCustomLayout, GtkCustomSorter, GtkDialog, GtkDirectoryList, GtkDragIcon, GtkDragSource, GtkDrawingArea, GtkDropControllerMotion, GtkDropDown, GtkDropTarget, GtkDropTargetAsync, GtkEditableLabel, GtkEmojiChooser, GtkEntry, GtkEntryBuffer, GtkEntryCompletion, GtkEventController, GtkEventControllerFocus, GtkEventControllerKey, GtkEventControllerLegacy, GtkEventControllerMotion, GtkEventControllerScroll, GtkEveryFilter, GtkExpander, GtkFileChooserDialog, GtkFileChooserNative, GtkFileChooserWidget, GtkFileFilter, GtkFilter, GtkFilterListModel, GtkFixed, GtkFixedLayout, GtkFixedLayoutChild, GtkFlattenListModel, GtkFlowBox, GtkFlowBoxChild, GtkFontButton, GtkFontChooserDialog, GtkFontChooserWidget, GtkFrame, GtkGLArea, GtkGesture, GtkGestureClick, GtkGestureDrag, GtkGestureLongPress, GtkGesturePan, GtkGestureRotate, GtkGestureSingle, GtkGestureStylus, GtkGestureSwipe, GtkGestureZoom, GtkGrid, GtkGridLayout, GtkGridLayoutChild, GtkGridView, GtkHeaderBar, GtkIMContext, GtkIMContextSimple, GtkIMMulticontext, GtkIconPaintable, GtkIconTheme, GtkIconView, GtkImage, GtkInfoBar, GtkKeyvalTrigger, GtkLabel, GtkLayoutChild, GtkLayoutManager, GtkLevelBar, GtkLinkButton, GtkListBase, GtkListBox, GtkListBoxRow, GtkListItem, GtkListItemFactory, GtkListStore, GtkListView, GtkLockButton, GtkMapListModel, GtkMediaControls, GtkMediaFile, GtkMediaStream, GtkMenuButton, GtkMessageDialog, GtkMnemonicAction, GtkMnemonicTrigger, GtkMountOperation, GtkMultiFilter, GtkMultiSelection, GtkMultiSorter, GtkNamedAction, GtkNativeDialog, GtkNeverTrigger, GtkNoSelection, GtkNotebook, GtkNotebookPage, GtkNothingAction, GtkNumericSorter, GtkOverlay, GtkOverlayLayout, GtkOverlayLayoutChild, GtkPadController, GtkPageSetup, GtkPageSetupUnixDialog, GtkPaned, GtkPasswordEntry, GtkPasswordEntryBuffer, GtkPicture, GtkPopover, GtkPopoverMenu, GtkPopoverMenuBar, GtkPrintContext, GtkPrintJob, GtkPrintOperation, GtkPrintSettings, GtkPrintUnixDialog, GtkPrinter, GtkProgressBar, GtkRange, GtkRecentManager, GtkRevealer, GtkScale, GtkScaleButton, GtkScrollbar, GtkScrolledWindow, GtkSearchBar, GtkSearchEntry, GtkSelectionFilterModel, GtkSeparator, GtkSettings, GtkShortcut, GtkShortcutAction, GtkShortcutController, GtkShortcutLabel, GtkShortcutTrigger, GtkShortcutsGroup, GtkShortcutsSection, GtkShortcutsShortcut, GtkShortcutsWindow, GtkSignalAction, GtkSignalListItemFactory, GtkSingleSelection, GtkSizeGroup, GtkSliceListModel, GtkSnapshot, GtkSortListModel, GtkSorter, GtkSpinButton, GtkSpinner, GtkStack, GtkStackPage, GtkStackSidebar, GtkStackSwitcher, GtkStatusbar, GtkStringFilter, GtkStringList, GtkStringObject, GtkStringSorter, GtkStyleContext, GtkSwitch, GtkText, GtkTextBuffer, GtkTextChildAnchor, GtkTextMark, GtkTextTag, GtkTextTagTable, GtkTextView, GtkToggleButton, GtkTooltip, GtkTreeExpander, GtkTreeListModel, GtkTreeListRow, GtkTreeListRowSorter, GtkTreeModelFilter, GtkTreeModelSort, GtkTreeSelection, GtkTreeStore, GtkTreeView, GtkTreeViewColumn, GtkVideo, GtkViewport, GtkVolumeButton, GtkWidget, GtkWidgetPaintable, GtkWindow, GtkWindowControls, GtkWindowGroup, GtkWindowHandle, GtkAccessible, GtkActionable, GtkAppChooser, GtkBuildable, GtkBuilderScope, GtkCellEditable, GtkCellLayout, GtkColorChooser, GtkConstraintTarget, GtkEditable, GtkFileChooser, GtkFontChooser, GtkNative, GtkOrientable, GtkPrintOperationPreview, GtkRoot, GtkScrollable, GtkSelectionModel, GtkShortcutManager, GtkStyleProvider, GtkTreeDragDest, GtkTreeDragSource, GtkTreeModel, GtkTreeSortable
end))
end
