quote
$(Expr(:toplevel, quote
    begin
        gboxed_types = Any[]
    end
    mutable struct GtkBitset <: GBoxed
        handle::Ptr{GtkBitset}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkBitset) = begin
                    ccall(("gtk_bitset_get_type", libgtk4), GType, ())
                end
            function GtkBitset(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkBitset)
        end
    end
    begin
        begin
            mutable struct GtkBitsetIter
                handle::Ptr{GtkBitsetIter}
            end
        end
        const _GtkBitsetIter = GtkBitsetIter
    end
    begin
        struct _GtkBorder
            left::Int16
            right::Int16
            top::Int16
            bottom::Int16
        end
        begin
            mutable struct GtkBorder <: GBoxed
                handle::Ptr{_GtkBorder}
                begin
                    (GLib.g_type(::Type{T}) where T <: GtkBorder) = begin
                            ccall(("gtk_border_get_type", libgtk4), GType, ())
                        end
                    function GtkBorder(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                        x = new(ref)
                        if own
                            finalizer(x) do x
                                GLib.delboxed(x)
                            end
                        end
                        x
                    end
                    push!(gboxed_types, GtkBorder)
                end
            end
        end
    end
    mutable struct GtkBuildableParseContext
        handle::Ptr{GtkBuildableParseContext}
    end
    begin
        begin
            mutable struct GtkBuildableParser
                handle::Ptr{GtkBuildableParser}
            end
        end
        const _GtkBuildableParser = GtkBuildableParser
    end
    begin
        struct _GtkCssLocation
            bytes::UInt64
            chars::UInt64
            lines::UInt64
            line_bytes::UInt64
            line_chars::UInt64
        end
        begin
            mutable struct GtkCssLocation
                handle::Ptr{_GtkCssLocation}
            end
        end
    end
    mutable struct GtkCssSection <: GBoxed
        handle::Ptr{GtkCssSection}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkCssSection) = begin
                    ccall(("gtk_css_section_get_type", libgtk4), GType, ())
                end
            function GtkCssSection(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkCssSection)
        end
    end
    mutable struct GtkCssStyleChange
        handle::Ptr{GtkCssStyleChange}
    end
    mutable struct GtkExpressionWatch <: GBoxed
        handle::Ptr{GtkExpressionWatch}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkExpressionWatch) = begin
                    ccall(("gtk_expression_watch_get_type", libgtk4), GType, ())
                end
            function GtkExpressionWatch(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkExpressionWatch)
        end
    end
    begin
        struct _GtkPadActionEntry
            type::Int32
            index::Int32
            mode::Int32
            label::Cstring
            action_name::Cstring
        end
        begin
            mutable struct GtkPadActionEntry
                handle::Ptr{_GtkPadActionEntry}
            end
        end
    end
    mutable struct GtkPaperSize <: GBoxed
        handle::Ptr{GtkPaperSize}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkPaperSize) = begin
                    ccall(("gtk_paper_size_get_type", libgtk4), GType, ())
                end
            function GtkPaperSize(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkPaperSize)
        end
    end
    mutable struct GtkPrintBackend
        handle::Ptr{GtkPrintBackend}
    end
    begin
        struct _GtkRecentData
            display_name::Cstring
            description::Cstring
            mime_type::Cstring
            app_name::Cstring
            app_exec::Cstring
            groups::Ptr{Cstring}
            is_private::Cint
        end
        begin
            mutable struct GtkRecentData
                handle::Ptr{_GtkRecentData}
            end
        end
    end
    mutable struct GtkRecentInfo <: GBoxed
        handle::Ptr{GtkRecentInfo}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkRecentInfo) = begin
                    ccall(("gtk_recent_info_get_type", libgtk4), GType, ())
                end
            function GtkRecentInfo(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkRecentInfo)
        end
    end
    begin
        struct _GtkRequestedSize
            data::Ptr{Nothing}
            minimum_size::Int32
            natural_size::Int32
        end
        begin
            mutable struct GtkRequestedSize
                handle::Ptr{_GtkRequestedSize}
            end
        end
    end
    begin
        struct _GtkRequisition
            width::Int32
            height::Int32
        end
        begin
            mutable struct GtkRequisition <: GBoxed
                handle::Ptr{_GtkRequisition}
                begin
                    (GLib.g_type(::Type{T}) where T <: GtkRequisition) = begin
                            ccall(("gtk_requisition_get_type", libgtk4), GType, ())
                        end
                    function GtkRequisition(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                        x = new(ref)
                        if own
                            finalizer(x) do x
                                GLib.delboxed(x)
                            end
                        end
                        x
                    end
                    push!(gboxed_types, GtkRequisition)
                end
            end
        end
    end
    begin
        struct _GtkTextIter
            dummy1::Ptr{Nothing}
            dummy2::Ptr{Nothing}
            dummy3::Int32
            dummy4::Int32
            dummy5::Int32
            dummy6::Int32
            dummy7::Int32
            dummy8::Int32
            dummy9::Ptr{Nothing}
            dummy10::Ptr{Nothing}
            dummy11::Int32
            dummy12::Int32
            dummy13::Int32
            dummy14::Ptr{Nothing}
        end
        begin
            mutable struct GtkTextIter <: GBoxed
                handle::Ptr{_GtkTextIter}
                begin
                    (GLib.g_type(::Type{T}) where T <: GtkTextIter) = begin
                            ccall(("gtk_text_iter_get_type", libgtk4), GType, ())
                        end
                    function GtkTextIter(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                        x = new(ref)
                        if own
                            finalizer(x) do x
                                GLib.delboxed(x)
                            end
                        end
                        x
                    end
                    push!(gboxed_types, GtkTextIter)
                end
            end
        end
    end
    begin
        struct _GtkTreeIter
            stamp::Int32
            user_data::Ptr{Nothing}
            user_data2::Ptr{Nothing}
            user_data3::Ptr{Nothing}
        end
        begin
            mutable struct GtkTreeIter <: GBoxed
                handle::Ptr{_GtkTreeIter}
                begin
                    (GLib.g_type(::Type{T}) where T <: GtkTreeIter) = begin
                            ccall(("gtk_tree_iter_get_type", libgtk4), GType, ())
                        end
                    function GtkTreeIter(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                        x = new(ref)
                        if own
                            finalizer(x) do x
                                GLib.delboxed(x)
                            end
                        end
                        x
                    end
                    push!(gboxed_types, GtkTreeIter)
                end
            end
        end
    end
    mutable struct GtkTreePath <: GBoxed
        handle::Ptr{GtkTreePath}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkTreePath) = begin
                    ccall(("gtk_tree_path_get_type", libgtk4), GType, ())
                end
            function GtkTreePath(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkTreePath)
        end
    end
    mutable struct GtkTreeRowReference <: GBoxed
        handle::Ptr{GtkTreeRowReference}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkTreeRowReference) = begin
                    ccall(("gtk_tree_row_reference_get_type", libgtk4), GType, ())
                end
            function GtkTreeRowReference(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkTreeRowReference)
        end
    end
    begin
        gboxed_cache_init() = begin
                append!(GLib.gboxed_types, gboxed_types)
            end
    end
    begin
        gtype_wrapper_cache = Dict{Symbol, Type}()
    end
    begin
        abstract type GtkATContext <: GObject end
    end
    begin
        mutable struct GtkATContextLeaf <: GtkATContext
            handle::Ptr{GObject}
            function GtkATContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkATContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkATContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkATContextLeaf, args))
            end
            w = GtkATContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkATContext] = GtkATContextLeaf
        function GtkATContext(args...; kwargs...)
            GtkATContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkWidget <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkWidgetLeaf <: GtkWidget
            handle::Ptr{GObject}
            function GtkWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWidgetLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWidgetLeaf, args))
            end
            w = GtkWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWidget] = GtkWidgetLeaf
        function GtkWidget(args...; kwargs...)
            GtkWidgetLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkWindow <: GtkWidget end
    end
    begin
        mutable struct GtkWindowLeaf <: GtkWindow
            handle::Ptr{GObject}
            function GtkWindowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWindowLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWindowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWindowLeaf, args))
            end
            w = GtkWindowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWindow] = GtkWindowLeaf
        function GtkWindow(args...; kwargs...)
            GtkWindowLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAboutDialog <: GtkWindow end
    end
    begin
        mutable struct GtkAboutDialogLeaf <: GtkAboutDialog
            handle::Ptr{GObject}
            function GtkAboutDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAboutDialogLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAboutDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAboutDialogLeaf, args))
            end
            w = GtkAboutDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAboutDialog] = GtkAboutDialogLeaf
        function GtkAboutDialog(args...; kwargs...)
            GtkAboutDialogLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkActionBar <: GtkWidget end
    end
    begin
        mutable struct GtkActionBarLeaf <: GtkActionBar
            handle::Ptr{GObject}
            function GtkActionBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkActionBarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkActionBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkActionBarLeaf, args))
            end
            w = GtkActionBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkActionBar] = GtkActionBarLeaf
        function GtkActionBar(args...; kwargs...)
            GtkActionBarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkShortcutAction <: GObject end
    end
    begin
        mutable struct GtkShortcutActionLeaf <: GtkShortcutAction
            handle::Ptr{GObject}
            function GtkShortcutActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutActionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutActionLeaf, args))
            end
            w = GtkShortcutActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutAction] = GtkShortcutActionLeaf
        function GtkShortcutAction(args...; kwargs...)
            GtkShortcutActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkActivateAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkActivateActionLeaf <: GtkActivateAction
            handle::Ptr{GObject}
            function GtkActivateActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkActivateActionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkActivateActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkActivateActionLeaf, args))
            end
            w = GtkActivateActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkActivateAction] = GtkActivateActionLeaf
        function GtkActivateAction(args...; kwargs...)
            GtkActivateActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAdjustment <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkAdjustmentLeaf <: GtkAdjustment
            handle::Ptr{GObject}
            function GtkAdjustmentLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAdjustmentLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAdjustmentLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAdjustmentLeaf, args))
            end
            w = GtkAdjustmentLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAdjustment] = GtkAdjustmentLeaf
        function GtkAdjustment(args...; kwargs...)
            GtkAdjustmentLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkShortcutTrigger <: GObject end
    end
    begin
        mutable struct GtkShortcutTriggerLeaf <: GtkShortcutTrigger
            handle::Ptr{GObject}
            function GtkShortcutTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutTriggerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutTriggerLeaf, args))
            end
            w = GtkShortcutTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutTrigger] = GtkShortcutTriggerLeaf
        function GtkShortcutTrigger(args...; kwargs...)
            GtkShortcutTriggerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAlternativeTrigger <: GtkShortcutTrigger end
    end
    begin
        mutable struct GtkAlternativeTriggerLeaf <: GtkAlternativeTrigger
            handle::Ptr{GObject}
            function GtkAlternativeTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAlternativeTriggerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAlternativeTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAlternativeTriggerLeaf, args))
            end
            w = GtkAlternativeTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAlternativeTrigger] = GtkAlternativeTriggerLeaf
        function GtkAlternativeTrigger(args...; kwargs...)
            GtkAlternativeTriggerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFilter <: GObject end
    end
    begin
        mutable struct GtkFilterLeaf <: GtkFilter
            handle::Ptr{GObject}
            function GtkFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFilterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFilterLeaf, args))
            end
            w = GtkFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFilter] = GtkFilterLeaf
        function GtkFilter(args...; kwargs...)
            GtkFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMultiFilter <: GtkFilter end
    end
    begin
        mutable struct GtkMultiFilterLeaf <: GtkMultiFilter
            handle::Ptr{GObject}
            function GtkMultiFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMultiFilterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMultiFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMultiFilterLeaf, args))
            end
            w = GtkMultiFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMultiFilter] = GtkMultiFilterLeaf
        function GtkMultiFilter(args...; kwargs...)
            GtkMultiFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAnyFilter <: GtkMultiFilter end
    end
    begin
        mutable struct GtkAnyFilterLeaf <: GtkAnyFilter
            handle::Ptr{GObject}
            function GtkAnyFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAnyFilterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAnyFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAnyFilterLeaf, args))
            end
            w = GtkAnyFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAnyFilter] = GtkAnyFilterLeaf
        function GtkAnyFilter(args...; kwargs...)
            GtkAnyFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAppChooserButton <: GtkWidget end
    end
    begin
        mutable struct GtkAppChooserButtonLeaf <: GtkAppChooserButton
            handle::Ptr{GObject}
            function GtkAppChooserButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAppChooserButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAppChooserButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAppChooserButtonLeaf, args))
            end
            w = GtkAppChooserButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAppChooserButton] = GtkAppChooserButtonLeaf
        function GtkAppChooserButton(args...; kwargs...)
            GtkAppChooserButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDialog <: GtkWindow end
    end
    begin
        mutable struct GtkDialogLeaf <: GtkDialog
            handle::Ptr{GObject}
            function GtkDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDialogLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDialogLeaf, args))
            end
            w = GtkDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDialog] = GtkDialogLeaf
        function GtkDialog(args...; kwargs...)
            GtkDialogLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAppChooserDialog <: GtkDialog end
    end
    begin
        mutable struct GtkAppChooserDialogLeaf <: GtkAppChooserDialog
            handle::Ptr{GObject}
            function GtkAppChooserDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAppChooserDialogLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAppChooserDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAppChooserDialogLeaf, args))
            end
            w = GtkAppChooserDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAppChooserDialog] = GtkAppChooserDialogLeaf
        function GtkAppChooserDialog(args...; kwargs...)
            GtkAppChooserDialogLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAppChooserWidget <: GtkWidget end
    end
    begin
        mutable struct GtkAppChooserWidgetLeaf <: GtkAppChooserWidget
            handle::Ptr{GObject}
            function GtkAppChooserWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAppChooserWidgetLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAppChooserWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAppChooserWidgetLeaf, args))
            end
            w = GtkAppChooserWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAppChooserWidget] = GtkAppChooserWidgetLeaf
        function GtkAppChooserWidget(args...; kwargs...)
            GtkAppChooserWidgetLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkApplication <: GApplication end
    end
    begin
        mutable struct GtkApplicationLeaf <: GtkApplication
            handle::Ptr{GObject}
            function GtkApplicationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkApplicationLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkApplicationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkApplicationLeaf, args))
            end
            w = GtkApplicationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkApplication] = GtkApplicationLeaf
        function GtkApplication(args...; kwargs...)
            GtkApplicationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkApplicationWindow <: GtkWindow end
    end
    begin
        mutable struct GtkApplicationWindowLeaf <: GtkApplicationWindow
            handle::Ptr{GObject}
            function GtkApplicationWindowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkApplicationWindowLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkApplicationWindowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkApplicationWindowLeaf, args))
            end
            w = GtkApplicationWindowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkApplicationWindow] = GtkApplicationWindowLeaf
        function GtkApplicationWindow(args...; kwargs...)
            GtkApplicationWindowLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAspectFrame <: GtkWidget end
    end
    begin
        mutable struct GtkAspectFrameLeaf <: GtkAspectFrame
            handle::Ptr{GObject}
            function GtkAspectFrameLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAspectFrameLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAspectFrameLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAspectFrameLeaf, args))
            end
            w = GtkAspectFrameLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAspectFrame] = GtkAspectFrameLeaf
        function GtkAspectFrame(args...; kwargs...)
            GtkAspectFrameLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAssistant <: GtkWindow end
    end
    begin
        mutable struct GtkAssistantLeaf <: GtkAssistant
            handle::Ptr{GObject}
            function GtkAssistantLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAssistantLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAssistantLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAssistantLeaf, args))
            end
            w = GtkAssistantLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAssistant] = GtkAssistantLeaf
        function GtkAssistant(args...; kwargs...)
            GtkAssistantLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkAssistantPage <: GObject end
    end
    begin
        mutable struct GtkAssistantPageLeaf <: GtkAssistantPage
            handle::Ptr{GObject}
            function GtkAssistantPageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAssistantPageLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkAssistantPageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkAssistantPageLeaf, args))
            end
            w = GtkAssistantPageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkAssistantPage] = GtkAssistantPageLeaf
        function GtkAssistantPage(args...; kwargs...)
            GtkAssistantPageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkLayoutManager <: GObject end
    end
    begin
        mutable struct GtkLayoutManagerLeaf <: GtkLayoutManager
            handle::Ptr{GObject}
            function GtkLayoutManagerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLayoutManagerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLayoutManagerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLayoutManagerLeaf, args))
            end
            w = GtkLayoutManagerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLayoutManager] = GtkLayoutManagerLeaf
        function GtkLayoutManager(args...; kwargs...)
            GtkLayoutManagerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBinLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkBinLayoutLeaf <: GtkBinLayout
            handle::Ptr{GObject}
            function GtkBinLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBinLayoutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBinLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBinLayoutLeaf, args))
            end
            w = GtkBinLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBinLayout] = GtkBinLayoutLeaf
        function GtkBinLayout(args...; kwargs...)
            GtkBinLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBookmarkList <: GObject end
    end
    begin
        mutable struct GtkBookmarkListLeaf <: GtkBookmarkList
            handle::Ptr{GObject}
            function GtkBookmarkListLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBookmarkListLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBookmarkListLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBookmarkListLeaf, args))
            end
            w = GtkBookmarkListLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBookmarkList] = GtkBookmarkListLeaf
        function GtkBookmarkList(args...; kwargs...)
            GtkBookmarkListLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBoolFilter <: GtkFilter end
    end
    begin
        mutable struct GtkBoolFilterLeaf <: GtkBoolFilter
            handle::Ptr{GObject}
            function GtkBoolFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBoolFilterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBoolFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBoolFilterLeaf, args))
            end
            w = GtkBoolFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBoolFilter] = GtkBoolFilterLeaf
        function GtkBoolFilter(args...; kwargs...)
            GtkBoolFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBox <: GtkWidget end
    end
    begin
        mutable struct GtkBoxLeaf <: GtkBox
            handle::Ptr{GObject}
            function GtkBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBoxLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBoxLeaf, args))
            end
            w = GtkBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBox] = GtkBoxLeaf
        function GtkBox(args...; kwargs...)
            GtkBoxLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBoxLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkBoxLayoutLeaf <: GtkBoxLayout
            handle::Ptr{GObject}
            function GtkBoxLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBoxLayoutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBoxLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBoxLayoutLeaf, args))
            end
            w = GtkBoxLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBoxLayout] = GtkBoxLayoutLeaf
        function GtkBoxLayout(args...; kwargs...)
            GtkBoxLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBuilder <: GObject end
    end
    begin
        mutable struct GtkBuilderLeaf <: GtkBuilder
            handle::Ptr{GObject}
            function GtkBuilderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBuilderLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBuilderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBuilderLeaf, args))
            end
            w = GtkBuilderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBuilder] = GtkBuilderLeaf
        function GtkBuilder(args...; kwargs...)
            GtkBuilderLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBuilderCScope <: GObject end
    end
    begin
        mutable struct GtkBuilderCScopeLeaf <: GtkBuilderCScope
            handle::Ptr{GObject}
            function GtkBuilderCScopeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBuilderCScopeLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBuilderCScopeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBuilderCScopeLeaf, args))
            end
            w = GtkBuilderCScopeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBuilderCScope] = GtkBuilderCScopeLeaf
        function GtkBuilderCScope(args...; kwargs...)
            GtkBuilderCScopeLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkListItemFactory <: GObject end
    end
    begin
        mutable struct GtkListItemFactoryLeaf <: GtkListItemFactory
            handle::Ptr{GObject}
            function GtkListItemFactoryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListItemFactoryLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListItemFactoryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListItemFactoryLeaf, args))
            end
            w = GtkListItemFactoryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListItemFactory] = GtkListItemFactoryLeaf
        function GtkListItemFactory(args...; kwargs...)
            GtkListItemFactoryLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkBuilderListItemFactory <: GtkListItemFactory end
    end
    begin
        mutable struct GtkBuilderListItemFactoryLeaf <: GtkBuilderListItemFactory
            handle::Ptr{GObject}
            function GtkBuilderListItemFactoryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBuilderListItemFactoryLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkBuilderListItemFactoryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkBuilderListItemFactoryLeaf, args))
            end
            w = GtkBuilderListItemFactoryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkBuilderListItemFactory] = GtkBuilderListItemFactoryLeaf
        function GtkBuilderListItemFactory(args...; kwargs...)
            GtkBuilderListItemFactoryLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkButton <: GtkWidget end
    end
    begin
        mutable struct GtkButtonLeaf <: GtkButton
            handle::Ptr{GObject}
            function GtkButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkButtonLeaf, args))
            end
            w = GtkButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkButton] = GtkButtonLeaf
        function GtkButton(args...; kwargs...)
            GtkButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCalendar <: GtkWidget end
    end
    begin
        mutable struct GtkCalendarLeaf <: GtkCalendar
            handle::Ptr{GObject}
            function GtkCalendarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCalendarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCalendarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCalendarLeaf, args))
            end
            w = GtkCalendarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCalendar] = GtkCalendarLeaf
        function GtkCalendar(args...; kwargs...)
            GtkCalendarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCallbackAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkCallbackActionLeaf <: GtkCallbackAction
            handle::Ptr{GObject}
            function GtkCallbackActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCallbackActionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCallbackActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCallbackActionLeaf, args))
            end
            w = GtkCallbackActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCallbackAction] = GtkCallbackActionLeaf
        function GtkCallbackAction(args...; kwargs...)
            GtkCallbackActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellArea <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkCellAreaLeaf <: GtkCellArea
            handle::Ptr{GObject}
            function GtkCellAreaLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellAreaLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellAreaLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellAreaLeaf, args))
            end
            w = GtkCellAreaLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellArea] = GtkCellAreaLeaf
        function GtkCellArea(args...; kwargs...)
            GtkCellAreaLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellAreaBox <: GtkCellArea end
    end
    begin
        mutable struct GtkCellAreaBoxLeaf <: GtkCellAreaBox
            handle::Ptr{GObject}
            function GtkCellAreaBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellAreaBoxLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellAreaBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellAreaBoxLeaf, args))
            end
            w = GtkCellAreaBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellAreaBox] = GtkCellAreaBoxLeaf
        function GtkCellAreaBox(args...; kwargs...)
            GtkCellAreaBoxLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellAreaContext <: GObject end
    end
    begin
        mutable struct GtkCellAreaContextLeaf <: GtkCellAreaContext
            handle::Ptr{GObject}
            function GtkCellAreaContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellAreaContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellAreaContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellAreaContextLeaf, args))
            end
            w = GtkCellAreaContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellAreaContext] = GtkCellAreaContextLeaf
        function GtkCellAreaContext(args...; kwargs...)
            GtkCellAreaContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellRenderer <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkCellRendererLeaf <: GtkCellRenderer
            handle::Ptr{GObject}
            function GtkCellRendererLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererLeaf, args))
            end
            w = GtkCellRendererLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRenderer] = GtkCellRendererLeaf
        function GtkCellRenderer(args...; kwargs...)
            GtkCellRendererLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellRendererText <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererTextLeaf <: GtkCellRendererText
            handle::Ptr{GObject}
            function GtkCellRendererTextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererTextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererTextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererTextLeaf, args))
            end
            w = GtkCellRendererTextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererText] = GtkCellRendererTextLeaf
        function GtkCellRendererText(args...; kwargs...)
            GtkCellRendererTextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellRendererAccel <: GtkCellRendererText end
    end
    begin
        mutable struct GtkCellRendererAccelLeaf <: GtkCellRendererAccel
            handle::Ptr{GObject}
            function GtkCellRendererAccelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererAccelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererAccelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererAccelLeaf, args))
            end
            w = GtkCellRendererAccelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererAccel] = GtkCellRendererAccelLeaf
        function GtkCellRendererAccel(args...; kwargs...)
            GtkCellRendererAccelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellRendererCombo <: GtkCellRendererText end
    end
    begin
        mutable struct GtkCellRendererComboLeaf <: GtkCellRendererCombo
            handle::Ptr{GObject}
            function GtkCellRendererComboLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererComboLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererComboLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererComboLeaf, args))
            end
            w = GtkCellRendererComboLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererCombo] = GtkCellRendererComboLeaf
        function GtkCellRendererCombo(args...; kwargs...)
            GtkCellRendererComboLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellRendererPixbuf <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererPixbufLeaf <: GtkCellRendererPixbuf
            handle::Ptr{GObject}
            function GtkCellRendererPixbufLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererPixbufLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererPixbufLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererPixbufLeaf, args))
            end
            w = GtkCellRendererPixbufLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererPixbuf] = GtkCellRendererPixbufLeaf
        function GtkCellRendererPixbuf(args...; kwargs...)
            GtkCellRendererPixbufLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellRendererProgress <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererProgressLeaf <: GtkCellRendererProgress
            handle::Ptr{GObject}
            function GtkCellRendererProgressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererProgressLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererProgressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererProgressLeaf, args))
            end
            w = GtkCellRendererProgressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererProgress] = GtkCellRendererProgressLeaf
        function GtkCellRendererProgress(args...; kwargs...)
            GtkCellRendererProgressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellRendererSpin <: GtkCellRendererText end
    end
    begin
        mutable struct GtkCellRendererSpinLeaf <: GtkCellRendererSpin
            handle::Ptr{GObject}
            function GtkCellRendererSpinLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererSpinLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererSpinLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererSpinLeaf, args))
            end
            w = GtkCellRendererSpinLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererSpin] = GtkCellRendererSpinLeaf
        function GtkCellRendererSpin(args...; kwargs...)
            GtkCellRendererSpinLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellRendererSpinner <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererSpinnerLeaf <: GtkCellRendererSpinner
            handle::Ptr{GObject}
            function GtkCellRendererSpinnerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererSpinnerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererSpinnerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererSpinnerLeaf, args))
            end
            w = GtkCellRendererSpinnerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererSpinner] = GtkCellRendererSpinnerLeaf
        function GtkCellRendererSpinner(args...; kwargs...)
            GtkCellRendererSpinnerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellRendererToggle <: GtkCellRenderer end
    end
    begin
        mutable struct GtkCellRendererToggleLeaf <: GtkCellRendererToggle
            handle::Ptr{GObject}
            function GtkCellRendererToggleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererToggleLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellRendererToggleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellRendererToggleLeaf, args))
            end
            w = GtkCellRendererToggleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellRendererToggle] = GtkCellRendererToggleLeaf
        function GtkCellRendererToggle(args...; kwargs...)
            GtkCellRendererToggleLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCellView <: GtkWidget end
    end
    begin
        mutable struct GtkCellViewLeaf <: GtkCellView
            handle::Ptr{GObject}
            function GtkCellViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellViewLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCellViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCellViewLeaf, args))
            end
            w = GtkCellViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCellView] = GtkCellViewLeaf
        function GtkCellView(args...; kwargs...)
            GtkCellViewLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCenterBox <: GtkWidget end
    end
    begin
        mutable struct GtkCenterBoxLeaf <: GtkCenterBox
            handle::Ptr{GObject}
            function GtkCenterBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCenterBoxLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCenterBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCenterBoxLeaf, args))
            end
            w = GtkCenterBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCenterBox] = GtkCenterBoxLeaf
        function GtkCenterBox(args...; kwargs...)
            GtkCenterBoxLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCenterLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkCenterLayoutLeaf <: GtkCenterLayout
            handle::Ptr{GObject}
            function GtkCenterLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCenterLayoutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCenterLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCenterLayoutLeaf, args))
            end
            w = GtkCenterLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCenterLayout] = GtkCenterLayoutLeaf
        function GtkCenterLayout(args...; kwargs...)
            GtkCenterLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCheckButton <: GtkWidget end
    end
    begin
        mutable struct GtkCheckButtonLeaf <: GtkCheckButton
            handle::Ptr{GObject}
            function GtkCheckButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCheckButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCheckButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCheckButtonLeaf, args))
            end
            w = GtkCheckButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCheckButton] = GtkCheckButtonLeaf
        function GtkCheckButton(args...; kwargs...)
            GtkCheckButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkColorButton <: GtkWidget end
    end
    begin
        mutable struct GtkColorButtonLeaf <: GtkColorButton
            handle::Ptr{GObject}
            function GtkColorButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColorButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColorButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColorButtonLeaf, args))
            end
            w = GtkColorButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColorButton] = GtkColorButtonLeaf
        function GtkColorButton(args...; kwargs...)
            GtkColorButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkColorChooserDialog <: GtkDialog end
    end
    begin
        mutable struct GtkColorChooserDialogLeaf <: GtkColorChooserDialog
            handle::Ptr{GObject}
            function GtkColorChooserDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColorChooserDialogLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColorChooserDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColorChooserDialogLeaf, args))
            end
            w = GtkColorChooserDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColorChooserDialog] = GtkColorChooserDialogLeaf
        function GtkColorChooserDialog(args...; kwargs...)
            GtkColorChooserDialogLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkColorChooserWidget <: GtkWidget end
    end
    begin
        mutable struct GtkColorChooserWidgetLeaf <: GtkColorChooserWidget
            handle::Ptr{GObject}
            function GtkColorChooserWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColorChooserWidgetLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColorChooserWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColorChooserWidgetLeaf, args))
            end
            w = GtkColorChooserWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColorChooserWidget] = GtkColorChooserWidgetLeaf
        function GtkColorChooserWidget(args...; kwargs...)
            GtkColorChooserWidgetLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkColumnView <: GtkWidget end
    end
    begin
        mutable struct GtkColumnViewLeaf <: GtkColumnView
            handle::Ptr{GObject}
            function GtkColumnViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColumnViewLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColumnViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColumnViewLeaf, args))
            end
            w = GtkColumnViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColumnView] = GtkColumnViewLeaf
        function GtkColumnView(args...; kwargs...)
            GtkColumnViewLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkColumnViewColumn <: GObject end
    end
    begin
        mutable struct GtkColumnViewColumnLeaf <: GtkColumnViewColumn
            handle::Ptr{GObject}
            function GtkColumnViewColumnLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColumnViewColumnLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkColumnViewColumnLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkColumnViewColumnLeaf, args))
            end
            w = GtkColumnViewColumnLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkColumnViewColumn] = GtkColumnViewColumnLeaf
        function GtkColumnViewColumn(args...; kwargs...)
            GtkColumnViewColumnLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkComboBox <: GtkWidget end
    end
    begin
        mutable struct GtkComboBoxLeaf <: GtkComboBox
            handle::Ptr{GObject}
            function GtkComboBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkComboBoxLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkComboBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkComboBoxLeaf, args))
            end
            w = GtkComboBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkComboBox] = GtkComboBoxLeaf
        function GtkComboBox(args...; kwargs...)
            GtkComboBoxLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkComboBoxText <: GtkComboBox end
    end
    begin
        mutable struct GtkComboBoxTextLeaf <: GtkComboBoxText
            handle::Ptr{GObject}
            function GtkComboBoxTextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkComboBoxTextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkComboBoxTextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkComboBoxTextLeaf, args))
            end
            w = GtkComboBoxTextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkComboBoxText] = GtkComboBoxTextLeaf
        function GtkComboBoxText(args...; kwargs...)
            GtkComboBoxTextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkConstraint <: GObject end
    end
    begin
        mutable struct GtkConstraintLeaf <: GtkConstraint
            handle::Ptr{GObject}
            function GtkConstraintLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkConstraintLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkConstraintLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkConstraintLeaf, args))
            end
            w = GtkConstraintLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkConstraint] = GtkConstraintLeaf
        function GtkConstraint(args...; kwargs...)
            GtkConstraintLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkConstraintGuide <: GObject end
    end
    begin
        mutable struct GtkConstraintGuideLeaf <: GtkConstraintGuide
            handle::Ptr{GObject}
            function GtkConstraintGuideLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkConstraintGuideLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkConstraintGuideLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkConstraintGuideLeaf, args))
            end
            w = GtkConstraintGuideLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkConstraintGuide] = GtkConstraintGuideLeaf
        function GtkConstraintGuide(args...; kwargs...)
            GtkConstraintGuideLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkConstraintLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkConstraintLayoutLeaf <: GtkConstraintLayout
            handle::Ptr{GObject}
            function GtkConstraintLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkConstraintLayoutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkConstraintLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkConstraintLayoutLeaf, args))
            end
            w = GtkConstraintLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkConstraintLayout] = GtkConstraintLayoutLeaf
        function GtkConstraintLayout(args...; kwargs...)
            GtkConstraintLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkLayoutChild <: GObject end
    end
    begin
        mutable struct GtkLayoutChildLeaf <: GtkLayoutChild
            handle::Ptr{GObject}
            function GtkLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLayoutChildLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLayoutChildLeaf, args))
            end
            w = GtkLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLayoutChild] = GtkLayoutChildLeaf
        function GtkLayoutChild(args...; kwargs...)
            GtkLayoutChildLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkConstraintLayoutChild <: GtkLayoutChild end
    end
    begin
        mutable struct GtkConstraintLayoutChildLeaf <: GtkConstraintLayoutChild
            handle::Ptr{GObject}
            function GtkConstraintLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkConstraintLayoutChildLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkConstraintLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkConstraintLayoutChildLeaf, args))
            end
            w = GtkConstraintLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkConstraintLayoutChild] = GtkConstraintLayoutChildLeaf
        function GtkConstraintLayoutChild(args...; kwargs...)
            GtkConstraintLayoutChildLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCssProvider <: GObject end
    end
    begin
        mutable struct GtkCssProviderLeaf <: GtkCssProvider
            handle::Ptr{GObject}
            function GtkCssProviderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCssProviderLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCssProviderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCssProviderLeaf, args))
            end
            w = GtkCssProviderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCssProvider] = GtkCssProviderLeaf
        function GtkCssProvider(args...; kwargs...)
            GtkCssProviderLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCustomFilter <: GtkFilter end
    end
    begin
        mutable struct GtkCustomFilterLeaf <: GtkCustomFilter
            handle::Ptr{GObject}
            function GtkCustomFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCustomFilterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCustomFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCustomFilterLeaf, args))
            end
            w = GtkCustomFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCustomFilter] = GtkCustomFilterLeaf
        function GtkCustomFilter(args...; kwargs...)
            GtkCustomFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCustomLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkCustomLayoutLeaf <: GtkCustomLayout
            handle::Ptr{GObject}
            function GtkCustomLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCustomLayoutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCustomLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCustomLayoutLeaf, args))
            end
            w = GtkCustomLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCustomLayout] = GtkCustomLayoutLeaf
        function GtkCustomLayout(args...; kwargs...)
            GtkCustomLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSorter <: GObject end
    end
    begin
        mutable struct GtkSorterLeaf <: GtkSorter
            handle::Ptr{GObject}
            function GtkSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSorterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSorterLeaf, args))
            end
            w = GtkSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSorter] = GtkSorterLeaf
        function GtkSorter(args...; kwargs...)
            GtkSorterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkCustomSorter <: GtkSorter end
    end
    begin
        mutable struct GtkCustomSorterLeaf <: GtkCustomSorter
            handle::Ptr{GObject}
            function GtkCustomSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCustomSorterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkCustomSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkCustomSorterLeaf, args))
            end
            w = GtkCustomSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkCustomSorter] = GtkCustomSorterLeaf
        function GtkCustomSorter(args...; kwargs...)
            GtkCustomSorterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDirectoryList <: GObject end
    end
    begin
        mutable struct GtkDirectoryListLeaf <: GtkDirectoryList
            handle::Ptr{GObject}
            function GtkDirectoryListLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDirectoryListLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDirectoryListLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDirectoryListLeaf, args))
            end
            w = GtkDirectoryListLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDirectoryList] = GtkDirectoryListLeaf
        function GtkDirectoryList(args...; kwargs...)
            GtkDirectoryListLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDragIcon <: GtkWidget end
    end
    begin
        mutable struct GtkDragIconLeaf <: GtkDragIcon
            handle::Ptr{GObject}
            function GtkDragIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDragIconLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDragIconLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDragIconLeaf, args))
            end
            w = GtkDragIconLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDragIcon] = GtkDragIconLeaf
        function GtkDragIcon(args...; kwargs...)
            GtkDragIconLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEventController <: GObject end
    end
    begin
        mutable struct GtkEventControllerLeaf <: GtkEventController
            handle::Ptr{GObject}
            function GtkEventControllerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerLeaf, args))
            end
            w = GtkEventControllerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventController] = GtkEventControllerLeaf
        function GtkEventController(args...; kwargs...)
            GtkEventControllerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGesture <: GtkEventController end
    end
    begin
        mutable struct GtkGestureLeaf <: GtkGesture
            handle::Ptr{GObject}
            function GtkGestureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureLeaf, args))
            end
            w = GtkGestureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGesture] = GtkGestureLeaf
        function GtkGesture(args...; kwargs...)
            GtkGestureLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGestureSingle <: GtkGesture end
    end
    begin
        mutable struct GtkGestureSingleLeaf <: GtkGestureSingle
            handle::Ptr{GObject}
            function GtkGestureSingleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureSingleLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureSingleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureSingleLeaf, args))
            end
            w = GtkGestureSingleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureSingle] = GtkGestureSingleLeaf
        function GtkGestureSingle(args...; kwargs...)
            GtkGestureSingleLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDragSource <: GtkGestureSingle end
    end
    begin
        mutable struct GtkDragSourceLeaf <: GtkDragSource
            handle::Ptr{GObject}
            function GtkDragSourceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDragSourceLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDragSourceLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDragSourceLeaf, args))
            end
            w = GtkDragSourceLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDragSource] = GtkDragSourceLeaf
        function GtkDragSource(args...; kwargs...)
            GtkDragSourceLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDrawingArea <: GtkWidget end
    end
    begin
        mutable struct GtkDrawingAreaLeaf <: GtkDrawingArea
            handle::Ptr{GObject}
            function GtkDrawingAreaLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDrawingAreaLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDrawingAreaLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDrawingAreaLeaf, args))
            end
            w = GtkDrawingAreaLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDrawingArea] = GtkDrawingAreaLeaf
        function GtkDrawingArea(args...; kwargs...)
            GtkDrawingAreaLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDropControllerMotion <: GtkEventController end
    end
    begin
        mutable struct GtkDropControllerMotionLeaf <: GtkDropControllerMotion
            handle::Ptr{GObject}
            function GtkDropControllerMotionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDropControllerMotionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDropControllerMotionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDropControllerMotionLeaf, args))
            end
            w = GtkDropControllerMotionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDropControllerMotion] = GtkDropControllerMotionLeaf
        function GtkDropControllerMotion(args...; kwargs...)
            GtkDropControllerMotionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDropDown <: GtkWidget end
    end
    begin
        mutable struct GtkDropDownLeaf <: GtkDropDown
            handle::Ptr{GObject}
            function GtkDropDownLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDropDownLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDropDownLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDropDownLeaf, args))
            end
            w = GtkDropDownLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDropDown] = GtkDropDownLeaf
        function GtkDropDown(args...; kwargs...)
            GtkDropDownLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDropTarget <: GtkEventController end
    end
    begin
        mutable struct GtkDropTargetLeaf <: GtkDropTarget
            handle::Ptr{GObject}
            function GtkDropTargetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDropTargetLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDropTargetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDropTargetLeaf, args))
            end
            w = GtkDropTargetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDropTarget] = GtkDropTargetLeaf
        function GtkDropTarget(args...; kwargs...)
            GtkDropTargetLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkDropTargetAsync <: GtkEventController end
    end
    begin
        mutable struct GtkDropTargetAsyncLeaf <: GtkDropTargetAsync
            handle::Ptr{GObject}
            function GtkDropTargetAsyncLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDropTargetAsyncLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkDropTargetAsyncLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkDropTargetAsyncLeaf, args))
            end
            w = GtkDropTargetAsyncLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkDropTargetAsync] = GtkDropTargetAsyncLeaf
        function GtkDropTargetAsync(args...; kwargs...)
            GtkDropTargetAsyncLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEditableLabel <: GtkWidget end
    end
    begin
        mutable struct GtkEditableLabelLeaf <: GtkEditableLabel
            handle::Ptr{GObject}
            function GtkEditableLabelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEditableLabelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEditableLabelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEditableLabelLeaf, args))
            end
            w = GtkEditableLabelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEditableLabel] = GtkEditableLabelLeaf
        function GtkEditableLabel(args...; kwargs...)
            GtkEditableLabelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPopover <: GtkWidget end
    end
    begin
        mutable struct GtkPopoverLeaf <: GtkPopover
            handle::Ptr{GObject}
            function GtkPopoverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPopoverLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPopoverLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPopoverLeaf, args))
            end
            w = GtkPopoverLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPopover] = GtkPopoverLeaf
        function GtkPopover(args...; kwargs...)
            GtkPopoverLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEmojiChooser <: GtkPopover end
    end
    begin
        mutable struct GtkEmojiChooserLeaf <: GtkEmojiChooser
            handle::Ptr{GObject}
            function GtkEmojiChooserLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEmojiChooserLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEmojiChooserLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEmojiChooserLeaf, args))
            end
            w = GtkEmojiChooserLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEmojiChooser] = GtkEmojiChooserLeaf
        function GtkEmojiChooser(args...; kwargs...)
            GtkEmojiChooserLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEntry <: GtkWidget end
    end
    begin
        mutable struct GtkEntryLeaf <: GtkEntry
            handle::Ptr{GObject}
            function GtkEntryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEntryLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEntryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEntryLeaf, args))
            end
            w = GtkEntryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEntry] = GtkEntryLeaf
        function GtkEntry(args...; kwargs...)
            GtkEntryLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEntryBuffer <: GObject end
    end
    begin
        mutable struct GtkEntryBufferLeaf <: GtkEntryBuffer
            handle::Ptr{GObject}
            function GtkEntryBufferLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEntryBufferLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEntryBufferLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEntryBufferLeaf, args))
            end
            w = GtkEntryBufferLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEntryBuffer] = GtkEntryBufferLeaf
        function GtkEntryBuffer(args...; kwargs...)
            GtkEntryBufferLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEntryCompletion <: GObject end
    end
    begin
        mutable struct GtkEntryCompletionLeaf <: GtkEntryCompletion
            handle::Ptr{GObject}
            function GtkEntryCompletionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEntryCompletionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEntryCompletionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEntryCompletionLeaf, args))
            end
            w = GtkEntryCompletionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEntryCompletion] = GtkEntryCompletionLeaf
        function GtkEntryCompletion(args...; kwargs...)
            GtkEntryCompletionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEventControllerFocus <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerFocusLeaf <: GtkEventControllerFocus
            handle::Ptr{GObject}
            function GtkEventControllerFocusLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerFocusLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerFocusLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerFocusLeaf, args))
            end
            w = GtkEventControllerFocusLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerFocus] = GtkEventControllerFocusLeaf
        function GtkEventControllerFocus(args...; kwargs...)
            GtkEventControllerFocusLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEventControllerKey <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerKeyLeaf <: GtkEventControllerKey
            handle::Ptr{GObject}
            function GtkEventControllerKeyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerKeyLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerKeyLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerKeyLeaf, args))
            end
            w = GtkEventControllerKeyLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerKey] = GtkEventControllerKeyLeaf
        function GtkEventControllerKey(args...; kwargs...)
            GtkEventControllerKeyLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEventControllerLegacy <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerLegacyLeaf <: GtkEventControllerLegacy
            handle::Ptr{GObject}
            function GtkEventControllerLegacyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerLegacyLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerLegacyLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerLegacyLeaf, args))
            end
            w = GtkEventControllerLegacyLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerLegacy] = GtkEventControllerLegacyLeaf
        function GtkEventControllerLegacy(args...; kwargs...)
            GtkEventControllerLegacyLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEventControllerMotion <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerMotionLeaf <: GtkEventControllerMotion
            handle::Ptr{GObject}
            function GtkEventControllerMotionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerMotionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerMotionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerMotionLeaf, args))
            end
            w = GtkEventControllerMotionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerMotion] = GtkEventControllerMotionLeaf
        function GtkEventControllerMotion(args...; kwargs...)
            GtkEventControllerMotionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEventControllerScroll <: GtkEventController end
    end
    begin
        mutable struct GtkEventControllerScrollLeaf <: GtkEventControllerScroll
            handle::Ptr{GObject}
            function GtkEventControllerScrollLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerScrollLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEventControllerScrollLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEventControllerScrollLeaf, args))
            end
            w = GtkEventControllerScrollLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEventControllerScroll] = GtkEventControllerScrollLeaf
        function GtkEventControllerScroll(args...; kwargs...)
            GtkEventControllerScrollLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkEveryFilter <: GtkMultiFilter end
    end
    begin
        mutable struct GtkEveryFilterLeaf <: GtkEveryFilter
            handle::Ptr{GObject}
            function GtkEveryFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEveryFilterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkEveryFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkEveryFilterLeaf, args))
            end
            w = GtkEveryFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkEveryFilter] = GtkEveryFilterLeaf
        function GtkEveryFilter(args...; kwargs...)
            GtkEveryFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkExpander <: GtkWidget end
    end
    begin
        mutable struct GtkExpanderLeaf <: GtkExpander
            handle::Ptr{GObject}
            function GtkExpanderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkExpanderLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkExpanderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkExpanderLeaf, args))
            end
            w = GtkExpanderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkExpander] = GtkExpanderLeaf
        function GtkExpander(args...; kwargs...)
            GtkExpanderLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFileChooserDialog <: GtkDialog end
    end
    begin
        mutable struct GtkFileChooserDialogLeaf <: GtkFileChooserDialog
            handle::Ptr{GObject}
            function GtkFileChooserDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileChooserDialogLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFileChooserDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFileChooserDialogLeaf, args))
            end
            w = GtkFileChooserDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFileChooserDialog] = GtkFileChooserDialogLeaf
        function GtkFileChooserDialog(args...; kwargs...)
            GtkFileChooserDialogLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNativeDialog <: GObject end
    end
    begin
        mutable struct GtkNativeDialogLeaf <: GtkNativeDialog
            handle::Ptr{GObject}
            function GtkNativeDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNativeDialogLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNativeDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNativeDialogLeaf, args))
            end
            w = GtkNativeDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNativeDialog] = GtkNativeDialogLeaf
        function GtkNativeDialog(args...; kwargs...)
            GtkNativeDialogLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFileChooserNative <: GtkNativeDialog end
    end
    begin
        mutable struct GtkFileChooserNativeLeaf <: GtkFileChooserNative
            handle::Ptr{GObject}
            function GtkFileChooserNativeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileChooserNativeLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFileChooserNativeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFileChooserNativeLeaf, args))
            end
            w = GtkFileChooserNativeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFileChooserNative] = GtkFileChooserNativeLeaf
        function GtkFileChooserNative(args...; kwargs...)
            GtkFileChooserNativeLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFileChooserWidget <: GtkWidget end
    end
    begin
        mutable struct GtkFileChooserWidgetLeaf <: GtkFileChooserWidget
            handle::Ptr{GObject}
            function GtkFileChooserWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileChooserWidgetLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFileChooserWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFileChooserWidgetLeaf, args))
            end
            w = GtkFileChooserWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFileChooserWidget] = GtkFileChooserWidgetLeaf
        function GtkFileChooserWidget(args...; kwargs...)
            GtkFileChooserWidgetLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFileFilter <: GtkFilter end
    end
    begin
        mutable struct GtkFileFilterLeaf <: GtkFileFilter
            handle::Ptr{GObject}
            function GtkFileFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileFilterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFileFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFileFilterLeaf, args))
            end
            w = GtkFileFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFileFilter] = GtkFileFilterLeaf
        function GtkFileFilter(args...; kwargs...)
            GtkFileFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFilterListModel <: GObject end
    end
    begin
        mutable struct GtkFilterListModelLeaf <: GtkFilterListModel
            handle::Ptr{GObject}
            function GtkFilterListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFilterListModelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFilterListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFilterListModelLeaf, args))
            end
            w = GtkFilterListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFilterListModel] = GtkFilterListModelLeaf
        function GtkFilterListModel(args...; kwargs...)
            GtkFilterListModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFixed <: GtkWidget end
    end
    begin
        mutable struct GtkFixedLeaf <: GtkFixed
            handle::Ptr{GObject}
            function GtkFixedLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFixedLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFixedLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFixedLeaf, args))
            end
            w = GtkFixedLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFixed] = GtkFixedLeaf
        function GtkFixed(args...; kwargs...)
            GtkFixedLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFixedLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkFixedLayoutLeaf <: GtkFixedLayout
            handle::Ptr{GObject}
            function GtkFixedLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFixedLayoutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFixedLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFixedLayoutLeaf, args))
            end
            w = GtkFixedLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFixedLayout] = GtkFixedLayoutLeaf
        function GtkFixedLayout(args...; kwargs...)
            GtkFixedLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFixedLayoutChild <: GtkLayoutChild end
    end
    begin
        mutable struct GtkFixedLayoutChildLeaf <: GtkFixedLayoutChild
            handle::Ptr{GObject}
            function GtkFixedLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFixedLayoutChildLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFixedLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFixedLayoutChildLeaf, args))
            end
            w = GtkFixedLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFixedLayoutChild] = GtkFixedLayoutChildLeaf
        function GtkFixedLayoutChild(args...; kwargs...)
            GtkFixedLayoutChildLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFlattenListModel <: GObject end
    end
    begin
        mutable struct GtkFlattenListModelLeaf <: GtkFlattenListModel
            handle::Ptr{GObject}
            function GtkFlattenListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFlattenListModelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFlattenListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFlattenListModelLeaf, args))
            end
            w = GtkFlattenListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFlattenListModel] = GtkFlattenListModelLeaf
        function GtkFlattenListModel(args...; kwargs...)
            GtkFlattenListModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFlowBox <: GtkWidget end
    end
    begin
        mutable struct GtkFlowBoxLeaf <: GtkFlowBox
            handle::Ptr{GObject}
            function GtkFlowBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFlowBoxLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFlowBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFlowBoxLeaf, args))
            end
            w = GtkFlowBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFlowBox] = GtkFlowBoxLeaf
        function GtkFlowBox(args...; kwargs...)
            GtkFlowBoxLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFlowBoxChild <: GtkWidget end
    end
    begin
        mutable struct GtkFlowBoxChildLeaf <: GtkFlowBoxChild
            handle::Ptr{GObject}
            function GtkFlowBoxChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFlowBoxChildLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFlowBoxChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFlowBoxChildLeaf, args))
            end
            w = GtkFlowBoxChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFlowBoxChild] = GtkFlowBoxChildLeaf
        function GtkFlowBoxChild(args...; kwargs...)
            GtkFlowBoxChildLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFontButton <: GtkWidget end
    end
    begin
        mutable struct GtkFontButtonLeaf <: GtkFontButton
            handle::Ptr{GObject}
            function GtkFontButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFontButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFontButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFontButtonLeaf, args))
            end
            w = GtkFontButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFontButton] = GtkFontButtonLeaf
        function GtkFontButton(args...; kwargs...)
            GtkFontButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFontChooserDialog <: GtkDialog end
    end
    begin
        mutable struct GtkFontChooserDialogLeaf <: GtkFontChooserDialog
            handle::Ptr{GObject}
            function GtkFontChooserDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFontChooserDialogLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFontChooserDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFontChooserDialogLeaf, args))
            end
            w = GtkFontChooserDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFontChooserDialog] = GtkFontChooserDialogLeaf
        function GtkFontChooserDialog(args...; kwargs...)
            GtkFontChooserDialogLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFontChooserWidget <: GtkWidget end
    end
    begin
        mutable struct GtkFontChooserWidgetLeaf <: GtkFontChooserWidget
            handle::Ptr{GObject}
            function GtkFontChooserWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFontChooserWidgetLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFontChooserWidgetLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFontChooserWidgetLeaf, args))
            end
            w = GtkFontChooserWidgetLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFontChooserWidget] = GtkFontChooserWidgetLeaf
        function GtkFontChooserWidget(args...; kwargs...)
            GtkFontChooserWidgetLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkFrame <: GtkWidget end
    end
    begin
        mutable struct GtkFrameLeaf <: GtkFrame
            handle::Ptr{GObject}
            function GtkFrameLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFrameLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkFrameLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkFrameLeaf, args))
            end
            w = GtkFrameLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkFrame] = GtkFrameLeaf
        function GtkFrame(args...; kwargs...)
            GtkFrameLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGLArea <: GtkWidget end
    end
    begin
        mutable struct GtkGLAreaLeaf <: GtkGLArea
            handle::Ptr{GObject}
            function GtkGLAreaLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGLAreaLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGLAreaLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGLAreaLeaf, args))
            end
            w = GtkGLAreaLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGLArea] = GtkGLAreaLeaf
        function GtkGLArea(args...; kwargs...)
            GtkGLAreaLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGestureClick <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureClickLeaf <: GtkGestureClick
            handle::Ptr{GObject}
            function GtkGestureClickLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureClickLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureClickLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureClickLeaf, args))
            end
            w = GtkGestureClickLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureClick] = GtkGestureClickLeaf
        function GtkGestureClick(args...; kwargs...)
            GtkGestureClickLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGestureDrag <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureDragLeaf <: GtkGestureDrag
            handle::Ptr{GObject}
            function GtkGestureDragLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureDragLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureDragLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureDragLeaf, args))
            end
            w = GtkGestureDragLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureDrag] = GtkGestureDragLeaf
        function GtkGestureDrag(args...; kwargs...)
            GtkGestureDragLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGestureLongPress <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureLongPressLeaf <: GtkGestureLongPress
            handle::Ptr{GObject}
            function GtkGestureLongPressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureLongPressLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureLongPressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureLongPressLeaf, args))
            end
            w = GtkGestureLongPressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureLongPress] = GtkGestureLongPressLeaf
        function GtkGestureLongPress(args...; kwargs...)
            GtkGestureLongPressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGesturePan <: GtkGestureDrag end
    end
    begin
        mutable struct GtkGesturePanLeaf <: GtkGesturePan
            handle::Ptr{GObject}
            function GtkGesturePanLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGesturePanLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGesturePanLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGesturePanLeaf, args))
            end
            w = GtkGesturePanLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGesturePan] = GtkGesturePanLeaf
        function GtkGesturePan(args...; kwargs...)
            GtkGesturePanLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGestureRotate <: GtkGesture end
    end
    begin
        mutable struct GtkGestureRotateLeaf <: GtkGestureRotate
            handle::Ptr{GObject}
            function GtkGestureRotateLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureRotateLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureRotateLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureRotateLeaf, args))
            end
            w = GtkGestureRotateLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureRotate] = GtkGestureRotateLeaf
        function GtkGestureRotate(args...; kwargs...)
            GtkGestureRotateLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGestureStylus <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureStylusLeaf <: GtkGestureStylus
            handle::Ptr{GObject}
            function GtkGestureStylusLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureStylusLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureStylusLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureStylusLeaf, args))
            end
            w = GtkGestureStylusLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureStylus] = GtkGestureStylusLeaf
        function GtkGestureStylus(args...; kwargs...)
            GtkGestureStylusLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGestureSwipe <: GtkGestureSingle end
    end
    begin
        mutable struct GtkGestureSwipeLeaf <: GtkGestureSwipe
            handle::Ptr{GObject}
            function GtkGestureSwipeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureSwipeLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureSwipeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureSwipeLeaf, args))
            end
            w = GtkGestureSwipeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureSwipe] = GtkGestureSwipeLeaf
        function GtkGestureSwipe(args...; kwargs...)
            GtkGestureSwipeLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGestureZoom <: GtkGesture end
    end
    begin
        mutable struct GtkGestureZoomLeaf <: GtkGestureZoom
            handle::Ptr{GObject}
            function GtkGestureZoomLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureZoomLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGestureZoomLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGestureZoomLeaf, args))
            end
            w = GtkGestureZoomLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGestureZoom] = GtkGestureZoomLeaf
        function GtkGestureZoom(args...; kwargs...)
            GtkGestureZoomLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGrid <: GtkWidget end
    end
    begin
        mutable struct GtkGridLeaf <: GtkGrid
            handle::Ptr{GObject}
            function GtkGridLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGridLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGridLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGridLeaf, args))
            end
            w = GtkGridLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGrid] = GtkGridLeaf
        function GtkGrid(args...; kwargs...)
            GtkGridLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGridLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkGridLayoutLeaf <: GtkGridLayout
            handle::Ptr{GObject}
            function GtkGridLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGridLayoutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGridLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGridLayoutLeaf, args))
            end
            w = GtkGridLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGridLayout] = GtkGridLayoutLeaf
        function GtkGridLayout(args...; kwargs...)
            GtkGridLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGridLayoutChild <: GtkLayoutChild end
    end
    begin
        mutable struct GtkGridLayoutChildLeaf <: GtkGridLayoutChild
            handle::Ptr{GObject}
            function GtkGridLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGridLayoutChildLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGridLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGridLayoutChildLeaf, args))
            end
            w = GtkGridLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGridLayoutChild] = GtkGridLayoutChildLeaf
        function GtkGridLayoutChild(args...; kwargs...)
            GtkGridLayoutChildLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkListBase <: GtkWidget end
    end
    begin
        mutable struct GtkListBaseLeaf <: GtkListBase
            handle::Ptr{GObject}
            function GtkListBaseLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListBaseLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListBaseLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListBaseLeaf, args))
            end
            w = GtkListBaseLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListBase] = GtkListBaseLeaf
        function GtkListBase(args...; kwargs...)
            GtkListBaseLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkGridView <: GtkListBase end
    end
    begin
        mutable struct GtkGridViewLeaf <: GtkGridView
            handle::Ptr{GObject}
            function GtkGridViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGridViewLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkGridViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkGridViewLeaf, args))
            end
            w = GtkGridViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkGridView] = GtkGridViewLeaf
        function GtkGridView(args...; kwargs...)
            GtkGridViewLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkHeaderBar <: GtkWidget end
    end
    begin
        mutable struct GtkHeaderBarLeaf <: GtkHeaderBar
            handle::Ptr{GObject}
            function GtkHeaderBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkHeaderBarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkHeaderBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkHeaderBarLeaf, args))
            end
            w = GtkHeaderBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkHeaderBar] = GtkHeaderBarLeaf
        function GtkHeaderBar(args...; kwargs...)
            GtkHeaderBarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkIMContext <: GObject end
    end
    begin
        mutable struct GtkIMContextLeaf <: GtkIMContext
            handle::Ptr{GObject}
            function GtkIMContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIMContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIMContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIMContextLeaf, args))
            end
            w = GtkIMContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIMContext] = GtkIMContextLeaf
        function GtkIMContext(args...; kwargs...)
            GtkIMContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkIMContextSimple <: GtkIMContext end
    end
    begin
        mutable struct GtkIMContextSimpleLeaf <: GtkIMContextSimple
            handle::Ptr{GObject}
            function GtkIMContextSimpleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIMContextSimpleLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIMContextSimpleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIMContextSimpleLeaf, args))
            end
            w = GtkIMContextSimpleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIMContextSimple] = GtkIMContextSimpleLeaf
        function GtkIMContextSimple(args...; kwargs...)
            GtkIMContextSimpleLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkIMMulticontext <: GtkIMContext end
    end
    begin
        mutable struct GtkIMMulticontextLeaf <: GtkIMMulticontext
            handle::Ptr{GObject}
            function GtkIMMulticontextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIMMulticontextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIMMulticontextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIMMulticontextLeaf, args))
            end
            w = GtkIMMulticontextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIMMulticontext] = GtkIMMulticontextLeaf
        function GtkIMMulticontext(args...; kwargs...)
            GtkIMMulticontextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkIconPaintable <: GObject end
    end
    begin
        mutable struct GtkIconPaintableLeaf <: GtkIconPaintable
            handle::Ptr{GObject}
            function GtkIconPaintableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIconPaintableLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIconPaintableLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIconPaintableLeaf, args))
            end
            w = GtkIconPaintableLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIconPaintable] = GtkIconPaintableLeaf
        function GtkIconPaintable(args...; kwargs...)
            GtkIconPaintableLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkIconTheme <: GObject end
    end
    begin
        mutable struct GtkIconThemeLeaf <: GtkIconTheme
            handle::Ptr{GObject}
            function GtkIconThemeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIconThemeLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIconThemeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIconThemeLeaf, args))
            end
            w = GtkIconThemeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIconTheme] = GtkIconThemeLeaf
        function GtkIconTheme(args...; kwargs...)
            GtkIconThemeLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkIconView <: GtkWidget end
    end
    begin
        mutable struct GtkIconViewLeaf <: GtkIconView
            handle::Ptr{GObject}
            function GtkIconViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIconViewLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkIconViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkIconViewLeaf, args))
            end
            w = GtkIconViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkIconView] = GtkIconViewLeaf
        function GtkIconView(args...; kwargs...)
            GtkIconViewLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkImage <: GtkWidget end
    end
    begin
        mutable struct GtkImageLeaf <: GtkImage
            handle::Ptr{GObject}
            function GtkImageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkImageLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkImageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkImageLeaf, args))
            end
            w = GtkImageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkImage] = GtkImageLeaf
        function GtkImage(args...; kwargs...)
            GtkImageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkInfoBar <: GtkWidget end
    end
    begin
        mutable struct GtkInfoBarLeaf <: GtkInfoBar
            handle::Ptr{GObject}
            function GtkInfoBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkInfoBarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkInfoBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkInfoBarLeaf, args))
            end
            w = GtkInfoBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkInfoBar] = GtkInfoBarLeaf
        function GtkInfoBar(args...; kwargs...)
            GtkInfoBarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkKeyvalTrigger <: GtkShortcutTrigger end
    end
    begin
        mutable struct GtkKeyvalTriggerLeaf <: GtkKeyvalTrigger
            handle::Ptr{GObject}
            function GtkKeyvalTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkKeyvalTriggerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkKeyvalTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkKeyvalTriggerLeaf, args))
            end
            w = GtkKeyvalTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkKeyvalTrigger] = GtkKeyvalTriggerLeaf
        function GtkKeyvalTrigger(args...; kwargs...)
            GtkKeyvalTriggerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkLabel <: GtkWidget end
    end
    begin
        mutable struct GtkLabelLeaf <: GtkLabel
            handle::Ptr{GObject}
            function GtkLabelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLabelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLabelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLabelLeaf, args))
            end
            w = GtkLabelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLabel] = GtkLabelLeaf
        function GtkLabel(args...; kwargs...)
            GtkLabelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkLevelBar <: GtkWidget end
    end
    begin
        mutable struct GtkLevelBarLeaf <: GtkLevelBar
            handle::Ptr{GObject}
            function GtkLevelBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLevelBarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLevelBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLevelBarLeaf, args))
            end
            w = GtkLevelBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLevelBar] = GtkLevelBarLeaf
        function GtkLevelBar(args...; kwargs...)
            GtkLevelBarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkLinkButton <: GtkButton end
    end
    begin
        mutable struct GtkLinkButtonLeaf <: GtkLinkButton
            handle::Ptr{GObject}
            function GtkLinkButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLinkButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLinkButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLinkButtonLeaf, args))
            end
            w = GtkLinkButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLinkButton] = GtkLinkButtonLeaf
        function GtkLinkButton(args...; kwargs...)
            GtkLinkButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkListBox <: GtkWidget end
    end
    begin
        mutable struct GtkListBoxLeaf <: GtkListBox
            handle::Ptr{GObject}
            function GtkListBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListBoxLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListBoxLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListBoxLeaf, args))
            end
            w = GtkListBoxLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListBox] = GtkListBoxLeaf
        function GtkListBox(args...; kwargs...)
            GtkListBoxLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkListBoxRow <: GtkWidget end
    end
    begin
        mutable struct GtkListBoxRowLeaf <: GtkListBoxRow
            handle::Ptr{GObject}
            function GtkListBoxRowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListBoxRowLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListBoxRowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListBoxRowLeaf, args))
            end
            w = GtkListBoxRowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListBoxRow] = GtkListBoxRowLeaf
        function GtkListBoxRow(args...; kwargs...)
            GtkListBoxRowLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkListItem <: GObject end
    end
    begin
        mutable struct GtkListItemLeaf <: GtkListItem
            handle::Ptr{GObject}
            function GtkListItemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListItemLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListItemLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListItemLeaf, args))
            end
            w = GtkListItemLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListItem] = GtkListItemLeaf
        function GtkListItem(args...; kwargs...)
            GtkListItemLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkListStore <: GObject end
    end
    begin
        mutable struct GtkListStoreLeaf <: GtkListStore
            handle::Ptr{GObject}
            function GtkListStoreLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListStoreLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListStoreLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListStoreLeaf, args))
            end
            w = GtkListStoreLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListStore] = GtkListStoreLeaf
        function GtkListStore(args...; kwargs...)
            GtkListStoreLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkListView <: GtkListBase end
    end
    begin
        mutable struct GtkListViewLeaf <: GtkListView
            handle::Ptr{GObject}
            function GtkListViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListViewLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkListViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkListViewLeaf, args))
            end
            w = GtkListViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkListView] = GtkListViewLeaf
        function GtkListView(args...; kwargs...)
            GtkListViewLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkLockButton <: GtkButton end
    end
    begin
        mutable struct GtkLockButtonLeaf <: GtkLockButton
            handle::Ptr{GObject}
            function GtkLockButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLockButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkLockButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkLockButtonLeaf, args))
            end
            w = GtkLockButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkLockButton] = GtkLockButtonLeaf
        function GtkLockButton(args...; kwargs...)
            GtkLockButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMapListModel <: GObject end
    end
    begin
        mutable struct GtkMapListModelLeaf <: GtkMapListModel
            handle::Ptr{GObject}
            function GtkMapListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMapListModelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMapListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMapListModelLeaf, args))
            end
            w = GtkMapListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMapListModel] = GtkMapListModelLeaf
        function GtkMapListModel(args...; kwargs...)
            GtkMapListModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMediaControls <: GtkWidget end
    end
    begin
        mutable struct GtkMediaControlsLeaf <: GtkMediaControls
            handle::Ptr{GObject}
            function GtkMediaControlsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMediaControlsLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMediaControlsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMediaControlsLeaf, args))
            end
            w = GtkMediaControlsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMediaControls] = GtkMediaControlsLeaf
        function GtkMediaControls(args...; kwargs...)
            GtkMediaControlsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMediaStream <: GObject end
    end
    begin
        mutable struct GtkMediaStreamLeaf <: GtkMediaStream
            handle::Ptr{GObject}
            function GtkMediaStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMediaStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMediaStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMediaStreamLeaf, args))
            end
            w = GtkMediaStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMediaStream] = GtkMediaStreamLeaf
        function GtkMediaStream(args...; kwargs...)
            GtkMediaStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMediaFile <: GtkMediaStream end
    end
    begin
        mutable struct GtkMediaFileLeaf <: GtkMediaFile
            handle::Ptr{GObject}
            function GtkMediaFileLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMediaFileLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMediaFileLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMediaFileLeaf, args))
            end
            w = GtkMediaFileLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMediaFile] = GtkMediaFileLeaf
        function GtkMediaFile(args...; kwargs...)
            GtkMediaFileLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMenuButton <: GtkWidget end
    end
    begin
        mutable struct GtkMenuButtonLeaf <: GtkMenuButton
            handle::Ptr{GObject}
            function GtkMenuButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMenuButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMenuButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMenuButtonLeaf, args))
            end
            w = GtkMenuButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMenuButton] = GtkMenuButtonLeaf
        function GtkMenuButton(args...; kwargs...)
            GtkMenuButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMessageDialog <: GtkDialog end
    end
    begin
        mutable struct GtkMessageDialogLeaf <: GtkMessageDialog
            handle::Ptr{GObject}
            function GtkMessageDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMessageDialogLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMessageDialogLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMessageDialogLeaf, args))
            end
            w = GtkMessageDialogLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMessageDialog] = GtkMessageDialogLeaf
        function GtkMessageDialog(args...; kwargs...)
            GtkMessageDialogLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMnemonicAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkMnemonicActionLeaf <: GtkMnemonicAction
            handle::Ptr{GObject}
            function GtkMnemonicActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMnemonicActionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMnemonicActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMnemonicActionLeaf, args))
            end
            w = GtkMnemonicActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMnemonicAction] = GtkMnemonicActionLeaf
        function GtkMnemonicAction(args...; kwargs...)
            GtkMnemonicActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMnemonicTrigger <: GtkShortcutTrigger end
    end
    begin
        mutable struct GtkMnemonicTriggerLeaf <: GtkMnemonicTrigger
            handle::Ptr{GObject}
            function GtkMnemonicTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMnemonicTriggerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMnemonicTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMnemonicTriggerLeaf, args))
            end
            w = GtkMnemonicTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMnemonicTrigger] = GtkMnemonicTriggerLeaf
        function GtkMnemonicTrigger(args...; kwargs...)
            GtkMnemonicTriggerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMountOperation <: GMountOperation end
    end
    begin
        mutable struct GtkMountOperationLeaf <: GtkMountOperation
            handle::Ptr{GObject}
            function GtkMountOperationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMountOperationLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMountOperationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMountOperationLeaf, args))
            end
            w = GtkMountOperationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMountOperation] = GtkMountOperationLeaf
        function GtkMountOperation(args...; kwargs...)
            GtkMountOperationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMultiSelection <: GObject end
    end
    begin
        mutable struct GtkMultiSelectionLeaf <: GtkMultiSelection
            handle::Ptr{GObject}
            function GtkMultiSelectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMultiSelectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMultiSelectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMultiSelectionLeaf, args))
            end
            w = GtkMultiSelectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMultiSelection] = GtkMultiSelectionLeaf
        function GtkMultiSelection(args...; kwargs...)
            GtkMultiSelectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkMultiSorter <: GtkSorter end
    end
    begin
        mutable struct GtkMultiSorterLeaf <: GtkMultiSorter
            handle::Ptr{GObject}
            function GtkMultiSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMultiSorterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkMultiSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkMultiSorterLeaf, args))
            end
            w = GtkMultiSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkMultiSorter] = GtkMultiSorterLeaf
        function GtkMultiSorter(args...; kwargs...)
            GtkMultiSorterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNamedAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkNamedActionLeaf <: GtkNamedAction
            handle::Ptr{GObject}
            function GtkNamedActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNamedActionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNamedActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNamedActionLeaf, args))
            end
            w = GtkNamedActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNamedAction] = GtkNamedActionLeaf
        function GtkNamedAction(args...; kwargs...)
            GtkNamedActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNeverTrigger <: GtkShortcutTrigger end
    end
    begin
        mutable struct GtkNeverTriggerLeaf <: GtkNeverTrigger
            handle::Ptr{GObject}
            function GtkNeverTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNeverTriggerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNeverTriggerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNeverTriggerLeaf, args))
            end
            w = GtkNeverTriggerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNeverTrigger] = GtkNeverTriggerLeaf
        function GtkNeverTrigger(args...; kwargs...)
            GtkNeverTriggerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNoSelection <: GObject end
    end
    begin
        mutable struct GtkNoSelectionLeaf <: GtkNoSelection
            handle::Ptr{GObject}
            function GtkNoSelectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNoSelectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNoSelectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNoSelectionLeaf, args))
            end
            w = GtkNoSelectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNoSelection] = GtkNoSelectionLeaf
        function GtkNoSelection(args...; kwargs...)
            GtkNoSelectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNotebook <: GtkWidget end
    end
    begin
        mutable struct GtkNotebookLeaf <: GtkNotebook
            handle::Ptr{GObject}
            function GtkNotebookLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNotebookLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNotebookLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNotebookLeaf, args))
            end
            w = GtkNotebookLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNotebook] = GtkNotebookLeaf
        function GtkNotebook(args...; kwargs...)
            GtkNotebookLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNotebookPage <: GObject end
    end
    begin
        mutable struct GtkNotebookPageLeaf <: GtkNotebookPage
            handle::Ptr{GObject}
            function GtkNotebookPageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNotebookPageLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNotebookPageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNotebookPageLeaf, args))
            end
            w = GtkNotebookPageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNotebookPage] = GtkNotebookPageLeaf
        function GtkNotebookPage(args...; kwargs...)
            GtkNotebookPageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNothingAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkNothingActionLeaf <: GtkNothingAction
            handle::Ptr{GObject}
            function GtkNothingActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNothingActionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNothingActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNothingActionLeaf, args))
            end
            w = GtkNothingActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNothingAction] = GtkNothingActionLeaf
        function GtkNothingAction(args...; kwargs...)
            GtkNothingActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkNumericSorter <: GtkSorter end
    end
    begin
        mutable struct GtkNumericSorterLeaf <: GtkNumericSorter
            handle::Ptr{GObject}
            function GtkNumericSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNumericSorterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkNumericSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkNumericSorterLeaf, args))
            end
            w = GtkNumericSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkNumericSorter] = GtkNumericSorterLeaf
        function GtkNumericSorter(args...; kwargs...)
            GtkNumericSorterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkOverlay <: GtkWidget end
    end
    begin
        mutable struct GtkOverlayLeaf <: GtkOverlay
            handle::Ptr{GObject}
            function GtkOverlayLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkOverlayLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkOverlayLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkOverlayLeaf, args))
            end
            w = GtkOverlayLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkOverlay] = GtkOverlayLeaf
        function GtkOverlay(args...; kwargs...)
            GtkOverlayLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkOverlayLayout <: GtkLayoutManager end
    end
    begin
        mutable struct GtkOverlayLayoutLeaf <: GtkOverlayLayout
            handle::Ptr{GObject}
            function GtkOverlayLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkOverlayLayoutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkOverlayLayoutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkOverlayLayoutLeaf, args))
            end
            w = GtkOverlayLayoutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkOverlayLayout] = GtkOverlayLayoutLeaf
        function GtkOverlayLayout(args...; kwargs...)
            GtkOverlayLayoutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkOverlayLayoutChild <: GtkLayoutChild end
    end
    begin
        mutable struct GtkOverlayLayoutChildLeaf <: GtkOverlayLayoutChild
            handle::Ptr{GObject}
            function GtkOverlayLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkOverlayLayoutChildLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkOverlayLayoutChildLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkOverlayLayoutChildLeaf, args))
            end
            w = GtkOverlayLayoutChildLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkOverlayLayoutChild] = GtkOverlayLayoutChildLeaf
        function GtkOverlayLayoutChild(args...; kwargs...)
            GtkOverlayLayoutChildLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPadController <: GtkEventController end
    end
    begin
        mutable struct GtkPadControllerLeaf <: GtkPadController
            handle::Ptr{GObject}
            function GtkPadControllerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPadControllerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPadControllerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPadControllerLeaf, args))
            end
            w = GtkPadControllerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPadController] = GtkPadControllerLeaf
        function GtkPadController(args...; kwargs...)
            GtkPadControllerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPageSetup <: GObject end
    end
    begin
        mutable struct GtkPageSetupLeaf <: GtkPageSetup
            handle::Ptr{GObject}
            function GtkPageSetupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPageSetupLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPageSetupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPageSetupLeaf, args))
            end
            w = GtkPageSetupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPageSetup] = GtkPageSetupLeaf
        function GtkPageSetup(args...; kwargs...)
            GtkPageSetupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPaned <: GtkWidget end
    end
    begin
        mutable struct GtkPanedLeaf <: GtkPaned
            handle::Ptr{GObject}
            function GtkPanedLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPanedLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPanedLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPanedLeaf, args))
            end
            w = GtkPanedLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPaned] = GtkPanedLeaf
        function GtkPaned(args...; kwargs...)
            GtkPanedLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPasswordEntry <: GtkWidget end
    end
    begin
        mutable struct GtkPasswordEntryLeaf <: GtkPasswordEntry
            handle::Ptr{GObject}
            function GtkPasswordEntryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPasswordEntryLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPasswordEntryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPasswordEntryLeaf, args))
            end
            w = GtkPasswordEntryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPasswordEntry] = GtkPasswordEntryLeaf
        function GtkPasswordEntry(args...; kwargs...)
            GtkPasswordEntryLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPasswordEntryBuffer <: GtkEntryBuffer end
    end
    begin
        mutable struct GtkPasswordEntryBufferLeaf <: GtkPasswordEntryBuffer
            handle::Ptr{GObject}
            function GtkPasswordEntryBufferLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPasswordEntryBufferLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPasswordEntryBufferLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPasswordEntryBufferLeaf, args))
            end
            w = GtkPasswordEntryBufferLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPasswordEntryBuffer] = GtkPasswordEntryBufferLeaf
        function GtkPasswordEntryBuffer(args...; kwargs...)
            GtkPasswordEntryBufferLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPicture <: GtkWidget end
    end
    begin
        mutable struct GtkPictureLeaf <: GtkPicture
            handle::Ptr{GObject}
            function GtkPictureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPictureLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPictureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPictureLeaf, args))
            end
            w = GtkPictureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPicture] = GtkPictureLeaf
        function GtkPicture(args...; kwargs...)
            GtkPictureLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPopoverMenu <: GtkPopover end
    end
    begin
        mutable struct GtkPopoverMenuLeaf <: GtkPopoverMenu
            handle::Ptr{GObject}
            function GtkPopoverMenuLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPopoverMenuLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPopoverMenuLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPopoverMenuLeaf, args))
            end
            w = GtkPopoverMenuLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPopoverMenu] = GtkPopoverMenuLeaf
        function GtkPopoverMenu(args...; kwargs...)
            GtkPopoverMenuLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPopoverMenuBar <: GtkWidget end
    end
    begin
        mutable struct GtkPopoverMenuBarLeaf <: GtkPopoverMenuBar
            handle::Ptr{GObject}
            function GtkPopoverMenuBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPopoverMenuBarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPopoverMenuBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPopoverMenuBarLeaf, args))
            end
            w = GtkPopoverMenuBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPopoverMenuBar] = GtkPopoverMenuBarLeaf
        function GtkPopoverMenuBar(args...; kwargs...)
            GtkPopoverMenuBarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPrintContext <: GObject end
    end
    begin
        mutable struct GtkPrintContextLeaf <: GtkPrintContext
            handle::Ptr{GObject}
            function GtkPrintContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrintContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrintContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrintContextLeaf, args))
            end
            w = GtkPrintContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrintContext] = GtkPrintContextLeaf
        function GtkPrintContext(args...; kwargs...)
            GtkPrintContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPrintJob <: GObject end
    end
    begin
        mutable struct GtkPrintJobLeaf <: GtkPrintJob
            handle::Ptr{GObject}
            function GtkPrintJobLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrintJobLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrintJobLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrintJobLeaf, args))
            end
            w = GtkPrintJobLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrintJob] = GtkPrintJobLeaf
        function GtkPrintJob(args...; kwargs...)
            GtkPrintJobLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPrintOperation <: GObject end
    end
    begin
        mutable struct GtkPrintOperationLeaf <: GtkPrintOperation
            handle::Ptr{GObject}
            function GtkPrintOperationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrintOperationLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrintOperationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrintOperationLeaf, args))
            end
            w = GtkPrintOperationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrintOperation] = GtkPrintOperationLeaf
        function GtkPrintOperation(args...; kwargs...)
            GtkPrintOperationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPrintSettings <: GObject end
    end
    begin
        mutable struct GtkPrintSettingsLeaf <: GtkPrintSettings
            handle::Ptr{GObject}
            function GtkPrintSettingsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrintSettingsLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrintSettingsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrintSettingsLeaf, args))
            end
            w = GtkPrintSettingsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrintSettings] = GtkPrintSettingsLeaf
        function GtkPrintSettings(args...; kwargs...)
            GtkPrintSettingsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkPrinter <: GObject end
    end
    begin
        mutable struct GtkPrinterLeaf <: GtkPrinter
            handle::Ptr{GObject}
            function GtkPrinterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrinterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkPrinterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkPrinterLeaf, args))
            end
            w = GtkPrinterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkPrinter] = GtkPrinterLeaf
        function GtkPrinter(args...; kwargs...)
            GtkPrinterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkProgressBar <: GtkWidget end
    end
    begin
        mutable struct GtkProgressBarLeaf <: GtkProgressBar
            handle::Ptr{GObject}
            function GtkProgressBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkProgressBarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkProgressBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkProgressBarLeaf, args))
            end
            w = GtkProgressBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkProgressBar] = GtkProgressBarLeaf
        function GtkProgressBar(args...; kwargs...)
            GtkProgressBarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkRange <: GtkWidget end
    end
    begin
        mutable struct GtkRangeLeaf <: GtkRange
            handle::Ptr{GObject}
            function GtkRangeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkRangeLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkRangeLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkRangeLeaf, args))
            end
            w = GtkRangeLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkRange] = GtkRangeLeaf
        function GtkRange(args...; kwargs...)
            GtkRangeLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkRecentManager <: GObject end
    end
    begin
        mutable struct GtkRecentManagerLeaf <: GtkRecentManager
            handle::Ptr{GObject}
            function GtkRecentManagerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkRecentManagerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkRecentManagerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkRecentManagerLeaf, args))
            end
            w = GtkRecentManagerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkRecentManager] = GtkRecentManagerLeaf
        function GtkRecentManager(args...; kwargs...)
            GtkRecentManagerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkRevealer <: GtkWidget end
    end
    begin
        mutable struct GtkRevealerLeaf <: GtkRevealer
            handle::Ptr{GObject}
            function GtkRevealerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkRevealerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkRevealerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkRevealerLeaf, args))
            end
            w = GtkRevealerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkRevealer] = GtkRevealerLeaf
        function GtkRevealer(args...; kwargs...)
            GtkRevealerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkScale <: GtkRange end
    end
    begin
        mutable struct GtkScaleLeaf <: GtkScale
            handle::Ptr{GObject}
            function GtkScaleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkScaleLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkScaleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkScaleLeaf, args))
            end
            w = GtkScaleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkScale] = GtkScaleLeaf
        function GtkScale(args...; kwargs...)
            GtkScaleLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkScaleButton <: GtkWidget end
    end
    begin
        mutable struct GtkScaleButtonLeaf <: GtkScaleButton
            handle::Ptr{GObject}
            function GtkScaleButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkScaleButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkScaleButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkScaleButtonLeaf, args))
            end
            w = GtkScaleButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkScaleButton] = GtkScaleButtonLeaf
        function GtkScaleButton(args...; kwargs...)
            GtkScaleButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkScrollbar <: GtkWidget end
    end
    begin
        mutable struct GtkScrollbarLeaf <: GtkScrollbar
            handle::Ptr{GObject}
            function GtkScrollbarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkScrollbarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkScrollbarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkScrollbarLeaf, args))
            end
            w = GtkScrollbarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkScrollbar] = GtkScrollbarLeaf
        function GtkScrollbar(args...; kwargs...)
            GtkScrollbarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkScrolledWindow <: GtkWidget end
    end
    begin
        mutable struct GtkScrolledWindowLeaf <: GtkScrolledWindow
            handle::Ptr{GObject}
            function GtkScrolledWindowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkScrolledWindowLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkScrolledWindowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkScrolledWindowLeaf, args))
            end
            w = GtkScrolledWindowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkScrolledWindow] = GtkScrolledWindowLeaf
        function GtkScrolledWindow(args...; kwargs...)
            GtkScrolledWindowLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSearchBar <: GtkWidget end
    end
    begin
        mutable struct GtkSearchBarLeaf <: GtkSearchBar
            handle::Ptr{GObject}
            function GtkSearchBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSearchBarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSearchBarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSearchBarLeaf, args))
            end
            w = GtkSearchBarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSearchBar] = GtkSearchBarLeaf
        function GtkSearchBar(args...; kwargs...)
            GtkSearchBarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSearchEntry <: GtkWidget end
    end
    begin
        mutable struct GtkSearchEntryLeaf <: GtkSearchEntry
            handle::Ptr{GObject}
            function GtkSearchEntryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSearchEntryLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSearchEntryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSearchEntryLeaf, args))
            end
            w = GtkSearchEntryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSearchEntry] = GtkSearchEntryLeaf
        function GtkSearchEntry(args...; kwargs...)
            GtkSearchEntryLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSelectionFilterModel <: GObject end
    end
    begin
        mutable struct GtkSelectionFilterModelLeaf <: GtkSelectionFilterModel
            handle::Ptr{GObject}
            function GtkSelectionFilterModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSelectionFilterModelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSelectionFilterModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSelectionFilterModelLeaf, args))
            end
            w = GtkSelectionFilterModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSelectionFilterModel] = GtkSelectionFilterModelLeaf
        function GtkSelectionFilterModel(args...; kwargs...)
            GtkSelectionFilterModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSeparator <: GtkWidget end
    end
    begin
        mutable struct GtkSeparatorLeaf <: GtkSeparator
            handle::Ptr{GObject}
            function GtkSeparatorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSeparatorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSeparatorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSeparatorLeaf, args))
            end
            w = GtkSeparatorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSeparator] = GtkSeparatorLeaf
        function GtkSeparator(args...; kwargs...)
            GtkSeparatorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSettings <: GObject end
    end
    begin
        mutable struct GtkSettingsLeaf <: GtkSettings
            handle::Ptr{GObject}
            function GtkSettingsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSettingsLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSettingsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSettingsLeaf, args))
            end
            w = GtkSettingsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSettings] = GtkSettingsLeaf
        function GtkSettings(args...; kwargs...)
            GtkSettingsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkShortcut <: GObject end
    end
    begin
        mutable struct GtkShortcutLeaf <: GtkShortcut
            handle::Ptr{GObject}
            function GtkShortcutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutLeaf, args))
            end
            w = GtkShortcutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcut] = GtkShortcutLeaf
        function GtkShortcut(args...; kwargs...)
            GtkShortcutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkShortcutController <: GtkEventController end
    end
    begin
        mutable struct GtkShortcutControllerLeaf <: GtkShortcutController
            handle::Ptr{GObject}
            function GtkShortcutControllerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutControllerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutControllerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutControllerLeaf, args))
            end
            w = GtkShortcutControllerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutController] = GtkShortcutControllerLeaf
        function GtkShortcutController(args...; kwargs...)
            GtkShortcutControllerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkShortcutLabel <: GtkWidget end
    end
    begin
        mutable struct GtkShortcutLabelLeaf <: GtkShortcutLabel
            handle::Ptr{GObject}
            function GtkShortcutLabelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutLabelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutLabelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutLabelLeaf, args))
            end
            w = GtkShortcutLabelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutLabel] = GtkShortcutLabelLeaf
        function GtkShortcutLabel(args...; kwargs...)
            GtkShortcutLabelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkShortcutsGroup <: GtkBox end
    end
    begin
        mutable struct GtkShortcutsGroupLeaf <: GtkShortcutsGroup
            handle::Ptr{GObject}
            function GtkShortcutsGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsGroupLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutsGroupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutsGroupLeaf, args))
            end
            w = GtkShortcutsGroupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutsGroup] = GtkShortcutsGroupLeaf
        function GtkShortcutsGroup(args...; kwargs...)
            GtkShortcutsGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkShortcutsSection <: GtkBox end
    end
    begin
        mutable struct GtkShortcutsSectionLeaf <: GtkShortcutsSection
            handle::Ptr{GObject}
            function GtkShortcutsSectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsSectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutsSectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutsSectionLeaf, args))
            end
            w = GtkShortcutsSectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutsSection] = GtkShortcutsSectionLeaf
        function GtkShortcutsSection(args...; kwargs...)
            GtkShortcutsSectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkShortcutsShortcut <: GtkWidget end
    end
    begin
        mutable struct GtkShortcutsShortcutLeaf <: GtkShortcutsShortcut
            handle::Ptr{GObject}
            function GtkShortcutsShortcutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsShortcutLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutsShortcutLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutsShortcutLeaf, args))
            end
            w = GtkShortcutsShortcutLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutsShortcut] = GtkShortcutsShortcutLeaf
        function GtkShortcutsShortcut(args...; kwargs...)
            GtkShortcutsShortcutLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkShortcutsWindow <: GtkWindow end
    end
    begin
        mutable struct GtkShortcutsWindowLeaf <: GtkShortcutsWindow
            handle::Ptr{GObject}
            function GtkShortcutsWindowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsWindowLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkShortcutsWindowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkShortcutsWindowLeaf, args))
            end
            w = GtkShortcutsWindowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkShortcutsWindow] = GtkShortcutsWindowLeaf
        function GtkShortcutsWindow(args...; kwargs...)
            GtkShortcutsWindowLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSignalAction <: GtkShortcutAction end
    end
    begin
        mutable struct GtkSignalActionLeaf <: GtkSignalAction
            handle::Ptr{GObject}
            function GtkSignalActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSignalActionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSignalActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSignalActionLeaf, args))
            end
            w = GtkSignalActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSignalAction] = GtkSignalActionLeaf
        function GtkSignalAction(args...; kwargs...)
            GtkSignalActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSignalListItemFactory <: GtkListItemFactory end
    end
    begin
        mutable struct GtkSignalListItemFactoryLeaf <: GtkSignalListItemFactory
            handle::Ptr{GObject}
            function GtkSignalListItemFactoryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSignalListItemFactoryLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSignalListItemFactoryLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSignalListItemFactoryLeaf, args))
            end
            w = GtkSignalListItemFactoryLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSignalListItemFactory] = GtkSignalListItemFactoryLeaf
        function GtkSignalListItemFactory(args...; kwargs...)
            GtkSignalListItemFactoryLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSingleSelection <: GObject end
    end
    begin
        mutable struct GtkSingleSelectionLeaf <: GtkSingleSelection
            handle::Ptr{GObject}
            function GtkSingleSelectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSingleSelectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSingleSelectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSingleSelectionLeaf, args))
            end
            w = GtkSingleSelectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSingleSelection] = GtkSingleSelectionLeaf
        function GtkSingleSelection(args...; kwargs...)
            GtkSingleSelectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSizeGroup <: GObject end
    end
    begin
        mutable struct GtkSizeGroupLeaf <: GtkSizeGroup
            handle::Ptr{GObject}
            function GtkSizeGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSizeGroupLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSizeGroupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSizeGroupLeaf, args))
            end
            w = GtkSizeGroupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSizeGroup] = GtkSizeGroupLeaf
        function GtkSizeGroup(args...; kwargs...)
            GtkSizeGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSliceListModel <: GObject end
    end
    begin
        mutable struct GtkSliceListModelLeaf <: GtkSliceListModel
            handle::Ptr{GObject}
            function GtkSliceListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSliceListModelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSliceListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSliceListModelLeaf, args))
            end
            w = GtkSliceListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSliceListModel] = GtkSliceListModelLeaf
        function GtkSliceListModel(args...; kwargs...)
            GtkSliceListModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSnapshot <: GdkSnapshot end
    end
    begin
        mutable struct GtkSnapshotLeaf <: GtkSnapshot
            handle::Ptr{GObject}
            function GtkSnapshotLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSnapshotLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSnapshotLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSnapshotLeaf, args))
            end
            w = GtkSnapshotLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSnapshot] = GtkSnapshotLeaf
        function GtkSnapshot(args...; kwargs...)
            GtkSnapshotLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSortListModel <: GObject end
    end
    begin
        mutable struct GtkSortListModelLeaf <: GtkSortListModel
            handle::Ptr{GObject}
            function GtkSortListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSortListModelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSortListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSortListModelLeaf, args))
            end
            w = GtkSortListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSortListModel] = GtkSortListModelLeaf
        function GtkSortListModel(args...; kwargs...)
            GtkSortListModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSpinButton <: GtkWidget end
    end
    begin
        mutable struct GtkSpinButtonLeaf <: GtkSpinButton
            handle::Ptr{GObject}
            function GtkSpinButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSpinButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSpinButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSpinButtonLeaf, args))
            end
            w = GtkSpinButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSpinButton] = GtkSpinButtonLeaf
        function GtkSpinButton(args...; kwargs...)
            GtkSpinButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSpinner <: GtkWidget end
    end
    begin
        mutable struct GtkSpinnerLeaf <: GtkSpinner
            handle::Ptr{GObject}
            function GtkSpinnerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSpinnerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSpinnerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSpinnerLeaf, args))
            end
            w = GtkSpinnerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSpinner] = GtkSpinnerLeaf
        function GtkSpinner(args...; kwargs...)
            GtkSpinnerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStack <: GtkWidget end
    end
    begin
        mutable struct GtkStackLeaf <: GtkStack
            handle::Ptr{GObject}
            function GtkStackLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStackLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStackLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStackLeaf, args))
            end
            w = GtkStackLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStack] = GtkStackLeaf
        function GtkStack(args...; kwargs...)
            GtkStackLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStackPage <: GObject end
    end
    begin
        mutable struct GtkStackPageLeaf <: GtkStackPage
            handle::Ptr{GObject}
            function GtkStackPageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStackPageLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStackPageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStackPageLeaf, args))
            end
            w = GtkStackPageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStackPage] = GtkStackPageLeaf
        function GtkStackPage(args...; kwargs...)
            GtkStackPageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStackSidebar <: GtkWidget end
    end
    begin
        mutable struct GtkStackSidebarLeaf <: GtkStackSidebar
            handle::Ptr{GObject}
            function GtkStackSidebarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStackSidebarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStackSidebarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStackSidebarLeaf, args))
            end
            w = GtkStackSidebarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStackSidebar] = GtkStackSidebarLeaf
        function GtkStackSidebar(args...; kwargs...)
            GtkStackSidebarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStackSwitcher <: GtkWidget end
    end
    begin
        mutable struct GtkStackSwitcherLeaf <: GtkStackSwitcher
            handle::Ptr{GObject}
            function GtkStackSwitcherLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStackSwitcherLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStackSwitcherLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStackSwitcherLeaf, args))
            end
            w = GtkStackSwitcherLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStackSwitcher] = GtkStackSwitcherLeaf
        function GtkStackSwitcher(args...; kwargs...)
            GtkStackSwitcherLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStatusbar <: GtkWidget end
    end
    begin
        mutable struct GtkStatusbarLeaf <: GtkStatusbar
            handle::Ptr{GObject}
            function GtkStatusbarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStatusbarLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStatusbarLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStatusbarLeaf, args))
            end
            w = GtkStatusbarLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStatusbar] = GtkStatusbarLeaf
        function GtkStatusbar(args...; kwargs...)
            GtkStatusbarLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStringFilter <: GtkFilter end
    end
    begin
        mutable struct GtkStringFilterLeaf <: GtkStringFilter
            handle::Ptr{GObject}
            function GtkStringFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStringFilterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStringFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStringFilterLeaf, args))
            end
            w = GtkStringFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStringFilter] = GtkStringFilterLeaf
        function GtkStringFilter(args...; kwargs...)
            GtkStringFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStringList <: GObject end
    end
    begin
        mutable struct GtkStringListLeaf <: GtkStringList
            handle::Ptr{GObject}
            function GtkStringListLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStringListLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStringListLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStringListLeaf, args))
            end
            w = GtkStringListLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStringList] = GtkStringListLeaf
        function GtkStringList(args...; kwargs...)
            GtkStringListLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStringObject <: GObject end
    end
    begin
        mutable struct GtkStringObjectLeaf <: GtkStringObject
            handle::Ptr{GObject}
            function GtkStringObjectLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStringObjectLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStringObjectLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStringObjectLeaf, args))
            end
            w = GtkStringObjectLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStringObject] = GtkStringObjectLeaf
        function GtkStringObject(args...; kwargs...)
            GtkStringObjectLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStringSorter <: GtkSorter end
    end
    begin
        mutable struct GtkStringSorterLeaf <: GtkStringSorter
            handle::Ptr{GObject}
            function GtkStringSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStringSorterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStringSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStringSorterLeaf, args))
            end
            w = GtkStringSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStringSorter] = GtkStringSorterLeaf
        function GtkStringSorter(args...; kwargs...)
            GtkStringSorterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkStyleContext <: GObject end
    end
    begin
        mutable struct GtkStyleContextLeaf <: GtkStyleContext
            handle::Ptr{GObject}
            function GtkStyleContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStyleContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkStyleContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkStyleContextLeaf, args))
            end
            w = GtkStyleContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkStyleContext] = GtkStyleContextLeaf
        function GtkStyleContext(args...; kwargs...)
            GtkStyleContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkSwitch <: GtkWidget end
    end
    begin
        mutable struct GtkSwitchLeaf <: GtkSwitch
            handle::Ptr{GObject}
            function GtkSwitchLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSwitchLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkSwitchLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkSwitchLeaf, args))
            end
            w = GtkSwitchLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkSwitch] = GtkSwitchLeaf
        function GtkSwitch(args...; kwargs...)
            GtkSwitchLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkText <: GtkWidget end
    end
    begin
        mutable struct GtkTextLeaf <: GtkText
            handle::Ptr{GObject}
            function GtkTextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextLeaf, args))
            end
            w = GtkTextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkText] = GtkTextLeaf
        function GtkText(args...; kwargs...)
            GtkTextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTextBuffer <: GObject end
    end
    begin
        mutable struct GtkTextBufferLeaf <: GtkTextBuffer
            handle::Ptr{GObject}
            function GtkTextBufferLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextBufferLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextBufferLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextBufferLeaf, args))
            end
            w = GtkTextBufferLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextBuffer] = GtkTextBufferLeaf
        function GtkTextBuffer(args...; kwargs...)
            GtkTextBufferLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTextChildAnchor <: GObject end
    end
    begin
        mutable struct GtkTextChildAnchorLeaf <: GtkTextChildAnchor
            handle::Ptr{GObject}
            function GtkTextChildAnchorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextChildAnchorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextChildAnchorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextChildAnchorLeaf, args))
            end
            w = GtkTextChildAnchorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextChildAnchor] = GtkTextChildAnchorLeaf
        function GtkTextChildAnchor(args...; kwargs...)
            GtkTextChildAnchorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTextMark <: GObject end
    end
    begin
        mutable struct GtkTextMarkLeaf <: GtkTextMark
            handle::Ptr{GObject}
            function GtkTextMarkLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextMarkLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextMarkLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextMarkLeaf, args))
            end
            w = GtkTextMarkLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextMark] = GtkTextMarkLeaf
        function GtkTextMark(args...; kwargs...)
            GtkTextMarkLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTextTag <: GObject end
    end
    begin
        mutable struct GtkTextTagLeaf <: GtkTextTag
            handle::Ptr{GObject}
            function GtkTextTagLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextTagLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextTagLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextTagLeaf, args))
            end
            w = GtkTextTagLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextTag] = GtkTextTagLeaf
        function GtkTextTag(args...; kwargs...)
            GtkTextTagLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTextTagTable <: GObject end
    end
    begin
        mutable struct GtkTextTagTableLeaf <: GtkTextTagTable
            handle::Ptr{GObject}
            function GtkTextTagTableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextTagTableLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextTagTableLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextTagTableLeaf, args))
            end
            w = GtkTextTagTableLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextTagTable] = GtkTextTagTableLeaf
        function GtkTextTagTable(args...; kwargs...)
            GtkTextTagTableLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTextView <: GtkWidget end
    end
    begin
        mutable struct GtkTextViewLeaf <: GtkTextView
            handle::Ptr{GObject}
            function GtkTextViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextViewLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTextViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTextViewLeaf, args))
            end
            w = GtkTextViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTextView] = GtkTextViewLeaf
        function GtkTextView(args...; kwargs...)
            GtkTextViewLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkToggleButton <: GtkButton end
    end
    begin
        mutable struct GtkToggleButtonLeaf <: GtkToggleButton
            handle::Ptr{GObject}
            function GtkToggleButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkToggleButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkToggleButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkToggleButtonLeaf, args))
            end
            w = GtkToggleButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkToggleButton] = GtkToggleButtonLeaf
        function GtkToggleButton(args...; kwargs...)
            GtkToggleButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTooltip <: GObject end
    end
    begin
        mutable struct GtkTooltipLeaf <: GtkTooltip
            handle::Ptr{GObject}
            function GtkTooltipLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTooltipLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTooltipLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTooltipLeaf, args))
            end
            w = GtkTooltipLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTooltip] = GtkTooltipLeaf
        function GtkTooltip(args...; kwargs...)
            GtkTooltipLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeExpander <: GtkWidget end
    end
    begin
        mutable struct GtkTreeExpanderLeaf <: GtkTreeExpander
            handle::Ptr{GObject}
            function GtkTreeExpanderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeExpanderLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeExpanderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeExpanderLeaf, args))
            end
            w = GtkTreeExpanderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeExpander] = GtkTreeExpanderLeaf
        function GtkTreeExpander(args...; kwargs...)
            GtkTreeExpanderLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeListModel <: GObject end
    end
    begin
        mutable struct GtkTreeListModelLeaf <: GtkTreeListModel
            handle::Ptr{GObject}
            function GtkTreeListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeListModelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeListModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeListModelLeaf, args))
            end
            w = GtkTreeListModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeListModel] = GtkTreeListModelLeaf
        function GtkTreeListModel(args...; kwargs...)
            GtkTreeListModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeListRow <: GObject end
    end
    begin
        mutable struct GtkTreeListRowLeaf <: GtkTreeListRow
            handle::Ptr{GObject}
            function GtkTreeListRowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeListRowLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeListRowLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeListRowLeaf, args))
            end
            w = GtkTreeListRowLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeListRow] = GtkTreeListRowLeaf
        function GtkTreeListRow(args...; kwargs...)
            GtkTreeListRowLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeListRowSorter <: GtkSorter end
    end
    begin
        mutable struct GtkTreeListRowSorterLeaf <: GtkTreeListRowSorter
            handle::Ptr{GObject}
            function GtkTreeListRowSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeListRowSorterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeListRowSorterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeListRowSorterLeaf, args))
            end
            w = GtkTreeListRowSorterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeListRowSorter] = GtkTreeListRowSorterLeaf
        function GtkTreeListRowSorter(args...; kwargs...)
            GtkTreeListRowSorterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeModelFilter <: GObject end
    end
    begin
        mutable struct GtkTreeModelFilterLeaf <: GtkTreeModelFilter
            handle::Ptr{GObject}
            function GtkTreeModelFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeModelFilterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeModelFilterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeModelFilterLeaf, args))
            end
            w = GtkTreeModelFilterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeModelFilter] = GtkTreeModelFilterLeaf
        function GtkTreeModelFilter(args...; kwargs...)
            GtkTreeModelFilterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeModelSort <: GObject end
    end
    begin
        mutable struct GtkTreeModelSortLeaf <: GtkTreeModelSort
            handle::Ptr{GObject}
            function GtkTreeModelSortLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeModelSortLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeModelSortLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeModelSortLeaf, args))
            end
            w = GtkTreeModelSortLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeModelSort] = GtkTreeModelSortLeaf
        function GtkTreeModelSort(args...; kwargs...)
            GtkTreeModelSortLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeSelection <: GObject end
    end
    begin
        mutable struct GtkTreeSelectionLeaf <: GtkTreeSelection
            handle::Ptr{GObject}
            function GtkTreeSelectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeSelectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeSelectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeSelectionLeaf, args))
            end
            w = GtkTreeSelectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeSelection] = GtkTreeSelectionLeaf
        function GtkTreeSelection(args...; kwargs...)
            GtkTreeSelectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeStore <: GObject end
    end
    begin
        mutable struct GtkTreeStoreLeaf <: GtkTreeStore
            handle::Ptr{GObject}
            function GtkTreeStoreLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeStoreLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeStoreLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeStoreLeaf, args))
            end
            w = GtkTreeStoreLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeStore] = GtkTreeStoreLeaf
        function GtkTreeStore(args...; kwargs...)
            GtkTreeStoreLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeView <: GtkWidget end
    end
    begin
        mutable struct GtkTreeViewLeaf <: GtkTreeView
            handle::Ptr{GObject}
            function GtkTreeViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeViewLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeViewLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeViewLeaf, args))
            end
            w = GtkTreeViewLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeView] = GtkTreeViewLeaf
        function GtkTreeView(args...; kwargs...)
            GtkTreeViewLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkTreeViewColumn <: GInitiallyUnowned end
    end
    begin
        mutable struct GtkTreeViewColumnLeaf <: GtkTreeViewColumn
            handle::Ptr{GObject}
            function GtkTreeViewColumnLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeViewColumnLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkTreeViewColumnLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkTreeViewColumnLeaf, args))
            end
            w = GtkTreeViewColumnLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkTreeViewColumn] = GtkTreeViewColumnLeaf
        function GtkTreeViewColumn(args...; kwargs...)
            GtkTreeViewColumnLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkVideo <: GtkWidget end
    end
    begin
        mutable struct GtkVideoLeaf <: GtkVideo
            handle::Ptr{GObject}
            function GtkVideoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkVideoLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkVideoLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkVideoLeaf, args))
            end
            w = GtkVideoLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkVideo] = GtkVideoLeaf
        function GtkVideo(args...; kwargs...)
            GtkVideoLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkViewport <: GtkWidget end
    end
    begin
        mutable struct GtkViewportLeaf <: GtkViewport
            handle::Ptr{GObject}
            function GtkViewportLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkViewportLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkViewportLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkViewportLeaf, args))
            end
            w = GtkViewportLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkViewport] = GtkViewportLeaf
        function GtkViewport(args...; kwargs...)
            GtkViewportLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkVolumeButton <: GtkScaleButton end
    end
    begin
        mutable struct GtkVolumeButtonLeaf <: GtkVolumeButton
            handle::Ptr{GObject}
            function GtkVolumeButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkVolumeButtonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkVolumeButtonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkVolumeButtonLeaf, args))
            end
            w = GtkVolumeButtonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkVolumeButton] = GtkVolumeButtonLeaf
        function GtkVolumeButton(args...; kwargs...)
            GtkVolumeButtonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkWidgetPaintable <: GObject end
    end
    begin
        mutable struct GtkWidgetPaintableLeaf <: GtkWidgetPaintable
            handle::Ptr{GObject}
            function GtkWidgetPaintableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWidgetPaintableLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWidgetPaintableLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWidgetPaintableLeaf, args))
            end
            w = GtkWidgetPaintableLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWidgetPaintable] = GtkWidgetPaintableLeaf
        function GtkWidgetPaintable(args...; kwargs...)
            GtkWidgetPaintableLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkWindowControls <: GtkWidget end
    end
    begin
        mutable struct GtkWindowControlsLeaf <: GtkWindowControls
            handle::Ptr{GObject}
            function GtkWindowControlsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWindowControlsLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWindowControlsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWindowControlsLeaf, args))
            end
            w = GtkWindowControlsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWindowControls] = GtkWindowControlsLeaf
        function GtkWindowControls(args...; kwargs...)
            GtkWindowControlsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkWindowGroup <: GObject end
    end
    begin
        mutable struct GtkWindowGroupLeaf <: GtkWindowGroup
            handle::Ptr{GObject}
            function GtkWindowGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWindowGroupLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWindowGroupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWindowGroupLeaf, args))
            end
            w = GtkWindowGroupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWindowGroup] = GtkWindowGroupLeaf
        function GtkWindowGroup(args...; kwargs...)
            GtkWindowGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GtkWindowHandle <: GtkWidget end
    end
    begin
        mutable struct GtkWindowHandleLeaf <: GtkWindowHandle
            handle::Ptr{GObject}
            function GtkWindowHandleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWindowHandleLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GtkWindowHandleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GtkWindowHandleLeaf, args))
            end
            w = GtkWindowHandleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GtkWindowHandle] = GtkWindowHandleLeaf
        function GtkWindowHandle(args...; kwargs...)
            GtkWindowHandleLeaf(args...; kwargs...)
        end
    end
    begin
        gtype_wrapper_cache_init() = begin
                merge!(GLib.gtype_wrappers, gtype_wrapper_cache)
            end
    end
    begin
        struct GtkAccessible <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkAccessible(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkActionable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkActionable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkAppChooser <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkAppChooser(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkBuildable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkBuildable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkBuilderScope <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkBuilderScope(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkCellEditable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkCellEditable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkCellLayout <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkCellLayout(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkColorChooser <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkColorChooser(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkConstraintTarget <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkConstraintTarget(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkEditable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkEditable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkFileChooser <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkFileChooser(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkFontChooser <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkFontChooser(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkNative <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkNative(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkOrientable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkOrientable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkPrintOperationPreview <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkPrintOperationPreview(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkRoot <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkRoot(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkScrollable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkScrollable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkSelectionModel <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkSelectionModel(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkShortcutManager <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkShortcutManager(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkStyleProvider <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkStyleProvider(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkTreeDragDest <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkTreeDragDest(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkTreeDragSource <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkTreeDragSource(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkTreeModel <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkTreeModel(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GtkTreeSortable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GtkTreeSortable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    export GtkBitset, GtkBitsetIter, GtkBorder, _GtkBorder, GtkBuildableParseContext, GtkBuildableParser, GtkCssLocation, _GtkCssLocation, GtkCssSection, GtkCssStyleChange, GtkExpressionWatch, GtkPadActionEntry, _GtkPadActionEntry, GtkPaperSize, GtkPrintBackend, GtkRecentData, _GtkRecentData, GtkRecentInfo, GtkRequestedSize, _GtkRequestedSize, GtkRequisition, _GtkRequisition, GtkTextIter, _GtkTextIter, GtkTreeIter, _GtkTreeIter, GtkTreePath, GtkTreeRowReference, GtkATContext, GtkAboutDialog, GtkActionBar, GtkActivateAction, GtkAdjustment, GtkAlternativeTrigger, GtkAnyFilter, GtkAppChooserButton, GtkAppChooserDialog, GtkAppChooserWidget, GtkApplication, GtkApplicationWindow, GtkAspectFrame, GtkAssistant, GtkAssistantPage, GtkBinLayout, GtkBookmarkList, GtkBoolFilter, GtkBox, GtkBoxLayout, GtkBuilder, GtkBuilderCScope, GtkBuilderListItemFactory, GtkButton, GtkCalendar, GtkCallbackAction, GtkCellArea, GtkCellAreaBox, GtkCellAreaContext, GtkCellRenderer, GtkCellRendererAccel, GtkCellRendererCombo, GtkCellRendererPixbuf, GtkCellRendererProgress, GtkCellRendererSpin, GtkCellRendererSpinner, GtkCellRendererText, GtkCellRendererToggle, GtkCellView, GtkCenterBox, GtkCenterLayout, GtkCheckButton, GtkColorButton, GtkColorChooserDialog, GtkColorChooserWidget, GtkColumnView, GtkColumnViewColumn, GtkComboBox, GtkComboBoxText, GtkConstraint, GtkConstraintGuide, GtkConstraintLayout, GtkConstraintLayoutChild, GtkCssProvider, GtkCustomFilter, GtkCustomLayout, GtkCustomSorter, GtkDialog, GtkDirectoryList, GtkDragIcon, GtkDragSource, GtkDrawingArea, GtkDropControllerMotion, GtkDropDown, GtkDropTarget, GtkDropTargetAsync, GtkEditableLabel, GtkEmojiChooser, GtkEntry, GtkEntryBuffer, GtkEntryCompletion, GtkEventController, GtkEventControllerFocus, GtkEventControllerKey, GtkEventControllerLegacy, GtkEventControllerMotion, GtkEventControllerScroll, GtkEveryFilter, GtkExpander, GtkFileChooserDialog, GtkFileChooserNative, GtkFileChooserWidget, GtkFileFilter, GtkFilter, GtkFilterListModel, GtkFixed, GtkFixedLayout, GtkFixedLayoutChild, GtkFlattenListModel, GtkFlowBox, GtkFlowBoxChild, GtkFontButton, GtkFontChooserDialog, GtkFontChooserWidget, GtkFrame, GtkGLArea, GtkGesture, GtkGestureClick, GtkGestureDrag, GtkGestureLongPress, GtkGesturePan, GtkGestureRotate, GtkGestureSingle, GtkGestureStylus, GtkGestureSwipe, GtkGestureZoom, GtkGrid, GtkGridLayout, GtkGridLayoutChild, GtkGridView, GtkHeaderBar, GtkIMContext, GtkIMContextSimple, GtkIMMulticontext, GtkIconPaintable, GtkIconTheme, GtkIconView, GtkImage, GtkInfoBar, GtkKeyvalTrigger, GtkLabel, GtkLayoutChild, GtkLayoutManager, GtkLevelBar, GtkLinkButton, GtkListBase, GtkListBox, GtkListBoxRow, GtkListItem, GtkListItemFactory, GtkListStore, GtkListView, GtkLockButton, GtkMapListModel, GtkMediaControls, GtkMediaFile, GtkMediaStream, GtkMenuButton, GtkMessageDialog, GtkMnemonicAction, GtkMnemonicTrigger, GtkMountOperation, GtkMultiFilter, GtkMultiSelection, GtkMultiSorter, GtkNamedAction, GtkNativeDialog, GtkNeverTrigger, GtkNoSelection, GtkNotebook, GtkNotebookPage, GtkNothingAction, GtkNumericSorter, GtkOverlay, GtkOverlayLayout, GtkOverlayLayoutChild, GtkPadController, GtkPageSetup, GtkPaned, GtkPasswordEntry, GtkPasswordEntryBuffer, GtkPicture, GtkPopover, GtkPopoverMenu, GtkPopoverMenuBar, GtkPrintContext, GtkPrintJob, GtkPrintOperation, GtkPrintSettings, GtkPrinter, GtkProgressBar, GtkRange, GtkRecentManager, GtkRevealer, GtkScale, GtkScaleButton, GtkScrollbar, GtkScrolledWindow, GtkSearchBar, GtkSearchEntry, GtkSelectionFilterModel, GtkSeparator, GtkSettings, GtkShortcut, GtkShortcutAction, GtkShortcutController, GtkShortcutLabel, GtkShortcutTrigger, GtkShortcutsGroup, GtkShortcutsSection, GtkShortcutsShortcut, GtkShortcutsWindow, GtkSignalAction, GtkSignalListItemFactory, GtkSingleSelection, GtkSizeGroup, GtkSliceListModel, GtkSnapshot, GtkSortListModel, GtkSorter, GtkSpinButton, GtkSpinner, GtkStack, GtkStackPage, GtkStackSidebar, GtkStackSwitcher, GtkStatusbar, GtkStringFilter, GtkStringList, GtkStringObject, GtkStringSorter, GtkStyleContext, GtkSwitch, GtkText, GtkTextBuffer, GtkTextChildAnchor, GtkTextMark, GtkTextTag, GtkTextTagTable, GtkTextView, GtkToggleButton, GtkTooltip, GtkTreeExpander, GtkTreeListModel, GtkTreeListRow, GtkTreeListRowSorter, GtkTreeModelFilter, GtkTreeModelSort, GtkTreeSelection, GtkTreeStore, GtkTreeView, GtkTreeViewColumn, GtkVideo, GtkViewport, GtkVolumeButton, GtkWidget, GtkWidgetPaintable, GtkWindow, GtkWindowControls, GtkWindowGroup, GtkWindowHandle, GtkAccessible, GtkActionable, GtkAppChooser, GtkBuildable, GtkBuilderScope, GtkCellEditable, GtkCellLayout, GtkColorChooser, GtkConstraintTarget, GtkEditable, GtkFileChooser, GtkFontChooser, GtkNative, GtkOrientable, GtkPrintOperationPreview, GtkRoot, GtkScrollable, GtkSelectionModel, GtkShortcutManager, GtkStyleProvider, GtkTreeDragDest, GtkTreeDragSource, GtkTreeModel, GtkTreeSortable
end))
end
