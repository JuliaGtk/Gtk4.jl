quote
$(Expr(:toplevel, quote
    gboxed_types = Any[]
    mutable struct GtkBitset <: GBoxed
        handle::Ptr{GtkBitset}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkBitset) = begin
                    ccall(("gtk_bitset_get_type", libgtk4), GType, ())
                end
            function GtkBitset(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkBitset)
        end
    end
    begin
        mutable struct GtkBitsetIter <: GBoxed
            handle::Ptr{GtkBitsetIter}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkBitsetIter) = begin
                        ccall(("gtk_bitset_iter_get_type", libgtk4), GType, ())
                    end
                function GtkBitsetIter(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkBitsetIter)
            end
        end
        const _GtkBitsetIter = GtkBitsetIter
    end
    begin
        struct _GtkBorder
            left::Int16
            right::Int16
            top::Int16
            bottom::Int16
        end
        mutable struct GtkBorder <: GBoxed
            handle::Ptr{_GtkBorder}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkBorder) = begin
                        ccall(("gtk_border_get_type", libgtk4), GType, ())
                    end
                function GtkBorder(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkBorder)
            end
        end
        unsafe_convert(::Type{Ptr{_GtkBorder}}, box::GtkBorder) = begin
                convert(Ptr{_GtkBorder}, box.handle)
            end
    end
    mutable struct GtkBuildableParseContext
        handle::Ptr{GtkBuildableParseContext}
    end
    begin
        mutable struct GtkBuildableParser
            handle::Ptr{GtkBuildableParser}
        end
        const _GtkBuildableParser = GtkBuildableParser
    end
    begin
        struct _GtkCssLocation
            bytes::UInt64
            chars::UInt64
            lines::UInt64
            line_bytes::UInt64
            line_chars::UInt64
        end
        mutable struct GtkCssLocation
            handle::Ptr{_GtkCssLocation}
        end
        unsafe_convert(::Type{Ptr{_GtkCssLocation}}, box::GtkCssLocation) = begin
                convert(Ptr{_GtkCssLocation}, box.handle)
            end
    end
    mutable struct GtkCssSection <: GBoxed
        handle::Ptr{GtkCssSection}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkCssSection) = begin
                    ccall(("gtk_css_section_get_type", libgtk4), GType, ())
                end
            function GtkCssSection(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkCssSection)
        end
    end
    mutable struct GtkCssStyleChange
        handle::Ptr{GtkCssStyleChange}
    end
    mutable struct GtkExpressionWatch <: GBoxed
        handle::Ptr{GtkExpressionWatch}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkExpressionWatch) = begin
                    ccall(("gtk_expression_watch_get_type", libgtk4), GType, ())
                end
            function GtkExpressionWatch(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkExpressionWatch)
        end
    end
    begin
        struct _GtkPadActionEntry
            type::UInt32
            index::Int32
            mode::Int32
            label::Cstring
            action_name::Cstring
        end
        mutable struct GtkPadActionEntry
            handle::Ptr{_GtkPadActionEntry}
        end
        unsafe_convert(::Type{Ptr{_GtkPadActionEntry}}, box::GtkPadActionEntry) = begin
                convert(Ptr{_GtkPadActionEntry}, box.handle)
            end
    end
    mutable struct GtkPaperSize <: GBoxed
        handle::Ptr{GtkPaperSize}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkPaperSize) = begin
                    ccall(("gtk_paper_size_get_type", libgtk4), GType, ())
                end
            function GtkPaperSize(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkPaperSize)
        end
    end
    mutable struct GtkPrintBackend
        handle::Ptr{GtkPrintBackend}
    end
    begin
        struct _GtkRecentData
            display_name::Cstring
            description::Cstring
            mime_type::Cstring
            app_name::Cstring
            app_exec::Cstring
            groups::Ptr{Cstring}
            is_private::Cint
        end
        mutable struct GtkRecentData
            handle::Ptr{_GtkRecentData}
        end
        unsafe_convert(::Type{Ptr{_GtkRecentData}}, box::GtkRecentData) = begin
                convert(Ptr{_GtkRecentData}, box.handle)
            end
    end
    mutable struct GtkRecentInfo <: GBoxed
        handle::Ptr{GtkRecentInfo}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkRecentInfo) = begin
                    ccall(("gtk_recent_info_get_type", libgtk4), GType, ())
                end
            function GtkRecentInfo(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkRecentInfo)
        end
    end
    begin
        struct _GtkRequestedSize
            data::Ptr{Nothing}
            minimum_size::Int32
            natural_size::Int32
        end
        mutable struct GtkRequestedSize
            handle::Ptr{_GtkRequestedSize}
        end
        unsafe_convert(::Type{Ptr{_GtkRequestedSize}}, box::GtkRequestedSize) = begin
                convert(Ptr{_GtkRequestedSize}, box.handle)
            end
    end
    begin
        struct _GtkRequisition
            width::Int32
            height::Int32
        end
        mutable struct GtkRequisition <: GBoxed
            handle::Ptr{_GtkRequisition}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkRequisition) = begin
                        ccall(("gtk_requisition_get_type", libgtk4), GType, ())
                    end
                function GtkRequisition(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkRequisition)
            end
        end
        unsafe_convert(::Type{Ptr{_GtkRequisition}}, box::GtkRequisition) = begin
                convert(Ptr{_GtkRequisition}, box.handle)
            end
    end
    begin
        struct _GtkTextIter
            dummy1::Ptr{Nothing}
            dummy2::Ptr{Nothing}
            dummy3::Int32
            dummy4::Int32
            dummy5::Int32
            dummy6::Int32
            dummy7::Int32
            dummy8::Int32
            dummy9::Ptr{Nothing}
            dummy10::Ptr{Nothing}
            dummy11::Int32
            dummy12::Int32
            dummy13::Int32
            dummy14::Ptr{Nothing}
        end
        mutable struct GtkTextIter <: GBoxed
            handle::Ptr{_GtkTextIter}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkTextIter) = begin
                        ccall(("gtk_text_iter_get_type", libgtk4), GType, ())
                    end
                function GtkTextIter(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkTextIter)
            end
        end
        unsafe_convert(::Type{Ptr{_GtkTextIter}}, box::GtkTextIter) = begin
                convert(Ptr{_GtkTextIter}, box.handle)
            end
    end
    begin
        struct _GtkTreeIter
            stamp::Int32
            user_data::Ptr{Nothing}
            user_data2::Ptr{Nothing}
            user_data3::Ptr{Nothing}
        end
        mutable struct GtkTreeIter <: GBoxed
            handle::Ptr{_GtkTreeIter}
            begin
                (GLib.g_type(::Type{T}) where T <: GtkTreeIter) = begin
                        ccall(("gtk_tree_iter_get_type", libgtk4), GType, ())
                    end
                function GtkTreeIter(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GtkTreeIter)
            end
        end
        unsafe_convert(::Type{Ptr{_GtkTreeIter}}, box::GtkTreeIter) = begin
                convert(Ptr{_GtkTreeIter}, box.handle)
            end
    end
    mutable struct GtkTreePath <: GBoxed
        handle::Ptr{GtkTreePath}
        begin
            (GLib.g_type(::Type{T}) where T <: GtkTreePath) = begin
                    ccall(("gtk_tree_path_get_type", libgtk4), GType, ())
                end
            function GtkTreePath(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GtkTreePath)
        end
    end
    function GtkBitset()
        G_.Bitset_new_empty()
    end
    function GtkBitset(_start::Integer, _n_items::Integer)
        G_.Bitset_new_range(_start, _n_items)
    end
    function GtkBorder()
        G_.Border_new()
    end
    function GtkCssSection(_file::Maybe(GFile), _start::Union{GtkCssLocation, Ref{_GtkCssLocation}}, _end::Union{GtkCssLocation, Ref{_GtkCssLocation}})
        G_.CssSection_new(_file, _start, _end)
    end
    function GtkPaperSize(_name::Maybe(Union{AbstractString, Symbol}))
        G_.PaperSize_new(_name)
    end
    function GtkPaperSize(_name::Union{AbstractString, Symbol}, _display_name::Union{AbstractString, Symbol}, _width::Real, _height::Real, _unit)
        G_.PaperSize_new_custom(_name, _display_name, _width, _height, _unit)
    end
    function GtkPaperSize(_variant::GVariant)
        G_.PaperSize_new_from_gvariant(_variant)
    end
    function GtkPaperSize(_ipp_name::Union{AbstractString, Symbol}, _width::Real, _height::Real)
        G_.PaperSize_new_from_ipp(_ipp_name, _width, _height)
    end
    function GtkPaperSize(_key_file::GKeyFile, _group_name::Maybe(Union{AbstractString, Symbol}))
        G_.PaperSize_new_from_key_file(_key_file, _group_name)
    end
    function GtkPaperSize(_ppd_name::Union{AbstractString, Symbol}, _ppd_display_name::Union{AbstractString, Symbol}, _width::Real, _height::Real)
        G_.PaperSize_new_from_ppd(_ppd_name, _ppd_display_name, _width, _height)
    end
    function GtkRequisition()
        G_.Requisition_new()
    end
    function GtkTreePath()
        G_.TreePath_new()
    end
    function GtkTreePath(_indices)
        G_.TreePath_new_from_indices(_indices)
    end
    function GtkTreePath(_path::Union{AbstractString, Symbol})
        G_.TreePath_new_from_string(_path)
    end
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.Bitset.html)." GtkBitset
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.BitsetIter.html)." GtkBitsetIter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.Border.html)." GtkBorder
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.BuildableParseContext.html)." GtkBuildableParseContext
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.BuildableParser.html)." GtkBuildableParser
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.CssSection.html)." GtkCssSection
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.ExpressionWatch.html)." GtkExpressionWatch
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.PadActionEntry.html)." GtkPadActionEntry
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.PaperSize.html)." GtkPaperSize
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.RecentData.html)." GtkRecentData
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.RecentInfo.html)." GtkRecentInfo
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.RequestedSize.html)." GtkRequestedSize
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.Requisition.html)." GtkRequisition
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.TextIter.html)." GtkTextIter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.TreeIter.html)." GtkTreeIter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/struct.TreePath.html)." GtkTreePath
    struct GtkAccessible <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkAccessible(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkAccessibleRange <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkAccessibleRange(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkActionable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkActionable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkAppChooser <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkAppChooser(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkBuildable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkBuildable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkBuilderScope <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkBuilderScope(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkCellEditable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkCellEditable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkCellLayout <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkCellLayout(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkColorChooser <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkColorChooser(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkConstraintTarget <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkConstraintTarget(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkEditable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkEditable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkFileChooser <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkFileChooser(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkFontChooser <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkFontChooser(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkNative <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkNative(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkOrientable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkOrientable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkPrintOperationPreview <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkPrintOperationPreview(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkRoot <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkRoot(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkScrollable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkScrollable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkSelectionModel <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkSelectionModel(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkShortcutManager <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkShortcutManager(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkStyleProvider <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkStyleProvider(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkSymbolicPaintable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkSymbolicPaintable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkTreeDragDest <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkTreeDragDest(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkTreeDragSource <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkTreeDragSource(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkTreeModel <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkTreeModel(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GtkTreeSortable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GtkTreeSortable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    begin
        abstract type GtkATContext <: GObject end
        mutable struct GtkATContextLeaf <: GtkATContext
            handle::Ptr{GObject}
            function GtkATContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkATContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkATContext] = GtkATContextLeaf
        (GLib.g_type(::Type{T}) where T <: GtkATContext) = begin
                ccall(("gtk_at_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkWidget <: GInitiallyUnowned end
        mutable struct GtkWidgetLeaf <: GtkWidget
            handle::Ptr{GObject}
            function GtkWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWidgetLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkWidget] = GtkWidgetLeaf
        (GLib.g_type(::Type{T}) where T <: GtkWidget) = begin
                ccall(("gtk_widget_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkWindow <: GtkWidget end
        mutable struct GtkWindowLeaf <: GtkWindow
            handle::Ptr{GObject}
            function GtkWindowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWindowLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkWindow] = GtkWindowLeaf
        (GLib.g_type(::Type{T}) where T <: GtkWindow) = begin
                ccall(("gtk_window_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAboutDialog <: GtkWindow end
        mutable struct GtkAboutDialogLeaf <: GtkAboutDialog
            handle::Ptr{GObject}
            function GtkAboutDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAboutDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAboutDialog] = GtkAboutDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAboutDialog) = begin
                ccall(("gtk_about_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkActionBar <: GtkWidget end
        mutable struct GtkActionBarLeaf <: GtkActionBar
            handle::Ptr{GObject}
            function GtkActionBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkActionBarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkActionBar] = GtkActionBarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkActionBar) = begin
                ccall(("gtk_action_bar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkShortcutAction <: GObject end
        mutable struct GtkShortcutActionLeaf <: GtkShortcutAction
            handle::Ptr{GObject}
            function GtkShortcutActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkShortcutAction] = GtkShortcutActionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkShortcutAction) = begin
                ccall(("gtk_shortcut_action_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkActivateAction <: GtkShortcutAction end
        mutable struct GtkActivateActionLeaf <: GtkActivateAction
            handle::Ptr{GObject}
            function GtkActivateActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkActivateActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkActivateAction] = GtkActivateActionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkActivateAction) = begin
                ccall(("gtk_activate_action_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAdjustment <: GInitiallyUnowned end
        mutable struct GtkAdjustmentLeaf <: GtkAdjustment
            handle::Ptr{GObject}
            function GtkAdjustmentLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAdjustmentLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAdjustment] = GtkAdjustmentLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAdjustment) = begin
                ccall(("gtk_adjustment_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAlertDialog <: GObject end
        mutable struct GtkAlertDialogLeaf <: GtkAlertDialog
            handle::Ptr{GObject}
            function GtkAlertDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAlertDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAlertDialog] = GtkAlertDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAlertDialog) = begin
                ccall(("gtk_alert_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkShortcutTrigger <: GObject end
        mutable struct GtkShortcutTriggerLeaf <: GtkShortcutTrigger
            handle::Ptr{GObject}
            function GtkShortcutTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutTriggerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkShortcutTrigger] = GtkShortcutTriggerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkShortcutTrigger) = begin
                ccall(("gtk_shortcut_trigger_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAlternativeTrigger <: GtkShortcutTrigger end
        mutable struct GtkAlternativeTriggerLeaf <: GtkAlternativeTrigger
            handle::Ptr{GObject}
            function GtkAlternativeTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAlternativeTriggerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAlternativeTrigger] = GtkAlternativeTriggerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAlternativeTrigger) = begin
                ccall(("gtk_alternative_trigger_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFilter <: GObject end
        mutable struct GtkFilterLeaf <: GtkFilter
            handle::Ptr{GObject}
            function GtkFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFilterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFilter] = GtkFilterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFilter) = begin
                ccall(("gtk_filter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMultiFilter <: GtkFilter end
        mutable struct GtkMultiFilterLeaf <: GtkMultiFilter
            handle::Ptr{GObject}
            function GtkMultiFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMultiFilterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMultiFilter] = GtkMultiFilterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMultiFilter) = begin
                ccall(("gtk_multi_filter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAnyFilter <: GtkMultiFilter end
        mutable struct GtkAnyFilterLeaf <: GtkAnyFilter
            handle::Ptr{GObject}
            function GtkAnyFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAnyFilterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAnyFilter] = GtkAnyFilterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAnyFilter) = begin
                ccall(("gtk_any_filter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAppChooserButton <: GtkWidget end
        mutable struct GtkAppChooserButtonLeaf <: GtkAppChooserButton
            handle::Ptr{GObject}
            function GtkAppChooserButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAppChooserButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAppChooserButton] = GtkAppChooserButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAppChooserButton) = begin
                ccall(("gtk_app_chooser_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkDialog <: GtkWindow end
        mutable struct GtkDialogLeaf <: GtkDialog
            handle::Ptr{GObject}
            function GtkDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkDialog] = GtkDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkDialog) = begin
                ccall(("gtk_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAppChooserDialog <: GtkDialog end
        mutable struct GtkAppChooserDialogLeaf <: GtkAppChooserDialog
            handle::Ptr{GObject}
            function GtkAppChooserDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAppChooserDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAppChooserDialog] = GtkAppChooserDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAppChooserDialog) = begin
                ccall(("gtk_app_chooser_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAppChooserWidget <: GtkWidget end
        mutable struct GtkAppChooserWidgetLeaf <: GtkAppChooserWidget
            handle::Ptr{GObject}
            function GtkAppChooserWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAppChooserWidgetLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAppChooserWidget] = GtkAppChooserWidgetLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAppChooserWidget) = begin
                ccall(("gtk_app_chooser_widget_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkApplication <: GApplication end
        mutable struct GtkApplicationLeaf <: GtkApplication
            handle::Ptr{GObject}
            function GtkApplicationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkApplicationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkApplication] = GtkApplicationLeaf
        (GLib.g_type(::Type{T}) where T <: GtkApplication) = begin
                ccall(("gtk_application_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkApplicationWindow <: GtkWindow end
        mutable struct GtkApplicationWindowLeaf <: GtkApplicationWindow
            handle::Ptr{GObject}
            function GtkApplicationWindowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkApplicationWindowLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkApplicationWindow] = GtkApplicationWindowLeaf
        (GLib.g_type(::Type{T}) where T <: GtkApplicationWindow) = begin
                ccall(("gtk_application_window_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAspectFrame <: GtkWidget end
        mutable struct GtkAspectFrameLeaf <: GtkAspectFrame
            handle::Ptr{GObject}
            function GtkAspectFrameLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAspectFrameLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAspectFrame] = GtkAspectFrameLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAspectFrame) = begin
                ccall(("gtk_aspect_frame_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAssistant <: GtkWindow end
        mutable struct GtkAssistantLeaf <: GtkAssistant
            handle::Ptr{GObject}
            function GtkAssistantLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAssistantLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAssistant] = GtkAssistantLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAssistant) = begin
                ccall(("gtk_assistant_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkAssistantPage <: GObject end
        mutable struct GtkAssistantPageLeaf <: GtkAssistantPage
            handle::Ptr{GObject}
            function GtkAssistantPageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkAssistantPageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkAssistantPage] = GtkAssistantPageLeaf
        (GLib.g_type(::Type{T}) where T <: GtkAssistantPage) = begin
                ccall(("gtk_assistant_page_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkLayoutManager <: GObject end
        mutable struct GtkLayoutManagerLeaf <: GtkLayoutManager
            handle::Ptr{GObject}
            function GtkLayoutManagerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLayoutManagerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkLayoutManager] = GtkLayoutManagerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkLayoutManager) = begin
                ccall(("gtk_layout_manager_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkBinLayout <: GtkLayoutManager end
        mutable struct GtkBinLayoutLeaf <: GtkBinLayout
            handle::Ptr{GObject}
            function GtkBinLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBinLayoutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkBinLayout] = GtkBinLayoutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkBinLayout) = begin
                ccall(("gtk_bin_layout_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkBookmarkList <: GObject end
        mutable struct GtkBookmarkListLeaf <: GtkBookmarkList
            handle::Ptr{GObject}
            function GtkBookmarkListLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBookmarkListLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkBookmarkList] = GtkBookmarkListLeaf
        (GLib.g_type(::Type{T}) where T <: GtkBookmarkList) = begin
                ccall(("gtk_bookmark_list_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkBoolFilter <: GtkFilter end
        mutable struct GtkBoolFilterLeaf <: GtkBoolFilter
            handle::Ptr{GObject}
            function GtkBoolFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBoolFilterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkBoolFilter] = GtkBoolFilterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkBoolFilter) = begin
                ccall(("gtk_bool_filter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkBox <: GtkWidget end
        mutable struct GtkBoxLeaf <: GtkBox
            handle::Ptr{GObject}
            function GtkBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBoxLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkBox] = GtkBoxLeaf
        (GLib.g_type(::Type{T}) where T <: GtkBox) = begin
                ccall(("gtk_box_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkBoxLayout <: GtkLayoutManager end
        mutable struct GtkBoxLayoutLeaf <: GtkBoxLayout
            handle::Ptr{GObject}
            function GtkBoxLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBoxLayoutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkBoxLayout] = GtkBoxLayoutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkBoxLayout) = begin
                ccall(("gtk_box_layout_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkBuilder <: GObject end
        mutable struct GtkBuilderLeaf <: GtkBuilder
            handle::Ptr{GObject}
            function GtkBuilderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBuilderLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkBuilder] = GtkBuilderLeaf
        (GLib.g_type(::Type{T}) where T <: GtkBuilder) = begin
                ccall(("gtk_builder_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkBuilderCScope <: GObject end
        mutable struct GtkBuilderCScopeLeaf <: GtkBuilderCScope
            handle::Ptr{GObject}
            function GtkBuilderCScopeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBuilderCScopeLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkBuilderCScope] = GtkBuilderCScopeLeaf
        (GLib.g_type(::Type{T}) where T <: GtkBuilderCScope) = begin
                ccall(("gtk_builder_cscope_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkListItemFactory <: GObject end
        mutable struct GtkListItemFactoryLeaf <: GtkListItemFactory
            handle::Ptr{GObject}
            function GtkListItemFactoryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListItemFactoryLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkListItemFactory] = GtkListItemFactoryLeaf
        (GLib.g_type(::Type{T}) where T <: GtkListItemFactory) = begin
                ccall(("gtk_list_item_factory_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkBuilderListItemFactory <: GtkListItemFactory end
        mutable struct GtkBuilderListItemFactoryLeaf <: GtkBuilderListItemFactory
            handle::Ptr{GObject}
            function GtkBuilderListItemFactoryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkBuilderListItemFactoryLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkBuilderListItemFactory] = GtkBuilderListItemFactoryLeaf
        (GLib.g_type(::Type{T}) where T <: GtkBuilderListItemFactory) = begin
                ccall(("gtk_builder_list_item_factory_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkButton <: GtkWidget end
        mutable struct GtkButtonLeaf <: GtkButton
            handle::Ptr{GObject}
            function GtkButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkButton] = GtkButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkButton) = begin
                ccall(("gtk_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCalendar <: GtkWidget end
        mutable struct GtkCalendarLeaf <: GtkCalendar
            handle::Ptr{GObject}
            function GtkCalendarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCalendarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCalendar] = GtkCalendarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCalendar) = begin
                ccall(("gtk_calendar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCallbackAction <: GtkShortcutAction end
        mutable struct GtkCallbackActionLeaf <: GtkCallbackAction
            handle::Ptr{GObject}
            function GtkCallbackActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCallbackActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCallbackAction] = GtkCallbackActionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCallbackAction) = begin
                ccall(("gtk_callback_action_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellArea <: GInitiallyUnowned end
        mutable struct GtkCellAreaLeaf <: GtkCellArea
            handle::Ptr{GObject}
            function GtkCellAreaLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellAreaLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellArea] = GtkCellAreaLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellArea) = begin
                ccall(("gtk_cell_area_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellAreaBox <: GtkCellArea end
        mutable struct GtkCellAreaBoxLeaf <: GtkCellAreaBox
            handle::Ptr{GObject}
            function GtkCellAreaBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellAreaBoxLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellAreaBox] = GtkCellAreaBoxLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellAreaBox) = begin
                ccall(("gtk_cell_area_box_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellAreaContext <: GObject end
        mutable struct GtkCellAreaContextLeaf <: GtkCellAreaContext
            handle::Ptr{GObject}
            function GtkCellAreaContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellAreaContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellAreaContext] = GtkCellAreaContextLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellAreaContext) = begin
                ccall(("gtk_cell_area_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellRenderer <: GInitiallyUnowned end
        mutable struct GtkCellRendererLeaf <: GtkCellRenderer
            handle::Ptr{GObject}
            function GtkCellRendererLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellRenderer] = GtkCellRendererLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellRenderer) = begin
                ccall(("gtk_cell_renderer_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellRendererText <: GtkCellRenderer end
        mutable struct GtkCellRendererTextLeaf <: GtkCellRendererText
            handle::Ptr{GObject}
            function GtkCellRendererTextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererTextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellRendererText] = GtkCellRendererTextLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellRendererText) = begin
                ccall(("gtk_cell_renderer_text_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellRendererAccel <: GtkCellRendererText end
        mutable struct GtkCellRendererAccelLeaf <: GtkCellRendererAccel
            handle::Ptr{GObject}
            function GtkCellRendererAccelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererAccelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellRendererAccel] = GtkCellRendererAccelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellRendererAccel) = begin
                ccall(("gtk_cell_renderer_accel_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellRendererCombo <: GtkCellRendererText end
        mutable struct GtkCellRendererComboLeaf <: GtkCellRendererCombo
            handle::Ptr{GObject}
            function GtkCellRendererComboLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererComboLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellRendererCombo] = GtkCellRendererComboLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellRendererCombo) = begin
                ccall(("gtk_cell_renderer_combo_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellRendererPixbuf <: GtkCellRenderer end
        mutable struct GtkCellRendererPixbufLeaf <: GtkCellRendererPixbuf
            handle::Ptr{GObject}
            function GtkCellRendererPixbufLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererPixbufLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellRendererPixbuf] = GtkCellRendererPixbufLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellRendererPixbuf) = begin
                ccall(("gtk_cell_renderer_pixbuf_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellRendererProgress <: GtkCellRenderer end
        mutable struct GtkCellRendererProgressLeaf <: GtkCellRendererProgress
            handle::Ptr{GObject}
            function GtkCellRendererProgressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererProgressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellRendererProgress] = GtkCellRendererProgressLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellRendererProgress) = begin
                ccall(("gtk_cell_renderer_progress_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellRendererSpin <: GtkCellRendererText end
        mutable struct GtkCellRendererSpinLeaf <: GtkCellRendererSpin
            handle::Ptr{GObject}
            function GtkCellRendererSpinLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererSpinLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellRendererSpin] = GtkCellRendererSpinLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellRendererSpin) = begin
                ccall(("gtk_cell_renderer_spin_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellRendererSpinner <: GtkCellRenderer end
        mutable struct GtkCellRendererSpinnerLeaf <: GtkCellRendererSpinner
            handle::Ptr{GObject}
            function GtkCellRendererSpinnerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererSpinnerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellRendererSpinner] = GtkCellRendererSpinnerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellRendererSpinner) = begin
                ccall(("gtk_cell_renderer_spinner_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellRendererToggle <: GtkCellRenderer end
        mutable struct GtkCellRendererToggleLeaf <: GtkCellRendererToggle
            handle::Ptr{GObject}
            function GtkCellRendererToggleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellRendererToggleLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellRendererToggle] = GtkCellRendererToggleLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellRendererToggle) = begin
                ccall(("gtk_cell_renderer_toggle_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCellView <: GtkWidget end
        mutable struct GtkCellViewLeaf <: GtkCellView
            handle::Ptr{GObject}
            function GtkCellViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCellViewLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCellView] = GtkCellViewLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCellView) = begin
                ccall(("gtk_cell_view_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCenterBox <: GtkWidget end
        mutable struct GtkCenterBoxLeaf <: GtkCenterBox
            handle::Ptr{GObject}
            function GtkCenterBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCenterBoxLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCenterBox] = GtkCenterBoxLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCenterBox) = begin
                ccall(("gtk_center_box_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCenterLayout <: GtkLayoutManager end
        mutable struct GtkCenterLayoutLeaf <: GtkCenterLayout
            handle::Ptr{GObject}
            function GtkCenterLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCenterLayoutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCenterLayout] = GtkCenterLayoutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCenterLayout) = begin
                ccall(("gtk_center_layout_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCheckButton <: GtkWidget end
        mutable struct GtkCheckButtonLeaf <: GtkCheckButton
            handle::Ptr{GObject}
            function GtkCheckButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCheckButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCheckButton] = GtkCheckButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCheckButton) = begin
                ccall(("gtk_check_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkColorButton <: GtkWidget end
        mutable struct GtkColorButtonLeaf <: GtkColorButton
            handle::Ptr{GObject}
            function GtkColorButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColorButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkColorButton] = GtkColorButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkColorButton) = begin
                ccall(("gtk_color_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkColorChooserDialog <: GtkDialog end
        mutable struct GtkColorChooserDialogLeaf <: GtkColorChooserDialog
            handle::Ptr{GObject}
            function GtkColorChooserDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColorChooserDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkColorChooserDialog] = GtkColorChooserDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkColorChooserDialog) = begin
                ccall(("gtk_color_chooser_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkColorChooserWidget <: GtkWidget end
        mutable struct GtkColorChooserWidgetLeaf <: GtkColorChooserWidget
            handle::Ptr{GObject}
            function GtkColorChooserWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColorChooserWidgetLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkColorChooserWidget] = GtkColorChooserWidgetLeaf
        (GLib.g_type(::Type{T}) where T <: GtkColorChooserWidget) = begin
                ccall(("gtk_color_chooser_widget_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkColorDialog <: GObject end
        mutable struct GtkColorDialogLeaf <: GtkColorDialog
            handle::Ptr{GObject}
            function GtkColorDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColorDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkColorDialog] = GtkColorDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkColorDialog) = begin
                ccall(("gtk_color_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkColorDialogButton <: GtkWidget end
        mutable struct GtkColorDialogButtonLeaf <: GtkColorDialogButton
            handle::Ptr{GObject}
            function GtkColorDialogButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColorDialogButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkColorDialogButton] = GtkColorDialogButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkColorDialogButton) = begin
                ccall(("gtk_color_dialog_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkColumnView <: GtkWidget end
        mutable struct GtkColumnViewLeaf <: GtkColumnView
            handle::Ptr{GObject}
            function GtkColumnViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColumnViewLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkColumnView] = GtkColumnViewLeaf
        (GLib.g_type(::Type{T}) where T <: GtkColumnView) = begin
                ccall(("gtk_column_view_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkColumnViewColumn <: GObject end
        mutable struct GtkColumnViewColumnLeaf <: GtkColumnViewColumn
            handle::Ptr{GObject}
            function GtkColumnViewColumnLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColumnViewColumnLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkColumnViewColumn] = GtkColumnViewColumnLeaf
        (GLib.g_type(::Type{T}) where T <: GtkColumnViewColumn) = begin
                ccall(("gtk_column_view_column_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSorter <: GObject end
        mutable struct GtkSorterLeaf <: GtkSorter
            handle::Ptr{GObject}
            function GtkSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSorterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSorter] = GtkSorterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSorter) = begin
                ccall(("gtk_sorter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkColumnViewSorter <: GtkSorter end
        mutable struct GtkColumnViewSorterLeaf <: GtkColumnViewSorter
            handle::Ptr{GObject}
            function GtkColumnViewSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkColumnViewSorterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkColumnViewSorter] = GtkColumnViewSorterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkColumnViewSorter) = begin
                ccall(("gtk_column_view_sorter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkComboBox <: GtkWidget end
        mutable struct GtkComboBoxLeaf <: GtkComboBox
            handle::Ptr{GObject}
            function GtkComboBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkComboBoxLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkComboBox] = GtkComboBoxLeaf
        (GLib.g_type(::Type{T}) where T <: GtkComboBox) = begin
                ccall(("gtk_combo_box_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkComboBoxText <: GtkComboBox end
        mutable struct GtkComboBoxTextLeaf <: GtkComboBoxText
            handle::Ptr{GObject}
            function GtkComboBoxTextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkComboBoxTextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkComboBoxText] = GtkComboBoxTextLeaf
        (GLib.g_type(::Type{T}) where T <: GtkComboBoxText) = begin
                ccall(("gtk_combo_box_text_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkExpression <: GTypeInstance end
        Base.convert(::Type{GtkExpression}, ptr::Ptr{GtkExpression}) = begin
                GtkExpressionLeaf(ptr)
            end
        Base.unsafe_convert(::Type{Ptr{GtkExpression}}, o::GtkExpression) = begin
                o.handle
            end
    end
    begin
        mutable struct GtkExpressionLeaf <: GtkExpression
            handle::Ptr{GtkExpression}
        end
    end
    begin
        abstract type GtkConstantExpression <: GtkExpression end
    end
    begin
        mutable struct GtkConstantExpressionLeaf <: GtkConstantExpression
            handle::Ptr{GtkExpression}
        end
    end
    begin
        abstract type GtkConstraint <: GObject end
        mutable struct GtkConstraintLeaf <: GtkConstraint
            handle::Ptr{GObject}
            function GtkConstraintLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkConstraintLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkConstraint] = GtkConstraintLeaf
        (GLib.g_type(::Type{T}) where T <: GtkConstraint) = begin
                ccall(("gtk_constraint_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkConstraintGuide <: GObject end
        mutable struct GtkConstraintGuideLeaf <: GtkConstraintGuide
            handle::Ptr{GObject}
            function GtkConstraintGuideLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkConstraintGuideLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkConstraintGuide] = GtkConstraintGuideLeaf
        (GLib.g_type(::Type{T}) where T <: GtkConstraintGuide) = begin
                ccall(("gtk_constraint_guide_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkConstraintLayout <: GtkLayoutManager end
        mutable struct GtkConstraintLayoutLeaf <: GtkConstraintLayout
            handle::Ptr{GObject}
            function GtkConstraintLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkConstraintLayoutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkConstraintLayout] = GtkConstraintLayoutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkConstraintLayout) = begin
                ccall(("gtk_constraint_layout_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkLayoutChild <: GObject end
        mutable struct GtkLayoutChildLeaf <: GtkLayoutChild
            handle::Ptr{GObject}
            function GtkLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLayoutChildLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkLayoutChild] = GtkLayoutChildLeaf
        (GLib.g_type(::Type{T}) where T <: GtkLayoutChild) = begin
                ccall(("gtk_layout_child_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkConstraintLayoutChild <: GtkLayoutChild end
        mutable struct GtkConstraintLayoutChildLeaf <: GtkConstraintLayoutChild
            handle::Ptr{GObject}
            function GtkConstraintLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkConstraintLayoutChildLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkConstraintLayoutChild] = GtkConstraintLayoutChildLeaf
        (GLib.g_type(::Type{T}) where T <: GtkConstraintLayoutChild) = begin
                ccall(("gtk_constraint_layout_child_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCssProvider <: GObject end
        mutable struct GtkCssProviderLeaf <: GtkCssProvider
            handle::Ptr{GObject}
            function GtkCssProviderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCssProviderLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCssProvider] = GtkCssProviderLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCssProvider) = begin
                ccall(("gtk_css_provider_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCustomFilter <: GtkFilter end
        mutable struct GtkCustomFilterLeaf <: GtkCustomFilter
            handle::Ptr{GObject}
            function GtkCustomFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCustomFilterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCustomFilter] = GtkCustomFilterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCustomFilter) = begin
                ccall(("gtk_custom_filter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCustomLayout <: GtkLayoutManager end
        mutable struct GtkCustomLayoutLeaf <: GtkCustomLayout
            handle::Ptr{GObject}
            function GtkCustomLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCustomLayoutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCustomLayout] = GtkCustomLayoutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCustomLayout) = begin
                ccall(("gtk_custom_layout_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkCustomSorter <: GtkSorter end
        mutable struct GtkCustomSorterLeaf <: GtkCustomSorter
            handle::Ptr{GObject}
            function GtkCustomSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkCustomSorterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkCustomSorter] = GtkCustomSorterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkCustomSorter) = begin
                ccall(("gtk_custom_sorter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkDirectoryList <: GObject end
        mutable struct GtkDirectoryListLeaf <: GtkDirectoryList
            handle::Ptr{GObject}
            function GtkDirectoryListLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDirectoryListLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkDirectoryList] = GtkDirectoryListLeaf
        (GLib.g_type(::Type{T}) where T <: GtkDirectoryList) = begin
                ccall(("gtk_directory_list_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkDragIcon <: GtkWidget end
        mutable struct GtkDragIconLeaf <: GtkDragIcon
            handle::Ptr{GObject}
            function GtkDragIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDragIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkDragIcon] = GtkDragIconLeaf
        (GLib.g_type(::Type{T}) where T <: GtkDragIcon) = begin
                ccall(("gtk_drag_icon_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEventController <: GObject end
        mutable struct GtkEventControllerLeaf <: GtkEventController
            handle::Ptr{GObject}
            function GtkEventControllerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEventController] = GtkEventControllerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEventController) = begin
                ccall(("gtk_event_controller_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGesture <: GtkEventController end
        mutable struct GtkGestureLeaf <: GtkGesture
            handle::Ptr{GObject}
            function GtkGestureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGesture] = GtkGestureLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGesture) = begin
                ccall(("gtk_gesture_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGestureSingle <: GtkGesture end
        mutable struct GtkGestureSingleLeaf <: GtkGestureSingle
            handle::Ptr{GObject}
            function GtkGestureSingleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureSingleLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGestureSingle] = GtkGestureSingleLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGestureSingle) = begin
                ccall(("gtk_gesture_single_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkDragSource <: GtkGestureSingle end
        mutable struct GtkDragSourceLeaf <: GtkDragSource
            handle::Ptr{GObject}
            function GtkDragSourceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDragSourceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkDragSource] = GtkDragSourceLeaf
        (GLib.g_type(::Type{T}) where T <: GtkDragSource) = begin
                ccall(("gtk_drag_source_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkDrawingArea <: GtkWidget end
        mutable struct GtkDrawingAreaLeaf <: GtkDrawingArea
            handle::Ptr{GObject}
            function GtkDrawingAreaLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDrawingAreaLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkDrawingArea] = GtkDrawingAreaLeaf
        (GLib.g_type(::Type{T}) where T <: GtkDrawingArea) = begin
                ccall(("gtk_drawing_area_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkDropControllerMotion <: GtkEventController end
        mutable struct GtkDropControllerMotionLeaf <: GtkDropControllerMotion
            handle::Ptr{GObject}
            function GtkDropControllerMotionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDropControllerMotionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkDropControllerMotion] = GtkDropControllerMotionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkDropControllerMotion) = begin
                ccall(("gtk_drop_controller_motion_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkDropDown <: GtkWidget end
        mutable struct GtkDropDownLeaf <: GtkDropDown
            handle::Ptr{GObject}
            function GtkDropDownLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDropDownLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkDropDown] = GtkDropDownLeaf
        (GLib.g_type(::Type{T}) where T <: GtkDropDown) = begin
                ccall(("gtk_drop_down_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkDropTarget <: GtkEventController end
        mutable struct GtkDropTargetLeaf <: GtkDropTarget
            handle::Ptr{GObject}
            function GtkDropTargetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDropTargetLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkDropTarget] = GtkDropTargetLeaf
        (GLib.g_type(::Type{T}) where T <: GtkDropTarget) = begin
                ccall(("gtk_drop_target_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkDropTargetAsync <: GtkEventController end
        mutable struct GtkDropTargetAsyncLeaf <: GtkDropTargetAsync
            handle::Ptr{GObject}
            function GtkDropTargetAsyncLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkDropTargetAsyncLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkDropTargetAsync] = GtkDropTargetAsyncLeaf
        (GLib.g_type(::Type{T}) where T <: GtkDropTargetAsync) = begin
                ccall(("gtk_drop_target_async_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEditableLabel <: GtkWidget end
        mutable struct GtkEditableLabelLeaf <: GtkEditableLabel
            handle::Ptr{GObject}
            function GtkEditableLabelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEditableLabelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEditableLabel] = GtkEditableLabelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEditableLabel) = begin
                ccall(("gtk_editable_label_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPopover <: GtkWidget end
        mutable struct GtkPopoverLeaf <: GtkPopover
            handle::Ptr{GObject}
            function GtkPopoverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPopoverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPopover] = GtkPopoverLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPopover) = begin
                ccall(("gtk_popover_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEmojiChooser <: GtkPopover end
        mutable struct GtkEmojiChooserLeaf <: GtkEmojiChooser
            handle::Ptr{GObject}
            function GtkEmojiChooserLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEmojiChooserLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEmojiChooser] = GtkEmojiChooserLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEmojiChooser) = begin
                ccall(("gtk_emoji_chooser_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEntry <: GtkWidget end
        mutable struct GtkEntryLeaf <: GtkEntry
            handle::Ptr{GObject}
            function GtkEntryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEntryLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEntry] = GtkEntryLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEntry) = begin
                ccall(("gtk_entry_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEntryBuffer <: GObject end
        mutable struct GtkEntryBufferLeaf <: GtkEntryBuffer
            handle::Ptr{GObject}
            function GtkEntryBufferLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEntryBufferLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEntryBuffer] = GtkEntryBufferLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEntryBuffer) = begin
                ccall(("gtk_entry_buffer_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEntryCompletion <: GObject end
        mutable struct GtkEntryCompletionLeaf <: GtkEntryCompletion
            handle::Ptr{GObject}
            function GtkEntryCompletionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEntryCompletionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEntryCompletion] = GtkEntryCompletionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEntryCompletion) = begin
                ccall(("gtk_entry_completion_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEventControllerFocus <: GtkEventController end
        mutable struct GtkEventControllerFocusLeaf <: GtkEventControllerFocus
            handle::Ptr{GObject}
            function GtkEventControllerFocusLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerFocusLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEventControllerFocus] = GtkEventControllerFocusLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEventControllerFocus) = begin
                ccall(("gtk_event_controller_focus_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEventControllerKey <: GtkEventController end
        mutable struct GtkEventControllerKeyLeaf <: GtkEventControllerKey
            handle::Ptr{GObject}
            function GtkEventControllerKeyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerKeyLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEventControllerKey] = GtkEventControllerKeyLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEventControllerKey) = begin
                ccall(("gtk_event_controller_key_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEventControllerLegacy <: GtkEventController end
        mutable struct GtkEventControllerLegacyLeaf <: GtkEventControllerLegacy
            handle::Ptr{GObject}
            function GtkEventControllerLegacyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerLegacyLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEventControllerLegacy] = GtkEventControllerLegacyLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEventControllerLegacy) = begin
                ccall(("gtk_event_controller_legacy_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEventControllerMotion <: GtkEventController end
        mutable struct GtkEventControllerMotionLeaf <: GtkEventControllerMotion
            handle::Ptr{GObject}
            function GtkEventControllerMotionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerMotionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEventControllerMotion] = GtkEventControllerMotionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEventControllerMotion) = begin
                ccall(("gtk_event_controller_motion_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEventControllerScroll <: GtkEventController end
        mutable struct GtkEventControllerScrollLeaf <: GtkEventControllerScroll
            handle::Ptr{GObject}
            function GtkEventControllerScrollLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEventControllerScrollLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEventControllerScroll] = GtkEventControllerScrollLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEventControllerScroll) = begin
                ccall(("gtk_event_controller_scroll_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkEveryFilter <: GtkMultiFilter end
        mutable struct GtkEveryFilterLeaf <: GtkEveryFilter
            handle::Ptr{GObject}
            function GtkEveryFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkEveryFilterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkEveryFilter] = GtkEveryFilterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkEveryFilter) = begin
                ccall(("gtk_every_filter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkExpander <: GtkWidget end
        mutable struct GtkExpanderLeaf <: GtkExpander
            handle::Ptr{GObject}
            function GtkExpanderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkExpanderLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkExpander] = GtkExpanderLeaf
        (GLib.g_type(::Type{T}) where T <: GtkExpander) = begin
                ccall(("gtk_expander_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFileChooserDialog <: GtkDialog end
        mutable struct GtkFileChooserDialogLeaf <: GtkFileChooserDialog
            handle::Ptr{GObject}
            function GtkFileChooserDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileChooserDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFileChooserDialog] = GtkFileChooserDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFileChooserDialog) = begin
                ccall(("gtk_file_chooser_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkNativeDialog <: GObject end
        mutable struct GtkNativeDialogLeaf <: GtkNativeDialog
            handle::Ptr{GObject}
            function GtkNativeDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNativeDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkNativeDialog] = GtkNativeDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkNativeDialog) = begin
                ccall(("gtk_native_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFileChooserNative <: GtkNativeDialog end
        mutable struct GtkFileChooserNativeLeaf <: GtkFileChooserNative
            handle::Ptr{GObject}
            function GtkFileChooserNativeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileChooserNativeLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFileChooserNative] = GtkFileChooserNativeLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFileChooserNative) = begin
                ccall(("gtk_file_chooser_native_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFileChooserWidget <: GtkWidget end
        mutable struct GtkFileChooserWidgetLeaf <: GtkFileChooserWidget
            handle::Ptr{GObject}
            function GtkFileChooserWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileChooserWidgetLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFileChooserWidget] = GtkFileChooserWidgetLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFileChooserWidget) = begin
                ccall(("gtk_file_chooser_widget_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFileDialog <: GObject end
        mutable struct GtkFileDialogLeaf <: GtkFileDialog
            handle::Ptr{GObject}
            function GtkFileDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFileDialog] = GtkFileDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFileDialog) = begin
                ccall(("gtk_file_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFileFilter <: GtkFilter end
        mutable struct GtkFileFilterLeaf <: GtkFileFilter
            handle::Ptr{GObject}
            function GtkFileFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileFilterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFileFilter] = GtkFileFilterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFileFilter) = begin
                ccall(("gtk_file_filter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFileLauncher <: GObject end
        mutable struct GtkFileLauncherLeaf <: GtkFileLauncher
            handle::Ptr{GObject}
            function GtkFileLauncherLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFileLauncherLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFileLauncher] = GtkFileLauncherLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFileLauncher) = begin
                ccall(("gtk_file_launcher_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFilterListModel <: GObject end
        mutable struct GtkFilterListModelLeaf <: GtkFilterListModel
            handle::Ptr{GObject}
            function GtkFilterListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFilterListModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFilterListModel] = GtkFilterListModelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFilterListModel) = begin
                ccall(("gtk_filter_list_model_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFixed <: GtkWidget end
        mutable struct GtkFixedLeaf <: GtkFixed
            handle::Ptr{GObject}
            function GtkFixedLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFixedLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFixed] = GtkFixedLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFixed) = begin
                ccall(("gtk_fixed_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFixedLayout <: GtkLayoutManager end
        mutable struct GtkFixedLayoutLeaf <: GtkFixedLayout
            handle::Ptr{GObject}
            function GtkFixedLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFixedLayoutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFixedLayout] = GtkFixedLayoutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFixedLayout) = begin
                ccall(("gtk_fixed_layout_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFixedLayoutChild <: GtkLayoutChild end
        mutable struct GtkFixedLayoutChildLeaf <: GtkFixedLayoutChild
            handle::Ptr{GObject}
            function GtkFixedLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFixedLayoutChildLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFixedLayoutChild] = GtkFixedLayoutChildLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFixedLayoutChild) = begin
                ccall(("gtk_fixed_layout_child_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFlattenListModel <: GObject end
        mutable struct GtkFlattenListModelLeaf <: GtkFlattenListModel
            handle::Ptr{GObject}
            function GtkFlattenListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFlattenListModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFlattenListModel] = GtkFlattenListModelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFlattenListModel) = begin
                ccall(("gtk_flatten_list_model_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFlowBox <: GtkWidget end
        mutable struct GtkFlowBoxLeaf <: GtkFlowBox
            handle::Ptr{GObject}
            function GtkFlowBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFlowBoxLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFlowBox] = GtkFlowBoxLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFlowBox) = begin
                ccall(("gtk_flow_box_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFlowBoxChild <: GtkWidget end
        mutable struct GtkFlowBoxChildLeaf <: GtkFlowBoxChild
            handle::Ptr{GObject}
            function GtkFlowBoxChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFlowBoxChildLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFlowBoxChild] = GtkFlowBoxChildLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFlowBoxChild) = begin
                ccall(("gtk_flow_box_child_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFontButton <: GtkWidget end
        mutable struct GtkFontButtonLeaf <: GtkFontButton
            handle::Ptr{GObject}
            function GtkFontButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFontButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFontButton] = GtkFontButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFontButton) = begin
                ccall(("gtk_font_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFontChooserDialog <: GtkDialog end
        mutable struct GtkFontChooserDialogLeaf <: GtkFontChooserDialog
            handle::Ptr{GObject}
            function GtkFontChooserDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFontChooserDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFontChooserDialog] = GtkFontChooserDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFontChooserDialog) = begin
                ccall(("gtk_font_chooser_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFontChooserWidget <: GtkWidget end
        mutable struct GtkFontChooserWidgetLeaf <: GtkFontChooserWidget
            handle::Ptr{GObject}
            function GtkFontChooserWidgetLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFontChooserWidgetLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFontChooserWidget] = GtkFontChooserWidgetLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFontChooserWidget) = begin
                ccall(("gtk_font_chooser_widget_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFontDialog <: GObject end
        mutable struct GtkFontDialogLeaf <: GtkFontDialog
            handle::Ptr{GObject}
            function GtkFontDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFontDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFontDialog] = GtkFontDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFontDialog) = begin
                ccall(("gtk_font_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFontDialogButton <: GtkWidget end
        mutable struct GtkFontDialogButtonLeaf <: GtkFontDialogButton
            handle::Ptr{GObject}
            function GtkFontDialogButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFontDialogButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFontDialogButton] = GtkFontDialogButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFontDialogButton) = begin
                ccall(("gtk_font_dialog_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkFrame <: GtkWidget end
        mutable struct GtkFrameLeaf <: GtkFrame
            handle::Ptr{GObject}
            function GtkFrameLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkFrameLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkFrame] = GtkFrameLeaf
        (GLib.g_type(::Type{T}) where T <: GtkFrame) = begin
                ccall(("gtk_frame_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGLArea <: GtkWidget end
        mutable struct GtkGLAreaLeaf <: GtkGLArea
            handle::Ptr{GObject}
            function GtkGLAreaLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGLAreaLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGLArea] = GtkGLAreaLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGLArea) = begin
                ccall(("gtk_gl_area_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGestureClick <: GtkGestureSingle end
        mutable struct GtkGestureClickLeaf <: GtkGestureClick
            handle::Ptr{GObject}
            function GtkGestureClickLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureClickLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGestureClick] = GtkGestureClickLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGestureClick) = begin
                ccall(("gtk_gesture_click_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGestureDrag <: GtkGestureSingle end
        mutable struct GtkGestureDragLeaf <: GtkGestureDrag
            handle::Ptr{GObject}
            function GtkGestureDragLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureDragLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGestureDrag] = GtkGestureDragLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGestureDrag) = begin
                ccall(("gtk_gesture_drag_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGestureLongPress <: GtkGestureSingle end
        mutable struct GtkGestureLongPressLeaf <: GtkGestureLongPress
            handle::Ptr{GObject}
            function GtkGestureLongPressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureLongPressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGestureLongPress] = GtkGestureLongPressLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGestureLongPress) = begin
                ccall(("gtk_gesture_long_press_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGesturePan <: GtkGestureDrag end
        mutable struct GtkGesturePanLeaf <: GtkGesturePan
            handle::Ptr{GObject}
            function GtkGesturePanLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGesturePanLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGesturePan] = GtkGesturePanLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGesturePan) = begin
                ccall(("gtk_gesture_pan_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGestureRotate <: GtkGesture end
        mutable struct GtkGestureRotateLeaf <: GtkGestureRotate
            handle::Ptr{GObject}
            function GtkGestureRotateLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureRotateLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGestureRotate] = GtkGestureRotateLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGestureRotate) = begin
                ccall(("gtk_gesture_rotate_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGestureStylus <: GtkGestureSingle end
        mutable struct GtkGestureStylusLeaf <: GtkGestureStylus
            handle::Ptr{GObject}
            function GtkGestureStylusLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureStylusLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGestureStylus] = GtkGestureStylusLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGestureStylus) = begin
                ccall(("gtk_gesture_stylus_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGestureSwipe <: GtkGestureSingle end
        mutable struct GtkGestureSwipeLeaf <: GtkGestureSwipe
            handle::Ptr{GObject}
            function GtkGestureSwipeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureSwipeLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGestureSwipe] = GtkGestureSwipeLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGestureSwipe) = begin
                ccall(("gtk_gesture_swipe_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGestureZoom <: GtkGesture end
        mutable struct GtkGestureZoomLeaf <: GtkGestureZoom
            handle::Ptr{GObject}
            function GtkGestureZoomLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGestureZoomLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGestureZoom] = GtkGestureZoomLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGestureZoom) = begin
                ccall(("gtk_gesture_zoom_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGrid <: GtkWidget end
        mutable struct GtkGridLeaf <: GtkGrid
            handle::Ptr{GObject}
            function GtkGridLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGridLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGrid] = GtkGridLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGrid) = begin
                ccall(("gtk_grid_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGridLayout <: GtkLayoutManager end
        mutable struct GtkGridLayoutLeaf <: GtkGridLayout
            handle::Ptr{GObject}
            function GtkGridLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGridLayoutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGridLayout] = GtkGridLayoutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGridLayout) = begin
                ccall(("gtk_grid_layout_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGridLayoutChild <: GtkLayoutChild end
        mutable struct GtkGridLayoutChildLeaf <: GtkGridLayoutChild
            handle::Ptr{GObject}
            function GtkGridLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGridLayoutChildLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGridLayoutChild] = GtkGridLayoutChildLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGridLayoutChild) = begin
                ccall(("gtk_grid_layout_child_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkListBase <: GtkWidget end
        mutable struct GtkListBaseLeaf <: GtkListBase
            handle::Ptr{GObject}
            function GtkListBaseLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListBaseLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkListBase] = GtkListBaseLeaf
        (GLib.g_type(::Type{T}) where T <: GtkListBase) = begin
                ccall(("gtk_list_base_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkGridView <: GtkListBase end
        mutable struct GtkGridViewLeaf <: GtkGridView
            handle::Ptr{GObject}
            function GtkGridViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkGridViewLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkGridView] = GtkGridViewLeaf
        (GLib.g_type(::Type{T}) where T <: GtkGridView) = begin
                ccall(("gtk_grid_view_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkHeaderBar <: GtkWidget end
        mutable struct GtkHeaderBarLeaf <: GtkHeaderBar
            handle::Ptr{GObject}
            function GtkHeaderBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkHeaderBarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkHeaderBar] = GtkHeaderBarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkHeaderBar) = begin
                ccall(("gtk_header_bar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkIMContext <: GObject end
        mutable struct GtkIMContextLeaf <: GtkIMContext
            handle::Ptr{GObject}
            function GtkIMContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIMContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkIMContext] = GtkIMContextLeaf
        (GLib.g_type(::Type{T}) where T <: GtkIMContext) = begin
                ccall(("gtk_im_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkIMContextSimple <: GtkIMContext end
        mutable struct GtkIMContextSimpleLeaf <: GtkIMContextSimple
            handle::Ptr{GObject}
            function GtkIMContextSimpleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIMContextSimpleLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkIMContextSimple] = GtkIMContextSimpleLeaf
        (GLib.g_type(::Type{T}) where T <: GtkIMContextSimple) = begin
                ccall(("gtk_im_context_simple_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkIMMulticontext <: GtkIMContext end
        mutable struct GtkIMMulticontextLeaf <: GtkIMMulticontext
            handle::Ptr{GObject}
            function GtkIMMulticontextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIMMulticontextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkIMMulticontext] = GtkIMMulticontextLeaf
        (GLib.g_type(::Type{T}) where T <: GtkIMMulticontext) = begin
                ccall(("gtk_im_multicontext_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkIconPaintable <: GObject end
        mutable struct GtkIconPaintableLeaf <: GtkIconPaintable
            handle::Ptr{GObject}
            function GtkIconPaintableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIconPaintableLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkIconPaintable] = GtkIconPaintableLeaf
        (GLib.g_type(::Type{T}) where T <: GtkIconPaintable) = begin
                ccall(("gtk_icon_paintable_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkIconTheme <: GObject end
        mutable struct GtkIconThemeLeaf <: GtkIconTheme
            handle::Ptr{GObject}
            function GtkIconThemeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIconThemeLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkIconTheme] = GtkIconThemeLeaf
        (GLib.g_type(::Type{T}) where T <: GtkIconTheme) = begin
                ccall(("gtk_icon_theme_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkIconView <: GtkWidget end
        mutable struct GtkIconViewLeaf <: GtkIconView
            handle::Ptr{GObject}
            function GtkIconViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkIconViewLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkIconView] = GtkIconViewLeaf
        (GLib.g_type(::Type{T}) where T <: GtkIconView) = begin
                ccall(("gtk_icon_view_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkImage <: GtkWidget end
        mutable struct GtkImageLeaf <: GtkImage
            handle::Ptr{GObject}
            function GtkImageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkImageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkImage] = GtkImageLeaf
        (GLib.g_type(::Type{T}) where T <: GtkImage) = begin
                ccall(("gtk_image_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkInfoBar <: GtkWidget end
        mutable struct GtkInfoBarLeaf <: GtkInfoBar
            handle::Ptr{GObject}
            function GtkInfoBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkInfoBarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkInfoBar] = GtkInfoBarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkInfoBar) = begin
                ccall(("gtk_info_bar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkInscription <: GtkWidget end
        mutable struct GtkInscriptionLeaf <: GtkInscription
            handle::Ptr{GObject}
            function GtkInscriptionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkInscriptionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkInscription] = GtkInscriptionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkInscription) = begin
                ccall(("gtk_inscription_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkKeyvalTrigger <: GtkShortcutTrigger end
        mutable struct GtkKeyvalTriggerLeaf <: GtkKeyvalTrigger
            handle::Ptr{GObject}
            function GtkKeyvalTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkKeyvalTriggerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkKeyvalTrigger] = GtkKeyvalTriggerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkKeyvalTrigger) = begin
                ccall(("gtk_keyval_trigger_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkLabel <: GtkWidget end
        mutable struct GtkLabelLeaf <: GtkLabel
            handle::Ptr{GObject}
            function GtkLabelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLabelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkLabel] = GtkLabelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkLabel) = begin
                ccall(("gtk_label_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkLevelBar <: GtkWidget end
        mutable struct GtkLevelBarLeaf <: GtkLevelBar
            handle::Ptr{GObject}
            function GtkLevelBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLevelBarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkLevelBar] = GtkLevelBarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkLevelBar) = begin
                ccall(("gtk_level_bar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkLinkButton <: GtkButton end
        mutable struct GtkLinkButtonLeaf <: GtkLinkButton
            handle::Ptr{GObject}
            function GtkLinkButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLinkButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkLinkButton] = GtkLinkButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkLinkButton) = begin
                ccall(("gtk_link_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkListBox <: GtkWidget end
        mutable struct GtkListBoxLeaf <: GtkListBox
            handle::Ptr{GObject}
            function GtkListBoxLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListBoxLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkListBox] = GtkListBoxLeaf
        (GLib.g_type(::Type{T}) where T <: GtkListBox) = begin
                ccall(("gtk_list_box_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkListBoxRow <: GtkWidget end
        mutable struct GtkListBoxRowLeaf <: GtkListBoxRow
            handle::Ptr{GObject}
            function GtkListBoxRowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListBoxRowLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkListBoxRow] = GtkListBoxRowLeaf
        (GLib.g_type(::Type{T}) where T <: GtkListBoxRow) = begin
                ccall(("gtk_list_box_row_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkListItem <: GObject end
        mutable struct GtkListItemLeaf <: GtkListItem
            handle::Ptr{GObject}
            function GtkListItemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListItemLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkListItem] = GtkListItemLeaf
        (GLib.g_type(::Type{T}) where T <: GtkListItem) = begin
                ccall(("gtk_list_item_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkListStore <: GObject end
        mutable struct GtkListStoreLeaf <: GtkListStore
            handle::Ptr{GObject}
            function GtkListStoreLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListStoreLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkListStore] = GtkListStoreLeaf
        (GLib.g_type(::Type{T}) where T <: GtkListStore) = begin
                ccall(("gtk_list_store_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkListView <: GtkListBase end
        mutable struct GtkListViewLeaf <: GtkListView
            handle::Ptr{GObject}
            function GtkListViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkListViewLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkListView] = GtkListViewLeaf
        (GLib.g_type(::Type{T}) where T <: GtkListView) = begin
                ccall(("gtk_list_view_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkLockButton <: GtkButton end
        mutable struct GtkLockButtonLeaf <: GtkLockButton
            handle::Ptr{GObject}
            function GtkLockButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkLockButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkLockButton] = GtkLockButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkLockButton) = begin
                ccall(("gtk_lock_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMapListModel <: GObject end
        mutable struct GtkMapListModelLeaf <: GtkMapListModel
            handle::Ptr{GObject}
            function GtkMapListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMapListModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMapListModel] = GtkMapListModelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMapListModel) = begin
                ccall(("gtk_map_list_model_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMediaControls <: GtkWidget end
        mutable struct GtkMediaControlsLeaf <: GtkMediaControls
            handle::Ptr{GObject}
            function GtkMediaControlsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMediaControlsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMediaControls] = GtkMediaControlsLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMediaControls) = begin
                ccall(("gtk_media_controls_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMediaStream <: GObject end
        mutable struct GtkMediaStreamLeaf <: GtkMediaStream
            handle::Ptr{GObject}
            function GtkMediaStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMediaStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMediaStream] = GtkMediaStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMediaStream) = begin
                ccall(("gtk_media_stream_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMediaFile <: GtkMediaStream end
        mutable struct GtkMediaFileLeaf <: GtkMediaFile
            handle::Ptr{GObject}
            function GtkMediaFileLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMediaFileLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMediaFile] = GtkMediaFileLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMediaFile) = begin
                ccall(("gtk_media_file_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMenuButton <: GtkWidget end
        mutable struct GtkMenuButtonLeaf <: GtkMenuButton
            handle::Ptr{GObject}
            function GtkMenuButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMenuButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMenuButton] = GtkMenuButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMenuButton) = begin
                ccall(("gtk_menu_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMessageDialog <: GtkDialog end
        mutable struct GtkMessageDialogLeaf <: GtkMessageDialog
            handle::Ptr{GObject}
            function GtkMessageDialogLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMessageDialogLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMessageDialog] = GtkMessageDialogLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMessageDialog) = begin
                ccall(("gtk_message_dialog_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMnemonicAction <: GtkShortcutAction end
        mutable struct GtkMnemonicActionLeaf <: GtkMnemonicAction
            handle::Ptr{GObject}
            function GtkMnemonicActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMnemonicActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMnemonicAction] = GtkMnemonicActionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMnemonicAction) = begin
                ccall(("gtk_mnemonic_action_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMnemonicTrigger <: GtkShortcutTrigger end
        mutable struct GtkMnemonicTriggerLeaf <: GtkMnemonicTrigger
            handle::Ptr{GObject}
            function GtkMnemonicTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMnemonicTriggerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMnemonicTrigger] = GtkMnemonicTriggerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMnemonicTrigger) = begin
                ccall(("gtk_mnemonic_trigger_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMountOperation <: GMountOperation end
        mutable struct GtkMountOperationLeaf <: GtkMountOperation
            handle::Ptr{GObject}
            function GtkMountOperationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMountOperationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMountOperation] = GtkMountOperationLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMountOperation) = begin
                ccall(("gtk_mount_operation_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMultiSelection <: GObject end
        mutable struct GtkMultiSelectionLeaf <: GtkMultiSelection
            handle::Ptr{GObject}
            function GtkMultiSelectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMultiSelectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMultiSelection] = GtkMultiSelectionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMultiSelection) = begin
                ccall(("gtk_multi_selection_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkMultiSorter <: GtkSorter end
        mutable struct GtkMultiSorterLeaf <: GtkMultiSorter
            handle::Ptr{GObject}
            function GtkMultiSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkMultiSorterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkMultiSorter] = GtkMultiSorterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkMultiSorter) = begin
                ccall(("gtk_multi_sorter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkNamedAction <: GtkShortcutAction end
        mutable struct GtkNamedActionLeaf <: GtkNamedAction
            handle::Ptr{GObject}
            function GtkNamedActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNamedActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkNamedAction] = GtkNamedActionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkNamedAction) = begin
                ccall(("gtk_named_action_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkNeverTrigger <: GtkShortcutTrigger end
        mutable struct GtkNeverTriggerLeaf <: GtkNeverTrigger
            handle::Ptr{GObject}
            function GtkNeverTriggerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNeverTriggerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkNeverTrigger] = GtkNeverTriggerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkNeverTrigger) = begin
                ccall(("gtk_never_trigger_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkNoSelection <: GObject end
        mutable struct GtkNoSelectionLeaf <: GtkNoSelection
            handle::Ptr{GObject}
            function GtkNoSelectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNoSelectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkNoSelection] = GtkNoSelectionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkNoSelection) = begin
                ccall(("gtk_no_selection_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkNotebook <: GtkWidget end
        mutable struct GtkNotebookLeaf <: GtkNotebook
            handle::Ptr{GObject}
            function GtkNotebookLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNotebookLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkNotebook] = GtkNotebookLeaf
        (GLib.g_type(::Type{T}) where T <: GtkNotebook) = begin
                ccall(("gtk_notebook_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkNotebookPage <: GObject end
        mutable struct GtkNotebookPageLeaf <: GtkNotebookPage
            handle::Ptr{GObject}
            function GtkNotebookPageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNotebookPageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkNotebookPage] = GtkNotebookPageLeaf
        (GLib.g_type(::Type{T}) where T <: GtkNotebookPage) = begin
                ccall(("gtk_notebook_page_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkNothingAction <: GtkShortcutAction end
        mutable struct GtkNothingActionLeaf <: GtkNothingAction
            handle::Ptr{GObject}
            function GtkNothingActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNothingActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkNothingAction] = GtkNothingActionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkNothingAction) = begin
                ccall(("gtk_nothing_action_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkNumericSorter <: GtkSorter end
        mutable struct GtkNumericSorterLeaf <: GtkNumericSorter
            handle::Ptr{GObject}
            function GtkNumericSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkNumericSorterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkNumericSorter] = GtkNumericSorterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkNumericSorter) = begin
                ccall(("gtk_numeric_sorter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkObjectExpression <: GtkExpression end
    end
    begin
        mutable struct GtkObjectExpressionLeaf <: GtkObjectExpression
            handle::Ptr{GtkExpression}
        end
    end
    begin
        abstract type GtkOverlay <: GtkWidget end
        mutable struct GtkOverlayLeaf <: GtkOverlay
            handle::Ptr{GObject}
            function GtkOverlayLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkOverlayLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkOverlay] = GtkOverlayLeaf
        (GLib.g_type(::Type{T}) where T <: GtkOverlay) = begin
                ccall(("gtk_overlay_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkOverlayLayout <: GtkLayoutManager end
        mutable struct GtkOverlayLayoutLeaf <: GtkOverlayLayout
            handle::Ptr{GObject}
            function GtkOverlayLayoutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkOverlayLayoutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkOverlayLayout] = GtkOverlayLayoutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkOverlayLayout) = begin
                ccall(("gtk_overlay_layout_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkOverlayLayoutChild <: GtkLayoutChild end
        mutable struct GtkOverlayLayoutChildLeaf <: GtkOverlayLayoutChild
            handle::Ptr{GObject}
            function GtkOverlayLayoutChildLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkOverlayLayoutChildLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkOverlayLayoutChild] = GtkOverlayLayoutChildLeaf
        (GLib.g_type(::Type{T}) where T <: GtkOverlayLayoutChild) = begin
                ccall(("gtk_overlay_layout_child_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPadController <: GtkEventController end
        mutable struct GtkPadControllerLeaf <: GtkPadController
            handle::Ptr{GObject}
            function GtkPadControllerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPadControllerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPadController] = GtkPadControllerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPadController) = begin
                ccall(("gtk_pad_controller_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPageSetup <: GObject end
        mutable struct GtkPageSetupLeaf <: GtkPageSetup
            handle::Ptr{GObject}
            function GtkPageSetupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPageSetupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPageSetup] = GtkPageSetupLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPageSetup) = begin
                ccall(("gtk_page_setup_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPaned <: GtkWidget end
        mutable struct GtkPanedLeaf <: GtkPaned
            handle::Ptr{GObject}
            function GtkPanedLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPanedLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPaned] = GtkPanedLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPaned) = begin
                ccall(("gtk_paned_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPasswordEntry <: GtkWidget end
        mutable struct GtkPasswordEntryLeaf <: GtkPasswordEntry
            handle::Ptr{GObject}
            function GtkPasswordEntryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPasswordEntryLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPasswordEntry] = GtkPasswordEntryLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPasswordEntry) = begin
                ccall(("gtk_password_entry_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPasswordEntryBuffer <: GtkEntryBuffer end
        mutable struct GtkPasswordEntryBufferLeaf <: GtkPasswordEntryBuffer
            handle::Ptr{GObject}
            function GtkPasswordEntryBufferLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPasswordEntryBufferLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPasswordEntryBuffer] = GtkPasswordEntryBufferLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPasswordEntryBuffer) = begin
                ccall(("gtk_password_entry_buffer_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPicture <: GtkWidget end
        mutable struct GtkPictureLeaf <: GtkPicture
            handle::Ptr{GObject}
            function GtkPictureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPictureLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPicture] = GtkPictureLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPicture) = begin
                ccall(("gtk_picture_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPopoverMenu <: GtkPopover end
        mutable struct GtkPopoverMenuLeaf <: GtkPopoverMenu
            handle::Ptr{GObject}
            function GtkPopoverMenuLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPopoverMenuLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPopoverMenu] = GtkPopoverMenuLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPopoverMenu) = begin
                ccall(("gtk_popover_menu_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPopoverMenuBar <: GtkWidget end
        mutable struct GtkPopoverMenuBarLeaf <: GtkPopoverMenuBar
            handle::Ptr{GObject}
            function GtkPopoverMenuBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPopoverMenuBarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPopoverMenuBar] = GtkPopoverMenuBarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPopoverMenuBar) = begin
                ccall(("gtk_popover_menu_bar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPrintContext <: GObject end
        mutable struct GtkPrintContextLeaf <: GtkPrintContext
            handle::Ptr{GObject}
            function GtkPrintContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrintContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPrintContext] = GtkPrintContextLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPrintContext) = begin
                ccall(("gtk_print_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPrintJob <: GObject end
        mutable struct GtkPrintJobLeaf <: GtkPrintJob
            handle::Ptr{GObject}
            function GtkPrintJobLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrintJobLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPrintJob] = GtkPrintJobLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPrintJob) = begin
                ccall(("gtk_print_job_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPrintOperation <: GObject end
        mutable struct GtkPrintOperationLeaf <: GtkPrintOperation
            handle::Ptr{GObject}
            function GtkPrintOperationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrintOperationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPrintOperation] = GtkPrintOperationLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPrintOperation) = begin
                ccall(("gtk_print_operation_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPrintSettings <: GObject end
        mutable struct GtkPrintSettingsLeaf <: GtkPrintSettings
            handle::Ptr{GObject}
            function GtkPrintSettingsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrintSettingsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPrintSettings] = GtkPrintSettingsLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPrintSettings) = begin
                ccall(("gtk_print_settings_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPrinter <: GObject end
        mutable struct GtkPrinterLeaf <: GtkPrinter
            handle::Ptr{GObject}
            function GtkPrinterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkPrinterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkPrinter] = GtkPrinterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkPrinter) = begin
                ccall(("gtk_printer_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkProgressBar <: GtkWidget end
        mutable struct GtkProgressBarLeaf <: GtkProgressBar
            handle::Ptr{GObject}
            function GtkProgressBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkProgressBarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkProgressBar] = GtkProgressBarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkProgressBar) = begin
                ccall(("gtk_progress_bar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkPropertyExpression <: GtkExpression end
    end
    begin
        mutable struct GtkPropertyExpressionLeaf <: GtkPropertyExpression
            handle::Ptr{GtkExpression}
        end
    end
    begin
        abstract type GtkRange <: GtkWidget end
        mutable struct GtkRangeLeaf <: GtkRange
            handle::Ptr{GObject}
            function GtkRangeLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkRangeLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkRange] = GtkRangeLeaf
        (GLib.g_type(::Type{T}) where T <: GtkRange) = begin
                ccall(("gtk_range_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkRecentManager <: GObject end
        mutable struct GtkRecentManagerLeaf <: GtkRecentManager
            handle::Ptr{GObject}
            function GtkRecentManagerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkRecentManagerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkRecentManager] = GtkRecentManagerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkRecentManager) = begin
                ccall(("gtk_recent_manager_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkRevealer <: GtkWidget end
        mutable struct GtkRevealerLeaf <: GtkRevealer
            handle::Ptr{GObject}
            function GtkRevealerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkRevealerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkRevealer] = GtkRevealerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkRevealer) = begin
                ccall(("gtk_revealer_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkScale <: GtkRange end
        mutable struct GtkScaleLeaf <: GtkScale
            handle::Ptr{GObject}
            function GtkScaleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkScaleLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkScale] = GtkScaleLeaf
        (GLib.g_type(::Type{T}) where T <: GtkScale) = begin
                ccall(("gtk_scale_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkScaleButton <: GtkWidget end
        mutable struct GtkScaleButtonLeaf <: GtkScaleButton
            handle::Ptr{GObject}
            function GtkScaleButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkScaleButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkScaleButton] = GtkScaleButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkScaleButton) = begin
                ccall(("gtk_scale_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkScrollbar <: GtkWidget end
        mutable struct GtkScrollbarLeaf <: GtkScrollbar
            handle::Ptr{GObject}
            function GtkScrollbarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkScrollbarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkScrollbar] = GtkScrollbarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkScrollbar) = begin
                ccall(("gtk_scrollbar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkScrolledWindow <: GtkWidget end
        mutable struct GtkScrolledWindowLeaf <: GtkScrolledWindow
            handle::Ptr{GObject}
            function GtkScrolledWindowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkScrolledWindowLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkScrolledWindow] = GtkScrolledWindowLeaf
        (GLib.g_type(::Type{T}) where T <: GtkScrolledWindow) = begin
                ccall(("gtk_scrolled_window_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSearchBar <: GtkWidget end
        mutable struct GtkSearchBarLeaf <: GtkSearchBar
            handle::Ptr{GObject}
            function GtkSearchBarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSearchBarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSearchBar] = GtkSearchBarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSearchBar) = begin
                ccall(("gtk_search_bar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSearchEntry <: GtkWidget end
        mutable struct GtkSearchEntryLeaf <: GtkSearchEntry
            handle::Ptr{GObject}
            function GtkSearchEntryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSearchEntryLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSearchEntry] = GtkSearchEntryLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSearchEntry) = begin
                ccall(("gtk_search_entry_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSelectionFilterModel <: GObject end
        mutable struct GtkSelectionFilterModelLeaf <: GtkSelectionFilterModel
            handle::Ptr{GObject}
            function GtkSelectionFilterModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSelectionFilterModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSelectionFilterModel] = GtkSelectionFilterModelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSelectionFilterModel) = begin
                ccall(("gtk_selection_filter_model_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSeparator <: GtkWidget end
        mutable struct GtkSeparatorLeaf <: GtkSeparator
            handle::Ptr{GObject}
            function GtkSeparatorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSeparatorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSeparator] = GtkSeparatorLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSeparator) = begin
                ccall(("gtk_separator_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSettings <: GObject end
        mutable struct GtkSettingsLeaf <: GtkSettings
            handle::Ptr{GObject}
            function GtkSettingsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSettingsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSettings] = GtkSettingsLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSettings) = begin
                ccall(("gtk_settings_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkShortcut <: GObject end
        mutable struct GtkShortcutLeaf <: GtkShortcut
            handle::Ptr{GObject}
            function GtkShortcutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkShortcut] = GtkShortcutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkShortcut) = begin
                ccall(("gtk_shortcut_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkShortcutController <: GtkEventController end
        mutable struct GtkShortcutControllerLeaf <: GtkShortcutController
            handle::Ptr{GObject}
            function GtkShortcutControllerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutControllerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkShortcutController] = GtkShortcutControllerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkShortcutController) = begin
                ccall(("gtk_shortcut_controller_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkShortcutLabel <: GtkWidget end
        mutable struct GtkShortcutLabelLeaf <: GtkShortcutLabel
            handle::Ptr{GObject}
            function GtkShortcutLabelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutLabelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkShortcutLabel] = GtkShortcutLabelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkShortcutLabel) = begin
                ccall(("gtk_shortcut_label_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkShortcutsGroup <: GtkBox end
        mutable struct GtkShortcutsGroupLeaf <: GtkShortcutsGroup
            handle::Ptr{GObject}
            function GtkShortcutsGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkShortcutsGroup] = GtkShortcutsGroupLeaf
        (GLib.g_type(::Type{T}) where T <: GtkShortcutsGroup) = begin
                ccall(("gtk_shortcuts_group_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkShortcutsSection <: GtkBox end
        mutable struct GtkShortcutsSectionLeaf <: GtkShortcutsSection
            handle::Ptr{GObject}
            function GtkShortcutsSectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsSectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkShortcutsSection] = GtkShortcutsSectionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkShortcutsSection) = begin
                ccall(("gtk_shortcuts_section_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkShortcutsShortcut <: GtkWidget end
        mutable struct GtkShortcutsShortcutLeaf <: GtkShortcutsShortcut
            handle::Ptr{GObject}
            function GtkShortcutsShortcutLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsShortcutLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkShortcutsShortcut] = GtkShortcutsShortcutLeaf
        (GLib.g_type(::Type{T}) where T <: GtkShortcutsShortcut) = begin
                ccall(("gtk_shortcuts_shortcut_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkShortcutsWindow <: GtkWindow end
        mutable struct GtkShortcutsWindowLeaf <: GtkShortcutsWindow
            handle::Ptr{GObject}
            function GtkShortcutsWindowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkShortcutsWindowLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkShortcutsWindow] = GtkShortcutsWindowLeaf
        (GLib.g_type(::Type{T}) where T <: GtkShortcutsWindow) = begin
                ccall(("gtk_shortcuts_window_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSignalAction <: GtkShortcutAction end
        mutable struct GtkSignalActionLeaf <: GtkSignalAction
            handle::Ptr{GObject}
            function GtkSignalActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSignalActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSignalAction] = GtkSignalActionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSignalAction) = begin
                ccall(("gtk_signal_action_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSignalListItemFactory <: GtkListItemFactory end
        mutable struct GtkSignalListItemFactoryLeaf <: GtkSignalListItemFactory
            handle::Ptr{GObject}
            function GtkSignalListItemFactoryLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSignalListItemFactoryLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSignalListItemFactory] = GtkSignalListItemFactoryLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSignalListItemFactory) = begin
                ccall(("gtk_signal_list_item_factory_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSingleSelection <: GObject end
        mutable struct GtkSingleSelectionLeaf <: GtkSingleSelection
            handle::Ptr{GObject}
            function GtkSingleSelectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSingleSelectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSingleSelection] = GtkSingleSelectionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSingleSelection) = begin
                ccall(("gtk_single_selection_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSizeGroup <: GObject end
        mutable struct GtkSizeGroupLeaf <: GtkSizeGroup
            handle::Ptr{GObject}
            function GtkSizeGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSizeGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSizeGroup] = GtkSizeGroupLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSizeGroup) = begin
                ccall(("gtk_size_group_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSliceListModel <: GObject end
        mutable struct GtkSliceListModelLeaf <: GtkSliceListModel
            handle::Ptr{GObject}
            function GtkSliceListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSliceListModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSliceListModel] = GtkSliceListModelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSliceListModel) = begin
                ccall(("gtk_slice_list_model_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSnapshot <: GdkSnapshot end
        mutable struct GtkSnapshotLeaf <: GtkSnapshot
            handle::Ptr{GObject}
            function GtkSnapshotLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSnapshotLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSnapshot] = GtkSnapshotLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSnapshot) = begin
                ccall(("gtk_snapshot_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSortListModel <: GObject end
        mutable struct GtkSortListModelLeaf <: GtkSortListModel
            handle::Ptr{GObject}
            function GtkSortListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSortListModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSortListModel] = GtkSortListModelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSortListModel) = begin
                ccall(("gtk_sort_list_model_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSpinButton <: GtkWidget end
        mutable struct GtkSpinButtonLeaf <: GtkSpinButton
            handle::Ptr{GObject}
            function GtkSpinButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSpinButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSpinButton] = GtkSpinButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSpinButton) = begin
                ccall(("gtk_spin_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSpinner <: GtkWidget end
        mutable struct GtkSpinnerLeaf <: GtkSpinner
            handle::Ptr{GObject}
            function GtkSpinnerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSpinnerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSpinner] = GtkSpinnerLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSpinner) = begin
                ccall(("gtk_spinner_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStack <: GtkWidget end
        mutable struct GtkStackLeaf <: GtkStack
            handle::Ptr{GObject}
            function GtkStackLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStackLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStack] = GtkStackLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStack) = begin
                ccall(("gtk_stack_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStackPage <: GObject end
        mutable struct GtkStackPageLeaf <: GtkStackPage
            handle::Ptr{GObject}
            function GtkStackPageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStackPageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStackPage] = GtkStackPageLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStackPage) = begin
                ccall(("gtk_stack_page_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStackSidebar <: GtkWidget end
        mutable struct GtkStackSidebarLeaf <: GtkStackSidebar
            handle::Ptr{GObject}
            function GtkStackSidebarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStackSidebarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStackSidebar] = GtkStackSidebarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStackSidebar) = begin
                ccall(("gtk_stack_sidebar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStackSwitcher <: GtkWidget end
        mutable struct GtkStackSwitcherLeaf <: GtkStackSwitcher
            handle::Ptr{GObject}
            function GtkStackSwitcherLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStackSwitcherLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStackSwitcher] = GtkStackSwitcherLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStackSwitcher) = begin
                ccall(("gtk_stack_switcher_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStatusbar <: GtkWidget end
        mutable struct GtkStatusbarLeaf <: GtkStatusbar
            handle::Ptr{GObject}
            function GtkStatusbarLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStatusbarLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStatusbar] = GtkStatusbarLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStatusbar) = begin
                ccall(("gtk_statusbar_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStringFilter <: GtkFilter end
        mutable struct GtkStringFilterLeaf <: GtkStringFilter
            handle::Ptr{GObject}
            function GtkStringFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStringFilterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStringFilter] = GtkStringFilterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStringFilter) = begin
                ccall(("gtk_string_filter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStringList <: GObject end
        mutable struct GtkStringListLeaf <: GtkStringList
            handle::Ptr{GObject}
            function GtkStringListLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStringListLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStringList] = GtkStringListLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStringList) = begin
                ccall(("gtk_string_list_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStringObject <: GObject end
        mutable struct GtkStringObjectLeaf <: GtkStringObject
            handle::Ptr{GObject}
            function GtkStringObjectLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStringObjectLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStringObject] = GtkStringObjectLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStringObject) = begin
                ccall(("gtk_string_object_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStringSorter <: GtkSorter end
        mutable struct GtkStringSorterLeaf <: GtkStringSorter
            handle::Ptr{GObject}
            function GtkStringSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStringSorterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStringSorter] = GtkStringSorterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStringSorter) = begin
                ccall(("gtk_string_sorter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkStyleContext <: GObject end
        mutable struct GtkStyleContextLeaf <: GtkStyleContext
            handle::Ptr{GObject}
            function GtkStyleContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkStyleContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkStyleContext] = GtkStyleContextLeaf
        (GLib.g_type(::Type{T}) where T <: GtkStyleContext) = begin
                ccall(("gtk_style_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkSwitch <: GtkWidget end
        mutable struct GtkSwitchLeaf <: GtkSwitch
            handle::Ptr{GObject}
            function GtkSwitchLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkSwitchLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkSwitch] = GtkSwitchLeaf
        (GLib.g_type(::Type{T}) where T <: GtkSwitch) = begin
                ccall(("gtk_switch_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkText <: GtkWidget end
        mutable struct GtkTextLeaf <: GtkText
            handle::Ptr{GObject}
            function GtkTextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkText] = GtkTextLeaf
        (GLib.g_type(::Type{T}) where T <: GtkText) = begin
                ccall(("gtk_text_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTextBuffer <: GObject end
        mutable struct GtkTextBufferLeaf <: GtkTextBuffer
            handle::Ptr{GObject}
            function GtkTextBufferLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextBufferLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTextBuffer] = GtkTextBufferLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTextBuffer) = begin
                ccall(("gtk_text_buffer_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTextChildAnchor <: GObject end
        mutable struct GtkTextChildAnchorLeaf <: GtkTextChildAnchor
            handle::Ptr{GObject}
            function GtkTextChildAnchorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextChildAnchorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTextChildAnchor] = GtkTextChildAnchorLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTextChildAnchor) = begin
                ccall(("gtk_text_child_anchor_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTextMark <: GObject end
        mutable struct GtkTextMarkLeaf <: GtkTextMark
            handle::Ptr{GObject}
            function GtkTextMarkLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextMarkLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTextMark] = GtkTextMarkLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTextMark) = begin
                ccall(("gtk_text_mark_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTextTag <: GObject end
        mutable struct GtkTextTagLeaf <: GtkTextTag
            handle::Ptr{GObject}
            function GtkTextTagLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextTagLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTextTag] = GtkTextTagLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTextTag) = begin
                ccall(("gtk_text_tag_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTextTagTable <: GObject end
        mutable struct GtkTextTagTableLeaf <: GtkTextTagTable
            handle::Ptr{GObject}
            function GtkTextTagTableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextTagTableLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTextTagTable] = GtkTextTagTableLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTextTagTable) = begin
                ccall(("gtk_text_tag_table_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTextView <: GtkWidget end
        mutable struct GtkTextViewLeaf <: GtkTextView
            handle::Ptr{GObject}
            function GtkTextViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTextViewLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTextView] = GtkTextViewLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTextView) = begin
                ccall(("gtk_text_view_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkToggleButton <: GtkButton end
        mutable struct GtkToggleButtonLeaf <: GtkToggleButton
            handle::Ptr{GObject}
            function GtkToggleButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkToggleButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkToggleButton] = GtkToggleButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkToggleButton) = begin
                ccall(("gtk_toggle_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTooltip <: GObject end
        mutable struct GtkTooltipLeaf <: GtkTooltip
            handle::Ptr{GObject}
            function GtkTooltipLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTooltipLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTooltip] = GtkTooltipLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTooltip) = begin
                ccall(("gtk_tooltip_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeExpander <: GtkWidget end
        mutable struct GtkTreeExpanderLeaf <: GtkTreeExpander
            handle::Ptr{GObject}
            function GtkTreeExpanderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeExpanderLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeExpander] = GtkTreeExpanderLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeExpander) = begin
                ccall(("gtk_tree_expander_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeListModel <: GObject end
        mutable struct GtkTreeListModelLeaf <: GtkTreeListModel
            handle::Ptr{GObject}
            function GtkTreeListModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeListModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeListModel] = GtkTreeListModelLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeListModel) = begin
                ccall(("gtk_tree_list_model_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeListRow <: GObject end
        mutable struct GtkTreeListRowLeaf <: GtkTreeListRow
            handle::Ptr{GObject}
            function GtkTreeListRowLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeListRowLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeListRow] = GtkTreeListRowLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeListRow) = begin
                ccall(("gtk_tree_list_row_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeListRowSorter <: GtkSorter end
        mutable struct GtkTreeListRowSorterLeaf <: GtkTreeListRowSorter
            handle::Ptr{GObject}
            function GtkTreeListRowSorterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeListRowSorterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeListRowSorter] = GtkTreeListRowSorterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeListRowSorter) = begin
                ccall(("gtk_tree_list_row_sorter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeModelFilter <: GObject end
        mutable struct GtkTreeModelFilterLeaf <: GtkTreeModelFilter
            handle::Ptr{GObject}
            function GtkTreeModelFilterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeModelFilterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeModelFilter] = GtkTreeModelFilterLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeModelFilter) = begin
                ccall(("gtk_tree_model_filter_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeModelSort <: GObject end
        mutable struct GtkTreeModelSortLeaf <: GtkTreeModelSort
            handle::Ptr{GObject}
            function GtkTreeModelSortLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeModelSortLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeModelSort] = GtkTreeModelSortLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeModelSort) = begin
                ccall(("gtk_tree_model_sort_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeSelection <: GObject end
        mutable struct GtkTreeSelectionLeaf <: GtkTreeSelection
            handle::Ptr{GObject}
            function GtkTreeSelectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeSelectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeSelection] = GtkTreeSelectionLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeSelection) = begin
                ccall(("gtk_tree_selection_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeStore <: GObject end
        mutable struct GtkTreeStoreLeaf <: GtkTreeStore
            handle::Ptr{GObject}
            function GtkTreeStoreLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeStoreLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeStore] = GtkTreeStoreLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeStore) = begin
                ccall(("gtk_tree_store_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeView <: GtkWidget end
        mutable struct GtkTreeViewLeaf <: GtkTreeView
            handle::Ptr{GObject}
            function GtkTreeViewLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeViewLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeView] = GtkTreeViewLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeView) = begin
                ccall(("gtk_tree_view_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkTreeViewColumn <: GInitiallyUnowned end
        mutable struct GtkTreeViewColumnLeaf <: GtkTreeViewColumn
            handle::Ptr{GObject}
            function GtkTreeViewColumnLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkTreeViewColumnLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkTreeViewColumn] = GtkTreeViewColumnLeaf
        (GLib.g_type(::Type{T}) where T <: GtkTreeViewColumn) = begin
                ccall(("gtk_tree_view_column_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkUriLauncher <: GObject end
        mutable struct GtkUriLauncherLeaf <: GtkUriLauncher
            handle::Ptr{GObject}
            function GtkUriLauncherLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkUriLauncherLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkUriLauncher] = GtkUriLauncherLeaf
        (GLib.g_type(::Type{T}) where T <: GtkUriLauncher) = begin
                ccall(("gtk_uri_launcher_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkVideo <: GtkWidget end
        mutable struct GtkVideoLeaf <: GtkVideo
            handle::Ptr{GObject}
            function GtkVideoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkVideoLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkVideo] = GtkVideoLeaf
        (GLib.g_type(::Type{T}) where T <: GtkVideo) = begin
                ccall(("gtk_video_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkViewport <: GtkWidget end
        mutable struct GtkViewportLeaf <: GtkViewport
            handle::Ptr{GObject}
            function GtkViewportLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkViewportLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkViewport] = GtkViewportLeaf
        (GLib.g_type(::Type{T}) where T <: GtkViewport) = begin
                ccall(("gtk_viewport_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkVolumeButton <: GtkScaleButton end
        mutable struct GtkVolumeButtonLeaf <: GtkVolumeButton
            handle::Ptr{GObject}
            function GtkVolumeButtonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkVolumeButtonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkVolumeButton] = GtkVolumeButtonLeaf
        (GLib.g_type(::Type{T}) where T <: GtkVolumeButton) = begin
                ccall(("gtk_volume_button_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkWidgetPaintable <: GObject end
        mutable struct GtkWidgetPaintableLeaf <: GtkWidgetPaintable
            handle::Ptr{GObject}
            function GtkWidgetPaintableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWidgetPaintableLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkWidgetPaintable] = GtkWidgetPaintableLeaf
        (GLib.g_type(::Type{T}) where T <: GtkWidgetPaintable) = begin
                ccall(("gtk_widget_paintable_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkWindowControls <: GtkWidget end
        mutable struct GtkWindowControlsLeaf <: GtkWindowControls
            handle::Ptr{GObject}
            function GtkWindowControlsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWindowControlsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkWindowControls] = GtkWindowControlsLeaf
        (GLib.g_type(::Type{T}) where T <: GtkWindowControls) = begin
                ccall(("gtk_window_controls_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkWindowGroup <: GObject end
        mutable struct GtkWindowGroupLeaf <: GtkWindowGroup
            handle::Ptr{GObject}
            function GtkWindowGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWindowGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkWindowGroup] = GtkWindowGroupLeaf
        (GLib.g_type(::Type{T}) where T <: GtkWindowGroup) = begin
                ccall(("gtk_window_group_get_type", libgtk4), GType, ())
            end
    end
    begin
        abstract type GtkWindowHandle <: GtkWidget end
        mutable struct GtkWindowHandleLeaf <: GtkWindowHandle
            handle::Ptr{GObject}
            function GtkWindowHandleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GtkWindowHandleLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GtkWindowHandle] = GtkWindowHandleLeaf
        (GLib.g_type(::Type{T}) where T <: GtkWindowHandle) = begin
                ccall(("gtk_window_handle_get_type", libgtk4), GType, ())
            end
    end
    function GtkATContext(_accessible_role, _accessible::GtkAccessible, _display::GdkDisplay; kwargs...)
        obj = G_.ATContext_create(_accessible_role, _accessible, _display)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkAboutDialog(; kwargs...)
        obj = G_.AboutDialog_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkActionBar(; kwargs...)
        obj = G_.ActionBar_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkAdjustment(_value::Real, _lower::Real, _upper::Real, _step_increment::Real, _page_increment::Real, _page_size::Real; kwargs...)
        obj = G_.Adjustment_new(_value, _lower, _upper, _step_increment, _page_increment, _page_size)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkAlternativeTrigger(_first::GtkShortcutTrigger, _second::GtkShortcutTrigger; kwargs...)
        obj = G_.AlternativeTrigger_new(_first, _second)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkAnyFilter()
        G_.AnyFilter_new()
    end
    function GtkAppChooserButton(_content_type::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.AppChooserButton_new(_content_type)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkAppChooserDialog(_parent::Maybe(GtkWindow), _flags, _file::GFile; kwargs...)
        obj = G_.AppChooserDialog_new(_parent, _flags, _file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkAppChooserDialog(_parent::Maybe(GtkWindow), _flags, _content_type::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.AppChooserDialog_new_for_content_type(_parent, _flags, _content_type)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkAppChooserWidget(_content_type::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.AppChooserWidget_new(_content_type)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkApplication(_application_id::Maybe(Union{AbstractString, Symbol}), _flags; kwargs...)
        obj = G_.Application_new(_application_id, _flags)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkApplicationWindow(_application::GtkApplication; kwargs...)
        obj = G_.ApplicationWindow_new(_application)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkAspectFrame(_xalign::Real, _yalign::Real, _ratio::Real, _obey_child::Bool; kwargs...)
        obj = G_.AspectFrame_new(_xalign, _yalign, _ratio, _obey_child)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkAssistant(; kwargs...)
        obj = G_.Assistant_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkBinLayout()
        G_.BinLayout_new()
    end
    function GtkBookmarkList(_filename::Maybe(Union{AbstractString, Symbol}), _attributes::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.BookmarkList_new(_filename, _attributes)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkBoolFilter(_expression::Maybe(GtkExpression); kwargs...)
        obj = G_.BoolFilter_new(_expression)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkBox(_orientation, _spacing::Integer; kwargs...)
        obj = G_.Box_new(_orientation, _spacing)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkBoxLayout(_orientation; kwargs...)
        obj = G_.BoxLayout_new(_orientation)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkBuilder(; kwargs...)
        obj = G_.Builder_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkBuilder(_filename::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Builder_new_from_file(_filename)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkBuilder(_string::Union{AbstractString, Symbol}, _length::Integer; kwargs...)
        obj = G_.Builder_new_from_string(_string, _length)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkBuilderCScope()
        G_.BuilderCScope_new()
    end
    function GtkBuilderListItemFactory(_scope::Maybe(GtkBuilderScope), _bytes::GBytes; kwargs...)
        obj = G_.BuilderListItemFactory_new_from_bytes(_scope, _bytes)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkButton(; kwargs...)
        obj = G_.Button_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkButton(_label::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Button_new_with_label(_label)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCalendar(; kwargs...)
        obj = G_.Calendar_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCallbackAction(_callback::Maybe(Function), _data::Maybe(Nothing), _destroy::Function)
        G_.CallbackAction_new(_callback, _data, _destroy)
    end
    function GtkCellAreaBox(; kwargs...)
        obj = G_.CellAreaBox_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellRendererAccel(; kwargs...)
        obj = G_.CellRendererAccel_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellRendererCombo(; kwargs...)
        obj = G_.CellRendererCombo_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellRendererPixbuf(; kwargs...)
        obj = G_.CellRendererPixbuf_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellRendererProgress(; kwargs...)
        obj = G_.CellRendererProgress_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellRendererSpin(; kwargs...)
        obj = G_.CellRendererSpin_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellRendererSpinner(; kwargs...)
        obj = G_.CellRendererSpinner_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellRendererText(; kwargs...)
        obj = G_.CellRendererText_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellRendererToggle(; kwargs...)
        obj = G_.CellRendererToggle_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellView(; kwargs...)
        obj = G_.CellView_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellView(_area::GtkCellArea, _context::GtkCellAreaContext; kwargs...)
        obj = G_.CellView_new_with_context(_area, _context)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellView(_markup::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.CellView_new_with_markup(_markup)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCellView(_texture::GdkTexture; kwargs...)
        obj = G_.CellView_new_with_texture(_texture)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCenterBox(; kwargs...)
        obj = G_.CenterBox_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCenterLayout()
        G_.CenterLayout_new()
    end
    function GtkCheckButton(; kwargs...)
        obj = G_.CheckButton_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkCheckButton(_label::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.CheckButton_new_with_label(_label)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkColorButton(; kwargs...)
        obj = G_.ColorButton_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkColorButton(_rgba::Union{GdkRGBA, Ref{_GdkRGBA}}; kwargs...)
        obj = G_.ColorButton_new_with_rgba(_rgba)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkColorChooserDialog(_title::Maybe(Union{AbstractString, Symbol}), _parent::Maybe(GtkWindow); kwargs...)
        obj = G_.ColorChooserDialog_new(_title, _parent)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkColorChooserWidget(; kwargs...)
        obj = G_.ColorChooserWidget_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkColorDialog(; kwargs...)
        obj = G_.ColorDialog_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkColorDialogButton(_dialog::Maybe(GtkColorDialog); kwargs...)
        obj = G_.ColorDialogButton_new(_dialog)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkColumnView(_model::Maybe(GtkSelectionModel); kwargs...)
        obj = G_.ColumnView_new(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkColumnViewColumn(_title::Maybe(Union{AbstractString, Symbol}), _factory::Maybe(GtkListItemFactory); kwargs...)
        obj = G_.ColumnViewColumn_new(_title, _factory)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkComboBox(; kwargs...)
        obj = G_.ComboBox_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkComboBox(_model::GtkTreeModel; kwargs...)
        obj = G_.ComboBox_new_with_model(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkComboBoxText()
        G_.ComboBoxText_new()
    end
    function GtkConstantExpression(_value::Union{GValue, Ref{_GValue}})
        G_.ConstantExpression_new_for_value(_value)
    end
    function GtkConstraint(_target::Maybe(GtkConstraintTarget), _target_attribute, _relation, _source::Maybe(GtkConstraintTarget), _source_attribute, _multiplier::Real, _constant::Real, _strength::Integer; kwargs...)
        obj = G_.Constraint_new(_target, _target_attribute, _relation, _source, _source_attribute, _multiplier, _constant, _strength)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkConstraint(_target::Maybe(GtkConstraintTarget), _target_attribute, _relation, _constant::Real, _strength::Integer; kwargs...)
        obj = G_.Constraint_new_constant(_target, _target_attribute, _relation, _constant, _strength)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkConstraintGuide(; kwargs...)
        obj = G_.ConstraintGuide_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkConstraintLayout()
        G_.ConstraintLayout_new()
    end
    function GtkCssProvider()
        G_.CssProvider_new()
    end
    function GtkCustomFilter(_match_func::Maybe(Function), _user_data::Maybe(Nothing), _user_destroy::Function)
        G_.CustomFilter_new(_match_func, _user_data, _user_destroy)
    end
    function GtkCustomLayout(_request_mode::Maybe(Function), _measure::Function, _allocate::Function)
        G_.CustomLayout_new(_request_mode, _measure, _allocate)
    end
    function GtkCustomSorter(_sort_func::Maybe(Function), _user_data::Maybe(Nothing), _user_destroy::Maybe(Function))
        G_.CustomSorter_new(_sort_func, _user_data, _user_destroy)
    end
    function GtkDialog(; kwargs...)
        obj = G_.Dialog_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkDirectoryList(_attributes::Maybe(Union{AbstractString, Symbol}), _file::Maybe(GFile); kwargs...)
        obj = G_.DirectoryList_new(_attributes, _file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkDragSource(; kwargs...)
        obj = G_.DragSource_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkDrawingArea(; kwargs...)
        obj = G_.DrawingArea_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkDropControllerMotion(; kwargs...)
        obj = G_.DropControllerMotion_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkDropDown(_model::Maybe(GListModel), _expression::Maybe(GtkExpression); kwargs...)
        obj = G_.DropDown_new(_model, _expression)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkDropDown(_strings; kwargs...)
        obj = G_.DropDown_new_from_strings(_strings)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkDropTarget(_type::Integer, _actions; kwargs...)
        obj = G_.DropTarget_new(_type, _actions)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkDropTargetAsync(_formats::Maybe(GdkContentFormats), _actions; kwargs...)
        obj = G_.DropTargetAsync_new(_formats, _actions)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEditableLabel(_str::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.EditableLabel_new(_str)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEmojiChooser()
        G_.EmojiChooser_new()
    end
    function GtkEntry(; kwargs...)
        obj = G_.Entry_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEntry(_buffer::GtkEntryBuffer; kwargs...)
        obj = G_.Entry_new_with_buffer(_buffer)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEntryBuffer(_initial_chars::Maybe(Union{AbstractString, Symbol}), _n_initial_chars::Integer; kwargs...)
        obj = G_.EntryBuffer_new(_initial_chars, _n_initial_chars)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEntryCompletion(; kwargs...)
        obj = G_.EntryCompletion_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEntryCompletion(_area::GtkCellArea; kwargs...)
        obj = G_.EntryCompletion_new_with_area(_area)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEventControllerFocus(; kwargs...)
        obj = G_.EventControllerFocus_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEventControllerKey()
        G_.EventControllerKey_new()
    end
    function GtkEventControllerLegacy()
        G_.EventControllerLegacy_new()
    end
    function GtkEventControllerMotion(; kwargs...)
        obj = G_.EventControllerMotion_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEventControllerScroll(_flags; kwargs...)
        obj = G_.EventControllerScroll_new(_flags)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkEveryFilter()
        G_.EveryFilter_new()
    end
    function GtkExpander(_label::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.Expander_new(_label)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFileChooserNative(_title::Maybe(Union{AbstractString, Symbol}), _parent::Maybe(GtkWindow), _action, _accept_label::Maybe(Union{AbstractString, Symbol}), _cancel_label::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.FileChooserNative_new(_title, _parent, _action, _accept_label, _cancel_label)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFileChooserWidget(_action; kwargs...)
        obj = G_.FileChooserWidget_new(_action)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFileDialog(; kwargs...)
        obj = G_.FileDialog_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFileFilter(; kwargs...)
        obj = G_.FileFilter_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFileFilter(_variant::GVariant; kwargs...)
        obj = G_.FileFilter_new_from_gvariant(_variant)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFileLauncher(_file::Maybe(GFile); kwargs...)
        obj = G_.FileLauncher_new(_file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFilterListModel(_model::Maybe(GListModel), _filter::Maybe(GtkFilter); kwargs...)
        obj = G_.FilterListModel_new(_model, _filter)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFixed()
        G_.Fixed_new()
    end
    function GtkFixedLayout()
        G_.FixedLayout_new()
    end
    function GtkFlattenListModel(_model::Maybe(GListModel); kwargs...)
        obj = G_.FlattenListModel_new(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFlowBox(; kwargs...)
        obj = G_.FlowBox_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFlowBoxChild(; kwargs...)
        obj = G_.FlowBoxChild_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFontButton(; kwargs...)
        obj = G_.FontButton_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFontButton(_fontname::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.FontButton_new_with_font(_fontname)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFontChooserDialog(_title::Maybe(Union{AbstractString, Symbol}), _parent::Maybe(GtkWindow))
        G_.FontChooserDialog_new(_title, _parent)
    end
    function GtkFontChooserWidget(; kwargs...)
        obj = G_.FontChooserWidget_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFontDialog(; kwargs...)
        obj = G_.FontDialog_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFontDialogButton(_dialog::Maybe(GtkFontDialog); kwargs...)
        obj = G_.FontDialogButton_new(_dialog)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkFrame(_label::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.Frame_new(_label)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkGLArea(; kwargs...)
        obj = G_.GLArea_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkGestureClick()
        G_.GestureClick_new()
    end
    function GtkGestureDrag()
        G_.GestureDrag_new()
    end
    function GtkGestureLongPress(; kwargs...)
        obj = G_.GestureLongPress_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkGesturePan(_orientation; kwargs...)
        obj = G_.GesturePan_new(_orientation)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkGestureRotate()
        G_.GestureRotate_new()
    end
    function GtkGestureStylus(; kwargs...)
        obj = G_.GestureStylus_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkGestureSwipe()
        G_.GestureSwipe_new()
    end
    function GtkGestureZoom()
        G_.GestureZoom_new()
    end
    function GtkGrid(; kwargs...)
        obj = G_.Grid_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkGridLayout(; kwargs...)
        obj = G_.GridLayout_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkGridView(_model::Maybe(GtkSelectionModel), _factory::Maybe(GtkListItemFactory); kwargs...)
        obj = G_.GridView_new(_model, _factory)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkHeaderBar(; kwargs...)
        obj = G_.HeaderBar_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkIMContextSimple()
        G_.IMContextSimple_new()
    end
    function GtkIMMulticontext()
        G_.IMMulticontext_new()
    end
    function GtkIconPaintable(_file::GFile, _size::Integer, _scale::Integer; kwargs...)
        obj = G_.IconPaintable_new_for_file(_file, _size, _scale)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkIconTheme(; kwargs...)
        obj = G_.IconTheme_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkIconView(; kwargs...)
        obj = G_.IconView_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkIconView(_area::GtkCellArea; kwargs...)
        obj = G_.IconView_new_with_area(_area)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkIconView(_model::GtkTreeModel; kwargs...)
        obj = G_.IconView_new_with_model(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkImage(; kwargs...)
        obj = G_.Image_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkImage(_filename::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Image_new_from_file(_filename)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkImage(_icon::GIcon; kwargs...)
        obj = G_.Image_new_from_gicon(_icon)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkImage(_paintable::Maybe(GdkPaintable); kwargs...)
        obj = G_.Image_new_from_paintable(_paintable)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkImage(_pixbuf::Maybe(GdkPixbuf); kwargs...)
        obj = G_.Image_new_from_pixbuf(_pixbuf)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkInfoBar(; kwargs...)
        obj = G_.InfoBar_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkInscription(_text::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.Inscription_new(_text)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkKeyvalTrigger(_keyval::Integer, _modifiers; kwargs...)
        obj = G_.KeyvalTrigger_new(_keyval, _modifiers)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkLabel(_str::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.Label_new(_str)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkLevelBar(; kwargs...)
        obj = G_.LevelBar_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkLevelBar(_min_value::Real, _max_value::Real; kwargs...)
        obj = G_.LevelBar_new_for_interval(_min_value, _max_value)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkLinkButton(_uri::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.LinkButton_new(_uri)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkLinkButton(_uri::Union{AbstractString, Symbol}, _label::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.LinkButton_new_with_label(_uri, _label)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkListBox(; kwargs...)
        obj = G_.ListBox_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkListBoxRow(; kwargs...)
        obj = G_.ListBoxRow_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkListStore(_types)
        G_.ListStore_new(_types)
    end
    function GtkListView(_model::Maybe(GtkSelectionModel), _factory::Maybe(GtkListItemFactory); kwargs...)
        obj = G_.ListView_new(_model, _factory)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkLockButton(_permission::Maybe(GPermission); kwargs...)
        obj = G_.LockButton_new(_permission)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMapListModel(_model::Maybe(GListModel), _map_func::Maybe(Function), _user_data::Maybe(Nothing), _user_destroy::Function; kwargs...)
        obj = G_.MapListModel_new(_model, _map_func, _user_data, _user_destroy)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMediaControls(_stream::Maybe(GtkMediaStream); kwargs...)
        obj = G_.MediaControls_new(_stream)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMediaFile(; kwargs...)
        obj = G_.MediaFile_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMediaFile(_file::GFile; kwargs...)
        obj = G_.MediaFile_new_for_file(_file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMediaFile(_filename::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.MediaFile_new_for_filename(_filename)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMediaFile(_stream::GInputStream; kwargs...)
        obj = G_.MediaFile_new_for_input_stream(_stream)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMenuButton(; kwargs...)
        obj = G_.MenuButton_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMnemonicTrigger(_keyval::Integer; kwargs...)
        obj = G_.MnemonicTrigger_new(_keyval)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMountOperation(_parent::Maybe(GtkWindow); kwargs...)
        obj = G_.MountOperation_new(_parent)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMultiSelection(_model::Maybe(GListModel); kwargs...)
        obj = G_.MultiSelection_new(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkMultiSorter(; kwargs...)
        obj = G_.MultiSorter_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkNamedAction(_name::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.NamedAction_new(_name)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkNoSelection(_model::Maybe(GListModel); kwargs...)
        obj = G_.NoSelection_new(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkNotebook(; kwargs...)
        obj = G_.Notebook_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkNumericSorter(_expression::Maybe(GtkExpression); kwargs...)
        obj = G_.NumericSorter_new(_expression)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkObjectExpression(_object::GObject)
        G_.ObjectExpression_new(_object)
    end
    function GtkOverlay(; kwargs...)
        obj = G_.Overlay_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkOverlayLayout()
        G_.OverlayLayout_new()
    end
    function GtkPadController(_group::GActionGroup, _pad::Maybe(GdkDevice); kwargs...)
        obj = G_.PadController_new(_group, _pad)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPageSetup()
        G_.PageSetup_new()
    end
    function GtkPageSetup(_file_name::Union{AbstractString, Symbol})
        G_.PageSetup_new_from_file(_file_name)
    end
    function GtkPageSetup(_variant::GVariant)
        G_.PageSetup_new_from_gvariant(_variant)
    end
    function GtkPageSetup(_key_file::GKeyFile, _group_name::Maybe(Union{AbstractString, Symbol}))
        G_.PageSetup_new_from_key_file(_key_file, _group_name)
    end
    function GtkPaned(_orientation; kwargs...)
        obj = G_.Paned_new(_orientation)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPasswordEntry(; kwargs...)
        obj = G_.PasswordEntry_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPasswordEntryBuffer()
        G_.PasswordEntryBuffer_new()
    end
    function GtkPicture(; kwargs...)
        obj = G_.Picture_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPicture(_file::Maybe(GFile); kwargs...)
        obj = G_.Picture_new_for_file(_file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPicture(_filename::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.Picture_new_for_filename(_filename)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPicture(_paintable::Maybe(GdkPaintable); kwargs...)
        obj = G_.Picture_new_for_paintable(_paintable)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPicture(_pixbuf::Maybe(GdkPixbuf); kwargs...)
        obj = G_.Picture_new_for_pixbuf(_pixbuf)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPopover(; kwargs...)
        obj = G_.Popover_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPopoverMenu(_model::Maybe(GMenuModel); kwargs...)
        obj = G_.PopoverMenu_new_from_model(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPopoverMenu(_model::GMenuModel, _flags; kwargs...)
        obj = G_.PopoverMenu_new_from_model_full(_model, _flags)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPopoverMenuBar(_model::Maybe(GMenuModel); kwargs...)
        obj = G_.PopoverMenuBar_new_from_model(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPrintJob(_title::Union{AbstractString, Symbol}, _printer::GtkPrinter, _settings::GtkPrintSettings, _page_setup::GtkPageSetup; kwargs...)
        obj = G_.PrintJob_new(_title, _printer, _settings, _page_setup)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPrintOperation(; kwargs...)
        obj = G_.PrintOperation_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPrintSettings()
        G_.PrintSettings_new()
    end
    function GtkPrintSettings(_file_name::Union{AbstractString, Symbol})
        G_.PrintSettings_new_from_file(_file_name)
    end
    function GtkPrintSettings(_variant::GVariant)
        G_.PrintSettings_new_from_gvariant(_variant)
    end
    function GtkPrintSettings(_key_file::GKeyFile, _group_name::Maybe(Union{AbstractString, Symbol}))
        G_.PrintSettings_new_from_key_file(_key_file, _group_name)
    end
    function GtkPrinter(_name::Union{AbstractString, Symbol}, _backend::GtkPrintBackend, _virtual_::Bool; kwargs...)
        obj = G_.Printer_new(_name, _backend, _virtual_)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkProgressBar(; kwargs...)
        obj = G_.ProgressBar_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkPropertyExpression(_this_type::Integer, _expression::Maybe(GtkExpression), _property_name::Union{AbstractString, Symbol})
        G_.PropertyExpression_new(_this_type, _expression, _property_name)
    end
    function GtkPropertyExpression(_expression::Maybe(GtkExpression), _pspec::GParam)
        G_.PropertyExpression_new_for_pspec(_expression, _pspec)
    end
    function GtkRecentManager(; kwargs...)
        obj = G_.RecentManager_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkRevealer(; kwargs...)
        obj = G_.Revealer_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkScale(_orientation, _adjustment::Maybe(GtkAdjustment); kwargs...)
        obj = G_.Scale_new(_orientation, _adjustment)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkScale(_orientation, _min::Real, _max::Real, _step::Real; kwargs...)
        obj = G_.Scale_new_with_range(_orientation, _min, _max, _step)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkScaleButton(_min::Real, _max::Real, _step::Real, _icons; kwargs...)
        obj = G_.ScaleButton_new(_min, _max, _step, _icons)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkScrollbar(_orientation, _adjustment::Maybe(GtkAdjustment); kwargs...)
        obj = G_.Scrollbar_new(_orientation, _adjustment)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkScrolledWindow(; kwargs...)
        obj = G_.ScrolledWindow_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSearchBar(; kwargs...)
        obj = G_.SearchBar_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSearchEntry(; kwargs...)
        obj = G_.SearchEntry_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSelectionFilterModel(_model::Maybe(GtkSelectionModel); kwargs...)
        obj = G_.SelectionFilterModel_new(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSeparator(_orientation)
        G_.Separator_new(_orientation)
    end
    function GtkShortcut(_trigger::Maybe(GtkShortcutTrigger), _action::Maybe(GtkShortcutAction); kwargs...)
        obj = G_.Shortcut_new(_trigger, _action)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkShortcutAction(_string::Union{AbstractString, Symbol})
        G_.ShortcutAction_parse_string(_string)
    end
    function GtkShortcutController(; kwargs...)
        obj = G_.ShortcutController_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkShortcutController(_model::GListModel; kwargs...)
        obj = G_.ShortcutController_new_for_model(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkShortcutLabel(_accelerator::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.ShortcutLabel_new(_accelerator)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkShortcutTrigger(_string::Union{AbstractString, Symbol})
        G_.ShortcutTrigger_parse_string(_string)
    end
    function GtkSignalAction(_signal_name::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.SignalAction_new(_signal_name)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSignalListItemFactory()
        G_.SignalListItemFactory_new()
    end
    function GtkSingleSelection(_model::Maybe(GListModel); kwargs...)
        obj = G_.SingleSelection_new(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSizeGroup(_mode; kwargs...)
        obj = G_.SizeGroup_new(_mode)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSliceListModel(_model::Maybe(GListModel), _offset::Integer, _size::Integer; kwargs...)
        obj = G_.SliceListModel_new(_model, _offset, _size)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSnapshot()
        G_.Snapshot_new()
    end
    function GtkSortListModel(_model::Maybe(GListModel), _sorter::Maybe(GtkSorter); kwargs...)
        obj = G_.SortListModel_new(_model, _sorter)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSpinButton(_adjustment::Maybe(GtkAdjustment), _climb_rate::Real, _digits::Integer; kwargs...)
        obj = G_.SpinButton_new(_adjustment, _climb_rate, _digits)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSpinButton(_min::Real, _max::Real, _step::Real; kwargs...)
        obj = G_.SpinButton_new_with_range(_min, _max, _step)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSpinner(; kwargs...)
        obj = G_.Spinner_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkStack(; kwargs...)
        obj = G_.Stack_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkStackSidebar(; kwargs...)
        obj = G_.StackSidebar_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkStackSwitcher(; kwargs...)
        obj = G_.StackSwitcher_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkStatusbar()
        G_.Statusbar_new()
    end
    function GtkStringFilter(_expression::Maybe(GtkExpression); kwargs...)
        obj = G_.StringFilter_new(_expression)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkStringList(_strings; kwargs...)
        obj = G_.StringList_new(_strings)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkStringObject(_string::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.StringObject_new(_string)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkStringSorter(_expression::Maybe(GtkExpression); kwargs...)
        obj = G_.StringSorter_new(_expression)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkSwitch(; kwargs...)
        obj = G_.Switch_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkText(; kwargs...)
        obj = G_.Text_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkText(_buffer::GtkEntryBuffer; kwargs...)
        obj = G_.Text_new_with_buffer(_buffer)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTextBuffer(_table::Maybe(GtkTextTagTable); kwargs...)
        obj = G_.TextBuffer_new(_table)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTextChildAnchor()
        G_.TextChildAnchor_new()
    end
    function GtkTextChildAnchor(_character::Union{AbstractString, Symbol})
        G_.TextChildAnchor_new_with_replacement(_character)
    end
    function GtkTextMark(_name::Maybe(Union{AbstractString, Symbol}), _left_gravity::Bool; kwargs...)
        obj = G_.TextMark_new(_name, _left_gravity)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTextTag(_name::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.TextTag_new(_name)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTextTagTable()
        G_.TextTagTable_new()
    end
    function GtkTextView(; kwargs...)
        obj = G_.TextView_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTextView(_buffer::GtkTextBuffer; kwargs...)
        obj = G_.TextView_new_with_buffer(_buffer)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkToggleButton(; kwargs...)
        obj = G_.ToggleButton_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkToggleButton(_label::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.ToggleButton_new_with_label(_label)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTreeExpander(; kwargs...)
        obj = G_.TreeExpander_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTreeListModel(_root::GListModel, _passthrough::Bool, _autoexpand::Bool, _create_func::Function, _user_data::Maybe(Nothing), _user_destroy::Function; kwargs...)
        obj = G_.TreeListModel_new(_root, _passthrough, _autoexpand, _create_func, _user_data, _user_destroy)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTreeListRowSorter(_sorter::Maybe(GtkSorter); kwargs...)
        obj = G_.TreeListRowSorter_new(_sorter)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTreeModelSort(_child_model::GtkTreeModel; kwargs...)
        obj = G_.TreeModelSort_new_with_model(_child_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTreeStore(_types)
        G_.TreeStore_new(_types)
    end
    function GtkTreeView(; kwargs...)
        obj = G_.TreeView_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTreeView(_model::GtkTreeModel; kwargs...)
        obj = G_.TreeView_new_with_model(_model)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTreeViewColumn(; kwargs...)
        obj = G_.TreeViewColumn_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkTreeViewColumn(_area::GtkCellArea; kwargs...)
        obj = G_.TreeViewColumn_new_with_area(_area)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkUriLauncher(_uri::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.UriLauncher_new(_uri)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkVideo(; kwargs...)
        obj = G_.Video_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkVideo(_file::Maybe(GFile); kwargs...)
        obj = G_.Video_new_for_file(_file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkVideo(_filename::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.Video_new_for_filename(_filename)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkVideo(_stream::Maybe(GtkMediaStream); kwargs...)
        obj = G_.Video_new_for_media_stream(_stream)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkViewport(_hadjustment::Maybe(GtkAdjustment), _vadjustment::Maybe(GtkAdjustment); kwargs...)
        obj = G_.Viewport_new(_hadjustment, _vadjustment)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkVolumeButton(; kwargs...)
        obj = G_.VolumeButton_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkWidgetPaintable(_widget::Maybe(GtkWidget); kwargs...)
        obj = G_.WidgetPaintable_new(_widget)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkWindow(; kwargs...)
        obj = G_.Window_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkWindowControls(_side; kwargs...)
        obj = G_.WindowControls_new(_side)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GtkWindowGroup()
        G_.WindowGroup_new()
    end
    function GtkWindowHandle(; kwargs...)
        obj = G_.WindowHandle_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ATContext.html)." GtkATContext
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.AboutDialog.html)." GtkAboutDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ActionBar.html)." GtkActionBar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ActivateAction.html)." GtkActivateAction
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Adjustment.html)." GtkAdjustment
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.AlertDialog.html)." GtkAlertDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.AlternativeTrigger.html)." GtkAlternativeTrigger
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.AnyFilter.html)." GtkAnyFilter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.AppChooserButton.html)." GtkAppChooserButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.AppChooserDialog.html)." GtkAppChooserDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.AppChooserWidget.html)." GtkAppChooserWidget
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Application.html)." GtkApplication
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ApplicationWindow.html)." GtkApplicationWindow
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.AspectFrame.html)." GtkAspectFrame
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Assistant.html)." GtkAssistant
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.AssistantPage.html)." GtkAssistantPage
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.BinLayout.html)." GtkBinLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.BookmarkList.html)." GtkBookmarkList
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.BoolFilter.html)." GtkBoolFilter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Box.html)." GtkBox
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.BoxLayout.html)." GtkBoxLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Builder.html)." GtkBuilder
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.BuilderCScope.html)." GtkBuilderCScope
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.BuilderListItemFactory.html)." GtkBuilderListItemFactory
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Button.html)." GtkButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Calendar.html)." GtkCalendar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CallbackAction.html)." GtkCallbackAction
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellArea.html)." GtkCellArea
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellAreaBox.html)." GtkCellAreaBox
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellAreaContext.html)." GtkCellAreaContext
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellRenderer.html)." GtkCellRenderer
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellRendererAccel.html)." GtkCellRendererAccel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellRendererCombo.html)." GtkCellRendererCombo
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellRendererPixbuf.html)." GtkCellRendererPixbuf
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellRendererProgress.html)." GtkCellRendererProgress
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellRendererSpin.html)." GtkCellRendererSpin
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellRendererSpinner.html)." GtkCellRendererSpinner
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellRendererText.html)." GtkCellRendererText
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellRendererToggle.html)." GtkCellRendererToggle
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CellView.html)." GtkCellView
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CenterBox.html)." GtkCenterBox
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CenterLayout.html)." GtkCenterLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CheckButton.html)." GtkCheckButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ColorButton.html)." GtkColorButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ColorChooserDialog.html)." GtkColorChooserDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ColorChooserWidget.html)." GtkColorChooserWidget
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ColorDialog.html)." GtkColorDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ColorDialogButton.html)." GtkColorDialogButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ColumnView.html)." GtkColumnView
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ColumnViewColumn.html)." GtkColumnViewColumn
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ColumnViewSorter.html)." GtkColumnViewSorter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ComboBox.html)." GtkComboBox
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ComboBoxText.html)." GtkComboBoxText
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ConstantExpression.html)." GtkConstantExpression
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Constraint.html)." GtkConstraint
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ConstraintGuide.html)." GtkConstraintGuide
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ConstraintLayout.html)." GtkConstraintLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ConstraintLayoutChild.html)." GtkConstraintLayoutChild
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CssProvider.html)." GtkCssProvider
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CustomFilter.html)." GtkCustomFilter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CustomLayout.html)." GtkCustomLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.CustomSorter.html)." GtkCustomSorter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Dialog.html)." GtkDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.DirectoryList.html)." GtkDirectoryList
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.DragIcon.html)." GtkDragIcon
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.DragSource.html)." GtkDragSource
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.DrawingArea.html)." GtkDrawingArea
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.DropControllerMotion.html)." GtkDropControllerMotion
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.DropDown.html)." GtkDropDown
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.DropTarget.html)." GtkDropTarget
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.DropTargetAsync.html)." GtkDropTargetAsync
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EditableLabel.html)." GtkEditableLabel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EmojiChooser.html)." GtkEmojiChooser
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Entry.html)." GtkEntry
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EntryBuffer.html)." GtkEntryBuffer
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EntryCompletion.html)." GtkEntryCompletion
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EventController.html)." GtkEventController
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EventControllerFocus.html)." GtkEventControllerFocus
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EventControllerKey.html)." GtkEventControllerKey
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EventControllerLegacy.html)." GtkEventControllerLegacy
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EventControllerMotion.html)." GtkEventControllerMotion
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EventControllerScroll.html)." GtkEventControllerScroll
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.EveryFilter.html)." GtkEveryFilter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Expander.html)." GtkExpander
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Expression.html)." GtkExpression
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FileChooserDialog.html)." GtkFileChooserDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FileChooserNative.html)." GtkFileChooserNative
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FileChooserWidget.html)." GtkFileChooserWidget
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FileDialog.html)." GtkFileDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FileFilter.html)." GtkFileFilter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FileLauncher.html)." GtkFileLauncher
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Filter.html)." GtkFilter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FilterListModel.html)." GtkFilterListModel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Fixed.html)." GtkFixed
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FixedLayout.html)." GtkFixedLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FixedLayoutChild.html)." GtkFixedLayoutChild
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FlattenListModel.html)." GtkFlattenListModel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FlowBox.html)." GtkFlowBox
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FlowBoxChild.html)." GtkFlowBoxChild
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FontButton.html)." GtkFontButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FontChooserDialog.html)." GtkFontChooserDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FontChooserWidget.html)." GtkFontChooserWidget
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FontDialog.html)." GtkFontDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.FontDialogButton.html)." GtkFontDialogButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Frame.html)." GtkFrame
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GLArea.html)." GtkGLArea
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Gesture.html)." GtkGesture
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GestureClick.html)." GtkGestureClick
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GestureDrag.html)." GtkGestureDrag
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GestureLongPress.html)." GtkGestureLongPress
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GesturePan.html)." GtkGesturePan
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GestureRotate.html)." GtkGestureRotate
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GestureSingle.html)." GtkGestureSingle
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GestureStylus.html)." GtkGestureStylus
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GestureSwipe.html)." GtkGestureSwipe
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GestureZoom.html)." GtkGestureZoom
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Grid.html)." GtkGrid
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GridLayout.html)." GtkGridLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GridLayoutChild.html)." GtkGridLayoutChild
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.GridView.html)." GtkGridView
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.HeaderBar.html)." GtkHeaderBar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.IMContext.html)." GtkIMContext
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.IMContextSimple.html)." GtkIMContextSimple
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.IMMulticontext.html)." GtkIMMulticontext
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.IconPaintable.html)." GtkIconPaintable
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.IconTheme.html)." GtkIconTheme
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.IconView.html)." GtkIconView
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Image.html)." GtkImage
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.InfoBar.html)." GtkInfoBar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Inscription.html)." GtkInscription
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.KeyvalTrigger.html)." GtkKeyvalTrigger
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Label.html)." GtkLabel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.LayoutChild.html)." GtkLayoutChild
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.LayoutManager.html)." GtkLayoutManager
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.LevelBar.html)." GtkLevelBar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.LinkButton.html)." GtkLinkButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ListBase.html)." GtkListBase
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ListBox.html)." GtkListBox
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ListBoxRow.html)." GtkListBoxRow
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ListItem.html)." GtkListItem
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ListItemFactory.html)." GtkListItemFactory
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ListStore.html)." GtkListStore
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ListView.html)." GtkListView
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.LockButton.html)." GtkLockButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MapListModel.html)." GtkMapListModel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MediaControls.html)." GtkMediaControls
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MediaFile.html)." GtkMediaFile
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MediaStream.html)." GtkMediaStream
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MenuButton.html)." GtkMenuButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MessageDialog.html)." GtkMessageDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MnemonicAction.html)." GtkMnemonicAction
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MnemonicTrigger.html)." GtkMnemonicTrigger
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MountOperation.html)." GtkMountOperation
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MultiFilter.html)." GtkMultiFilter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MultiSelection.html)." GtkMultiSelection
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.MultiSorter.html)." GtkMultiSorter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.NamedAction.html)." GtkNamedAction
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.NativeDialog.html)." GtkNativeDialog
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.NeverTrigger.html)." GtkNeverTrigger
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.NoSelection.html)." GtkNoSelection
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Notebook.html)." GtkNotebook
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.NotebookPage.html)." GtkNotebookPage
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.NothingAction.html)." GtkNothingAction
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.NumericSorter.html)." GtkNumericSorter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ObjectExpression.html)." GtkObjectExpression
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Overlay.html)." GtkOverlay
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.OverlayLayout.html)." GtkOverlayLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.OverlayLayoutChild.html)." GtkOverlayLayoutChild
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PadController.html)." GtkPadController
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PageSetup.html)." GtkPageSetup
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Paned.html)." GtkPaned
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PasswordEntry.html)." GtkPasswordEntry
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PasswordEntryBuffer.html)." GtkPasswordEntryBuffer
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Picture.html)." GtkPicture
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Popover.html)." GtkPopover
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PopoverMenu.html)." GtkPopoverMenu
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PopoverMenuBar.html)." GtkPopoverMenuBar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PrintContext.html)." GtkPrintContext
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PrintJob.html)." GtkPrintJob
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PrintOperation.html)." GtkPrintOperation
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PrintSettings.html)." GtkPrintSettings
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Printer.html)." GtkPrinter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ProgressBar.html)." GtkProgressBar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.PropertyExpression.html)." GtkPropertyExpression
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Range.html)." GtkRange
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.RecentManager.html)." GtkRecentManager
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Revealer.html)." GtkRevealer
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Scale.html)." GtkScale
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ScaleButton.html)." GtkScaleButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Scrollbar.html)." GtkScrollbar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ScrolledWindow.html)." GtkScrolledWindow
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SearchBar.html)." GtkSearchBar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SearchEntry.html)." GtkSearchEntry
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SelectionFilterModel.html)." GtkSelectionFilterModel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Separator.html)." GtkSeparator
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Settings.html)." GtkSettings
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Shortcut.html)." GtkShortcut
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ShortcutAction.html)." GtkShortcutAction
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ShortcutController.html)." GtkShortcutController
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ShortcutLabel.html)." GtkShortcutLabel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ShortcutTrigger.html)." GtkShortcutTrigger
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ShortcutsGroup.html)." GtkShortcutsGroup
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ShortcutsSection.html)." GtkShortcutsSection
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ShortcutsShortcut.html)." GtkShortcutsShortcut
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ShortcutsWindow.html)." GtkShortcutsWindow
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SignalAction.html)." GtkSignalAction
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SignalListItemFactory.html)." GtkSignalListItemFactory
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SingleSelection.html)." GtkSingleSelection
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SizeGroup.html)." GtkSizeGroup
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SliceListModel.html)." GtkSliceListModel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Snapshot.html)." GtkSnapshot
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SortListModel.html)." GtkSortListModel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Sorter.html)." GtkSorter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.SpinButton.html)." GtkSpinButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Spinner.html)." GtkSpinner
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Stack.html)." GtkStack
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.StackPage.html)." GtkStackPage
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.StackSidebar.html)." GtkStackSidebar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.StackSwitcher.html)." GtkStackSwitcher
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Statusbar.html)." GtkStatusbar
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.StringFilter.html)." GtkStringFilter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.StringList.html)." GtkStringList
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.StringObject.html)." GtkStringObject
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.StringSorter.html)." GtkStringSorter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.StyleContext.html)." GtkStyleContext
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Switch.html)." GtkSwitch
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Text.html)." GtkText
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TextBuffer.html)." GtkTextBuffer
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TextChildAnchor.html)." GtkTextChildAnchor
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TextMark.html)." GtkTextMark
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TextTag.html)." GtkTextTag
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TextTagTable.html)." GtkTextTagTable
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TextView.html)." GtkTextView
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.ToggleButton.html)." GtkToggleButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Tooltip.html)." GtkTooltip
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeExpander.html)." GtkTreeExpander
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeListModel.html)." GtkTreeListModel
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeListRow.html)." GtkTreeListRow
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeListRowSorter.html)." GtkTreeListRowSorter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeModelFilter.html)." GtkTreeModelFilter
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeModelSort.html)." GtkTreeModelSort
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeSelection.html)." GtkTreeSelection
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeStore.html)." GtkTreeStore
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeView.html)." GtkTreeView
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.TreeViewColumn.html)." GtkTreeViewColumn
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.UriLauncher.html)." GtkUriLauncher
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Video.html)." GtkVideo
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Viewport.html)." GtkViewport
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.VolumeButton.html)." GtkVolumeButton
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Widget.html)." GtkWidget
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.WidgetPaintable.html)." GtkWidgetPaintable
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.Window.html)." GtkWindow
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.WindowControls.html)." GtkWindowControls
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.WindowGroup.html)." GtkWindowGroup
    @doc "See the [GTK docs](https://docs.gtk.org/gtk4/class.WindowHandle.html)." GtkWindowHandle
    function GtkAssistantPageFunc(current_page, data)
        f = data
        ret = f(current_page)
        convert(Int32, ret)
    end
    function GtkCellAllocCallback(renderer, cell_area, cell_background, data)
        f = data
        ret = f(renderer, cell_area, cell_background)
        convert(Cint, ret)
    end
    function GtkCellCallback(renderer, data)
        f = data
        ret = f(renderer)
        convert(Cint, ret)
    end
    function GtkCellLayoutDataFunc(cell_layout, cell, tree_model, iter, data)
        f = data
        ret = f(cell_layout, cell, tree_model, iter)
        nothing
    end
    function GtkCustomFilterFunc(item, user_data)
        f = user_data
        ret = f(item)
        convert(Cint, ret)
    end
    function GtkDrawingAreaDrawFunc(drawing_area, cr, width, height, user_data)
        f = user_data
        ret = f(drawing_area, cr, width, height)
        nothing
    end
    function GtkEntryCompletionMatchFunc(completion, key, iter, user_data)
        f = user_data
        ret = f(completion, key, iter)
        convert(Cint, ret)
    end
    function GtkExpressionNotify(user_data)
        f = user_data
        ret = f()
        nothing
    end
    function GtkFlowBoxCreateWidgetFunc(item, user_data)
        f = user_data
        ret = f(item)
        convert(Ptr{GObject}, ret)
    end
    function GtkFlowBoxFilterFunc(child, user_data)
        f = user_data
        ret = f(child)
        convert(Cint, ret)
    end
    function GtkFlowBoxForeachFunc(box, child, user_data)
        f = user_data
        ret = f(box, child)
        nothing
    end
    function GtkFlowBoxSortFunc(child1, child2, user_data)
        f = user_data
        ret = f(child1, child2)
        convert(Int32, ret)
    end
    function GtkFontFilterFunc(family, face, data)
        f = data
        ret = f(family, face)
        convert(Cint, ret)
    end
    function GtkIconViewForeachFunc(icon_view, path, data)
        f = data
        ret = f(icon_view, path)
        nothing
    end
    function GtkListBoxCreateWidgetFunc(item, user_data)
        f = user_data
        ret = f(item)
        convert(Ptr{GObject}, ret)
    end
    function GtkListBoxFilterFunc(row, user_data)
        f = user_data
        ret = f(row)
        convert(Cint, ret)
    end
    function GtkListBoxForeachFunc(box, row, user_data)
        f = user_data
        ret = f(box, row)
        nothing
    end
    function GtkListBoxSortFunc(row1, row2, user_data)
        f = user_data
        ret = f(row1, row2)
        convert(Int32, ret)
    end
    function GtkListBoxUpdateHeaderFunc(row, before, user_data)
        f = user_data
        ret = f(row, before)
        nothing
    end
    function GtkMapListModelMapFunc(item, user_data)
        f = user_data
        ret = f(item)
        convert(Ptr{GObject}, ret)
    end
    function GtkMenuButtonCreatePopupFunc(menu_button, user_data)
        f = user_data
        ret = f(menu_button)
        nothing
    end
    function GtkPageSetupDoneFunc(page_setup, data)
        f = data
        ret = f(page_setup)
        nothing
    end
    function GtkPrintSettingsFunc(key, value, user_data)
        f = user_data
        ret = f(key, value)
        nothing
    end
    function GtkPrinterFunc(printer, data)
        f = data
        ret = f(printer)
        convert(Cint, ret)
    end
    function GtkScaleFormatValueFunc(scale, value, user_data)
        f = user_data
        ret = f(scale, value)
        convert(Cstring, ret)
    end
    function GtkShortcutFunc(widget, args, user_data)
        f = user_data
        ret = f(widget, args)
        convert(Cint, ret)
    end
    function GtkTextCharPredicate(ch, user_data)
        f = user_data
        ret = f(ch)
        convert(Cint, ret)
    end
    function GtkTextTagTableForeach(tag, data)
        f = data
        ret = f(tag)
        nothing
    end
    function GtkTickCallback(widget, frame_clock, user_data)
        f = user_data
        ret = f(widget, frame_clock)
        convert(Cint, ret)
    end
    function GtkTreeCellDataFunc(tree_column, cell, tree_model, iter, data)
        f = data
        ret = f(tree_column, cell, tree_model, iter)
        nothing
    end
    function GtkTreeIterCompareFunc(model, a, b, user_data)
        f = user_data
        ret = f(model, a, b)
        convert(Int32, ret)
    end
    function GtkTreeListModelCreateModelFunc(item, user_data)
        f = user_data
        ret = f(item)
        convert(Ptr{GObject}, ret)
    end
    function GtkTreeModelFilterModifyFunc(model, iter, value, column, data)
        f = data
        ret = f(model, iter, value, column)
        nothing
    end
    function GtkTreeModelFilterVisibleFunc(model, iter, data)
        f = data
        ret = f(model, iter)
        convert(Cint, ret)
    end
    function GtkTreeModelForeachFunc(model, path, iter, data)
        f = data
        ret = f(model, path, iter)
        convert(Cint, ret)
    end
    function GtkTreeSelectionForeachFunc(model, path, iter, data)
        f = data
        ret = f(model, path, iter)
        nothing
    end
    function GtkTreeSelectionFunc(selection, model, path, path_currently_selected, data)
        f = data
        ret = f(selection, model, path, path_currently_selected)
        convert(Cint, ret)
    end
    function GtkTreeViewColumnDropFunc(tree_view, column, prev_column, next_column, data)
        f = data
        ret = f(tree_view, column, prev_column, next_column)
        convert(Cint, ret)
    end
    function GtkTreeViewMappingFunc(tree_view, path, user_data)
        f = user_data
        ret = f(tree_view, path)
        nothing
    end
    function GtkTreeViewRowSeparatorFunc(model, iter, data)
        f = data
        ret = f(model, iter)
        convert(Cint, ret)
    end
    function GtkTreeViewSearchEqualFunc(model, column, key, iter, search_data)
        f = search_data
        ret = f(model, column, key, iter)
        convert(Cint, ret)
    end
    export GtkBitset, GtkBitsetIter, _GtkBitsetIter, GtkBorder, _GtkBorder, GtkBuildableParseContext, GtkBuildableParser, _GtkBuildableParser, GtkCssLocation, _GtkCssLocation, GtkCssSection, GtkCssStyleChange, GtkExpressionWatch, GtkPadActionEntry, _GtkPadActionEntry, GtkPaperSize, GtkPrintBackend, GtkRecentData, _GtkRecentData, GtkRecentInfo, GtkRequestedSize, _GtkRequestedSize, GtkRequisition, _GtkRequisition, GtkTextIter, _GtkTextIter, GtkTreeIter, _GtkTreeIter, GtkTreePath, GtkAccessible, GtkAccessibleRange, GtkActionable, GtkAppChooser, GtkBuildable, GtkBuilderScope, GtkCellEditable, GtkCellLayout, GtkColorChooser, GtkConstraintTarget, GtkEditable, GtkFileChooser, GtkFontChooser, GtkNative, GtkOrientable, GtkPrintOperationPreview, GtkRoot, GtkScrollable, GtkSelectionModel, GtkShortcutManager, GtkStyleProvider, GtkSymbolicPaintable, GtkTreeDragDest, GtkTreeDragSource, GtkTreeModel, GtkTreeSortable, GtkATContext, GtkAboutDialog, GtkAboutDialogLeaf, GtkActionBar, GtkActionBarLeaf, GtkActivateAction, GtkActivateActionLeaf, GtkAdjustment, GtkAdjustmentLeaf, GtkAlertDialog, GtkAlertDialogLeaf, GtkAlternativeTrigger, GtkAlternativeTriggerLeaf, GtkAnyFilter, GtkAnyFilterLeaf, GtkAppChooserButton, GtkAppChooserButtonLeaf, GtkAppChooserDialog, GtkAppChooserDialogLeaf, GtkAppChooserWidget, GtkAppChooserWidgetLeaf, GtkApplication, GtkApplicationLeaf, GtkApplicationWindow, GtkApplicationWindowLeaf, GtkAspectFrame, GtkAspectFrameLeaf, GtkAssistant, GtkAssistantLeaf, GtkAssistantPage, GtkAssistantPageLeaf, GtkBinLayout, GtkBinLayoutLeaf, GtkBookmarkList, GtkBookmarkListLeaf, GtkBoolFilter, GtkBoolFilterLeaf, GtkBox, GtkBoxLeaf, GtkBoxLayout, GtkBoxLayoutLeaf, GtkBuilder, GtkBuilderLeaf, GtkBuilderCScope, GtkBuilderCScopeLeaf, GtkBuilderListItemFactory, GtkBuilderListItemFactoryLeaf, GtkButton, GtkButtonLeaf, GtkCalendar, GtkCalendarLeaf, GtkCallbackAction, GtkCallbackActionLeaf, GtkCellArea, GtkCellAreaBox, GtkCellAreaBoxLeaf, GtkCellAreaContext, GtkCellAreaContextLeaf, GtkCellRenderer, GtkCellRendererAccel, GtkCellRendererAccelLeaf, GtkCellRendererCombo, GtkCellRendererComboLeaf, GtkCellRendererPixbuf, GtkCellRendererPixbufLeaf, GtkCellRendererProgress, GtkCellRendererProgressLeaf, GtkCellRendererSpin, GtkCellRendererSpinLeaf, GtkCellRendererSpinner, GtkCellRendererSpinnerLeaf, GtkCellRendererText, GtkCellRendererTextLeaf, GtkCellRendererToggle, GtkCellRendererToggleLeaf, GtkCellView, GtkCellViewLeaf, GtkCenterBox, GtkCenterBoxLeaf, GtkCenterLayout, GtkCenterLayoutLeaf, GtkCheckButton, GtkCheckButtonLeaf, GtkColorButton, GtkColorButtonLeaf, GtkColorChooserDialog, GtkColorChooserDialogLeaf, GtkColorChooserWidget, GtkColorChooserWidgetLeaf, GtkColorDialog, GtkColorDialogLeaf, GtkColorDialogButton, GtkColorDialogButtonLeaf, GtkColumnView, GtkColumnViewLeaf, GtkColumnViewColumn, GtkColumnViewColumnLeaf, GtkColumnViewSorter, GtkColumnViewSorterLeaf, GtkComboBox, GtkComboBoxLeaf, GtkComboBoxText, GtkComboBoxTextLeaf, GtkConstantExpression, GtkConstantExpressionLeaf, GtkConstraint, GtkConstraintLeaf, GtkConstraintGuide, GtkConstraintGuideLeaf, GtkConstraintLayout, GtkConstraintLayoutLeaf, GtkConstraintLayoutChild, GtkConstraintLayoutChildLeaf, GtkCssProvider, GtkCssProviderLeaf, GtkCustomFilter, GtkCustomFilterLeaf, GtkCustomLayout, GtkCustomLayoutLeaf, GtkCustomSorter, GtkCustomSorterLeaf, GtkDialog, GtkDialogLeaf, GtkDirectoryList, GtkDirectoryListLeaf, GtkDragIcon, GtkDragIconLeaf, GtkDragSource, GtkDragSourceLeaf, GtkDrawingArea, GtkDrawingAreaLeaf, GtkDropControllerMotion, GtkDropControllerMotionLeaf, GtkDropDown, GtkDropDownLeaf, GtkDropTarget, GtkDropTargetLeaf, GtkDropTargetAsync, GtkDropTargetAsyncLeaf, GtkEditableLabel, GtkEditableLabelLeaf, GtkEmojiChooser, GtkEmojiChooserLeaf, GtkEntry, GtkEntryLeaf, GtkEntryBuffer, GtkEntryBufferLeaf, GtkEntryCompletion, GtkEntryCompletionLeaf, GtkEventController, GtkEventControllerFocus, GtkEventControllerFocusLeaf, GtkEventControllerKey, GtkEventControllerKeyLeaf, GtkEventControllerLegacy, GtkEventControllerLegacyLeaf, GtkEventControllerMotion, GtkEventControllerMotionLeaf, GtkEventControllerScroll, GtkEventControllerScrollLeaf, GtkEveryFilter, GtkEveryFilterLeaf, GtkExpander, GtkExpanderLeaf, GtkExpression, GtkFileChooserDialog, GtkFileChooserDialogLeaf, GtkFileChooserNative, GtkFileChooserNativeLeaf, GtkFileChooserWidget, GtkFileChooserWidgetLeaf, GtkFileDialog, GtkFileDialogLeaf, GtkFileFilter, GtkFileFilterLeaf, GtkFileLauncher, GtkFileLauncherLeaf, GtkFilter, GtkFilterLeaf, GtkFilterListModel, GtkFilterListModelLeaf, GtkFixed, GtkFixedLeaf, GtkFixedLayout, GtkFixedLayoutLeaf, GtkFixedLayoutChild, GtkFixedLayoutChildLeaf, GtkFlattenListModel, GtkFlattenListModelLeaf, GtkFlowBox, GtkFlowBoxLeaf, GtkFlowBoxChild, GtkFlowBoxChildLeaf, GtkFontButton, GtkFontButtonLeaf, GtkFontChooserDialog, GtkFontChooserDialogLeaf, GtkFontChooserWidget, GtkFontChooserWidgetLeaf, GtkFontDialog, GtkFontDialogLeaf, GtkFontDialogButton, GtkFontDialogButtonLeaf, GtkFrame, GtkFrameLeaf, GtkGLArea, GtkGLAreaLeaf, GtkGesture, GtkGestureClick, GtkGestureClickLeaf, GtkGestureDrag, GtkGestureDragLeaf, GtkGestureLongPress, GtkGestureLongPressLeaf, GtkGesturePan, GtkGesturePanLeaf, GtkGestureRotate, GtkGestureRotateLeaf, GtkGestureSingle, GtkGestureSingleLeaf, GtkGestureStylus, GtkGestureStylusLeaf, GtkGestureSwipe, GtkGestureSwipeLeaf, GtkGestureZoom, GtkGestureZoomLeaf, GtkGrid, GtkGridLeaf, GtkGridLayout, GtkGridLayoutLeaf, GtkGridLayoutChild, GtkGridLayoutChildLeaf, GtkGridView, GtkGridViewLeaf, GtkHeaderBar, GtkHeaderBarLeaf, GtkIMContext, GtkIMContextSimple, GtkIMContextSimpleLeaf, GtkIMMulticontext, GtkIMMulticontextLeaf, GtkIconPaintable, GtkIconPaintableLeaf, GtkIconTheme, GtkIconThemeLeaf, GtkIconView, GtkIconViewLeaf, GtkImage, GtkImageLeaf, GtkInfoBar, GtkInfoBarLeaf, GtkInscription, GtkInscriptionLeaf, GtkKeyvalTrigger, GtkKeyvalTriggerLeaf, GtkLabel, GtkLabelLeaf, GtkLayoutChild, GtkLayoutManager, GtkLevelBar, GtkLevelBarLeaf, GtkLinkButton, GtkLinkButtonLeaf, GtkListBase, GtkListBox, GtkListBoxLeaf, GtkListBoxRow, GtkListBoxRowLeaf, GtkListItem, GtkListItemLeaf, GtkListItemFactory, GtkListItemFactoryLeaf, GtkListStore, GtkListStoreLeaf, GtkListView, GtkListViewLeaf, GtkLockButton, GtkLockButtonLeaf, GtkMapListModel, GtkMapListModelLeaf, GtkMediaControls, GtkMediaControlsLeaf, GtkMediaFile, GtkMediaStream, GtkMenuButton, GtkMenuButtonLeaf, GtkMessageDialog, GtkMessageDialogLeaf, GtkMnemonicAction, GtkMnemonicActionLeaf, GtkMnemonicTrigger, GtkMnemonicTriggerLeaf, GtkMountOperation, GtkMountOperationLeaf, GtkMultiFilter, GtkMultiSelection, GtkMultiSelectionLeaf, GtkMultiSorter, GtkMultiSorterLeaf, GtkNamedAction, GtkNamedActionLeaf, GtkNativeDialog, GtkNeverTrigger, GtkNeverTriggerLeaf, GtkNoSelection, GtkNoSelectionLeaf, GtkNotebook, GtkNotebookLeaf, GtkNotebookPage, GtkNotebookPageLeaf, GtkNothingAction, GtkNothingActionLeaf, GtkNumericSorter, GtkNumericSorterLeaf, GtkObjectExpression, GtkObjectExpressionLeaf, GtkOverlay, GtkOverlayLeaf, GtkOverlayLayout, GtkOverlayLayoutLeaf, GtkOverlayLayoutChild, GtkOverlayLayoutChildLeaf, GtkPadController, GtkPadControllerLeaf, GtkPageSetup, GtkPageSetupLeaf, GtkPaned, GtkPanedLeaf, GtkPasswordEntry, GtkPasswordEntryLeaf, GtkPasswordEntryBuffer, GtkPasswordEntryBufferLeaf, GtkPicture, GtkPictureLeaf, GtkPopover, GtkPopoverLeaf, GtkPopoverMenu, GtkPopoverMenuLeaf, GtkPopoverMenuBar, GtkPopoverMenuBarLeaf, GtkPrintContext, GtkPrintContextLeaf, GtkPrintJob, GtkPrintJobLeaf, GtkPrintOperation, GtkPrintOperationLeaf, GtkPrintSettings, GtkPrintSettingsLeaf, GtkPrinter, GtkPrinterLeaf, GtkProgressBar, GtkProgressBarLeaf, GtkPropertyExpression, GtkPropertyExpressionLeaf, GtkRange, GtkRangeLeaf, GtkRecentManager, GtkRecentManagerLeaf, GtkRevealer, GtkRevealerLeaf, GtkScale, GtkScaleLeaf, GtkScaleButton, GtkScaleButtonLeaf, GtkScrollbar, GtkScrollbarLeaf, GtkScrolledWindow, GtkScrolledWindowLeaf, GtkSearchBar, GtkSearchBarLeaf, GtkSearchEntry, GtkSearchEntryLeaf, GtkSelectionFilterModel, GtkSelectionFilterModelLeaf, GtkSeparator, GtkSeparatorLeaf, GtkSettings, GtkSettingsLeaf, GtkShortcut, GtkShortcutLeaf, GtkShortcutAction, GtkShortcutController, GtkShortcutControllerLeaf, GtkShortcutLabel, GtkShortcutLabelLeaf, GtkShortcutTrigger, GtkShortcutsGroup, GtkShortcutsGroupLeaf, GtkShortcutsSection, GtkShortcutsSectionLeaf, GtkShortcutsShortcut, GtkShortcutsShortcutLeaf, GtkShortcutsWindow, GtkShortcutsWindowLeaf, GtkSignalAction, GtkSignalActionLeaf, GtkSignalListItemFactory, GtkSignalListItemFactoryLeaf, GtkSingleSelection, GtkSingleSelectionLeaf, GtkSizeGroup, GtkSizeGroupLeaf, GtkSliceListModel, GtkSliceListModelLeaf, GtkSnapshot, GtkSnapshotLeaf, GtkSortListModel, GtkSortListModelLeaf, GtkSorter, GtkSorterLeaf, GtkSpinButton, GtkSpinButtonLeaf, GtkSpinner, GtkSpinnerLeaf, GtkStack, GtkStackLeaf, GtkStackPage, GtkStackPageLeaf, GtkStackSidebar, GtkStackSidebarLeaf, GtkStackSwitcher, GtkStackSwitcherLeaf, GtkStatusbar, GtkStatusbarLeaf, GtkStringFilter, GtkStringFilterLeaf, GtkStringList, GtkStringListLeaf, GtkStringObject, GtkStringObjectLeaf, GtkStringSorter, GtkStringSorterLeaf, GtkStyleContext, GtkStyleContextLeaf, GtkSwitch, GtkSwitchLeaf, GtkText, GtkTextLeaf, GtkTextBuffer, GtkTextBufferLeaf, GtkTextChildAnchor, GtkTextChildAnchorLeaf, GtkTextMark, GtkTextMarkLeaf, GtkTextTag, GtkTextTagLeaf, GtkTextTagTable, GtkTextTagTableLeaf, GtkTextView, GtkTextViewLeaf, GtkToggleButton, GtkToggleButtonLeaf, GtkTooltip, GtkTooltipLeaf, GtkTreeExpander, GtkTreeExpanderLeaf, GtkTreeListModel, GtkTreeListModelLeaf, GtkTreeListRow, GtkTreeListRowLeaf, GtkTreeListRowSorter, GtkTreeListRowSorterLeaf, GtkTreeModelFilter, GtkTreeModelFilterLeaf, GtkTreeModelSort, GtkTreeModelSortLeaf, GtkTreeSelection, GtkTreeSelectionLeaf, GtkTreeStore, GtkTreeStoreLeaf, GtkTreeView, GtkTreeViewLeaf, GtkTreeViewColumn, GtkTreeViewColumnLeaf, GtkUriLauncher, GtkUriLauncherLeaf, GtkVideo, GtkVideoLeaf, GtkViewport, GtkViewportLeaf, GtkVolumeButton, GtkVolumeButtonLeaf, GtkWidget, GtkWidgetPaintable, GtkWidgetPaintableLeaf, GtkWindow, GtkWindowLeaf, GtkWindowControls, GtkWindowControlsLeaf, GtkWindowGroup, GtkWindowGroupLeaf, GtkWindowHandle, GtkWindowHandleLeaf, GtkAssistantPageFunc, GtkCellAllocCallback, GtkCellCallback, GtkCellLayoutDataFunc, GtkCustomFilterFunc, GtkDrawingAreaDrawFunc, GtkEntryCompletionMatchFunc, GtkExpressionNotify, GtkFlowBoxCreateWidgetFunc, GtkFlowBoxFilterFunc, GtkFlowBoxForeachFunc, GtkFlowBoxSortFunc, GtkFontFilterFunc, GtkIconViewForeachFunc, GtkListBoxCreateWidgetFunc, GtkListBoxFilterFunc, GtkListBoxForeachFunc, GtkListBoxSortFunc, GtkListBoxUpdateHeaderFunc, GtkMapListModelMapFunc, GtkMenuButtonCreatePopupFunc, GtkPageSetupDoneFunc, GtkPrintSettingsFunc, GtkPrinterFunc, GtkScaleFormatValueFunc, GtkShortcutFunc, GtkTextCharPredicate, GtkTextTagTableForeach, GtkTickCallback, GtkTreeCellDataFunc, GtkTreeIterCompareFunc, GtkTreeListModelCreateModelFunc, GtkTreeModelFilterModifyFunc, GtkTreeModelFilterVisibleFunc, GtkTreeModelForeachFunc, GtkTreeSelectionForeachFunc, GtkTreeSelectionFunc, GtkTreeViewColumnDropFunc, GtkTreeViewMappingFunc, GtkTreeViewRowSeparatorFunc, GtkTreeViewSearchEqualFunc
end))
end
