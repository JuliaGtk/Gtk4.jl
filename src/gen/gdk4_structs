begin
    const gboxed_types = Any[]
    mutable struct GdkColorState <: GBoxed
        handle::Ptr{GdkColorState}
        (GLib.g_type(::Type{T}) where T <: GdkColorState) = ccall(("gdk_color_state_get_type", libgtk4), GType, ())
        function GdkColorState(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkColorState)
    end
    const GdkColorStateLike = GdkColorState
    mutable struct GdkContentFormats <: GBoxed
        handle::Ptr{GdkContentFormats}
        (GLib.g_type(::Type{T}) where T <: GdkContentFormats) = ccall(("gdk_content_formats_get_type", libgtk4), GType, ())
        function GdkContentFormats(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkContentFormats)
    end
    const GdkContentFormatsLike = GdkContentFormats
    mutable struct GdkContentFormatsBuilder <: GBoxed
        handle::Ptr{GdkContentFormatsBuilder}
        (GLib.g_type(::Type{T}) where T <: GdkContentFormatsBuilder) = ccall(("gdk_content_formats_builder_get_type", libgtk4), GType, ())
        function GdkContentFormatsBuilder(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkContentFormatsBuilder)
    end
    const GdkContentFormatsBuilderLike = GdkContentFormatsBuilder
    mutable struct GdkDmabufFormats <: GBoxed
        handle::Ptr{GdkDmabufFormats}
        (GLib.g_type(::Type{T}) where T <: GdkDmabufFormats) = ccall(("gdk_dmabuf_formats_get_type", libgtk4), GType, ())
        function GdkDmabufFormats(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkDmabufFormats)
    end
    const GdkDmabufFormatsLike = GdkDmabufFormats
    mutable struct GdkDragSurfaceSize
        handle::Ptr{GdkDragSurfaceSize}
    end
    const GdkDragSurfaceSizeLike = GdkDragSurfaceSize
    mutable struct GdkEventSequence <: GBoxed
        handle::Ptr{GdkEventSequence}
        (GLib.g_type(::Type{T}) where T <: GdkEventSequence) = ccall(("gdk_event_sequence_get_type", libgtk4), GType, ())
        function GdkEventSequence(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkEventSequence)
    end
    const GdkEventSequenceLike = GdkEventSequence
    mutable struct GdkFileList <: GBoxed
        handle::Ptr{GdkFileList}
        (GLib.g_type(::Type{T}) where T <: GdkFileList) = ccall(("gdk_file_list_get_type", libgtk4), GType, ())
        function GdkFileList(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkFileList)
    end
    const GdkFileListLike = GdkFileList
    mutable struct GdkFrameTimings <: GBoxed
        handle::Ptr{GdkFrameTimings}
        (GLib.g_type(::Type{T}) where T <: GdkFrameTimings) = ccall(("gdk_frame_timings_get_type", libgtk4), GType, ())
        function GdkFrameTimings(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkFrameTimings)
    end
    const GdkFrameTimingsLike = GdkFrameTimings
    struct _GdkKeymapKey
        keycode::UInt32
        group::Int32
        level::Int32
    end
    mutable struct GdkKeymapKey
        handle::Ptr{_GdkKeymapKey}
    end
    unsafe_convert(::Type{Ptr{_GdkKeymapKey}}, box::GdkKeymapKey) = convert(Ptr{_GdkKeymapKey}, box.handle)
    convert(::Type{GdkKeymapKey}, p::Ptr{_GdkKeymapKey}, owns = false) = GdkKeymapKey(p, owns)
    const GdkKeymapKeyLike = Union{Ref{_GdkKeymapKey}, GdkKeymapKey}
    convert(::Type{GdkKeymapKeyLike}, p, owns) = convert(GdkKeymapKey, p, owns)
    mutable struct GdkPopupLayout <: GBoxed
        handle::Ptr{GdkPopupLayout}
        (GLib.g_type(::Type{T}) where T <: GdkPopupLayout) = ccall(("gdk_popup_layout_get_type", libgtk4), GType, ())
        function GdkPopupLayout(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkPopupLayout)
    end
    const GdkPopupLayoutLike = GdkPopupLayout
    struct _GdkRGBA
        red::Float32
        green::Float32
        blue::Float32
        alpha::Float32
    end
    mutable struct GdkRGBA <: GBoxed
        handle::Ptr{_GdkRGBA}
        (GLib.g_type(::Type{T}) where T <: GdkRGBA) = ccall(("gdk_rgba_get_type", libgtk4), GType, ())
        function GdkRGBA(ref::Ptr{T}, own::Bool = false) where T <: Union{GBoxed, _GdkRGBA}
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkRGBA)
    end
    unsafe_convert(::Type{Ptr{_GdkRGBA}}, box::GdkRGBA) = convert(Ptr{_GdkRGBA}, box.handle)
    convert(::Type{GdkRGBA}, p::Ptr{_GdkRGBA}, owns = false) = GdkRGBA(p, owns)
    const GdkRGBALike = Union{Ref{_GdkRGBA}, GdkRGBA}
    convert(::Type{GdkRGBALike}, p, owns) = convert(GdkRGBA, p, owns)
    struct _GdkRectangle
        x::Int32
        y::Int32
        width::Int32
        height::Int32
    end
    mutable struct GdkRectangle <: GBoxed
        handle::Ptr{_GdkRectangle}
        (GLib.g_type(::Type{T}) where T <: GdkRectangle) = ccall(("gdk_rectangle_get_type", libgtk4), GType, ())
        function GdkRectangle(ref::Ptr{T}, own::Bool = false) where T <: Union{GBoxed, _GdkRectangle}
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkRectangle)
    end
    unsafe_convert(::Type{Ptr{_GdkRectangle}}, box::GdkRectangle) = convert(Ptr{_GdkRectangle}, box.handle)
    convert(::Type{GdkRectangle}, p::Ptr{_GdkRectangle}, owns = false) = GdkRectangle(p, owns)
    const GdkRectangleLike = Union{Ref{_GdkRectangle}, GdkRectangle}
    convert(::Type{GdkRectangleLike}, p, owns) = convert(GdkRectangle, p, owns)
    mutable struct GdkTextureDownloader <: GBoxed
        handle::Ptr{GdkTextureDownloader}
        (GLib.g_type(::Type{T}) where T <: GdkTextureDownloader) = ccall(("gdk_texture_downloader_get_type", libgtk4), GType, ())
        function GdkTextureDownloader(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkTextureDownloader)
    end
    const GdkTextureDownloaderLike = GdkTextureDownloader
    mutable struct GdkTimeCoord
        handle::Ptr{GdkTimeCoord}
    end
    const GdkTimeCoordLike = GdkTimeCoord
    const _GdkTimeCoord = GdkTimeCoord
    mutable struct GdkToplevelLayout <: GBoxed
        handle::Ptr{GdkToplevelLayout}
        (GLib.g_type(::Type{T}) where T <: GdkToplevelLayout) = ccall(("gdk_toplevel_layout_get_type", libgtk4), GType, ())
        function GdkToplevelLayout(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GdkToplevelLayout)
    end
    const GdkToplevelLayoutLike = GdkToplevelLayout
    gboxed_cache_init() = append!(GLib.gboxed_types, gboxed_types)
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.ColorState.html)." GdkColorState
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.ContentFormats.html)." GdkContentFormats
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.ContentFormatsBuilder.html)." GdkContentFormatsBuilder
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.DmabufFormats.html)." GdkDmabufFormats
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.DragSurfaceSize.html)." GdkDragSurfaceSize
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.EventSequence.html)." GdkEventSequence
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.FileList.html)." GdkFileList
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.FrameTimings.html)." GdkFrameTimings
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.KeymapKey.html)." GdkKeymapKey
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.PopupLayout.html)." GdkPopupLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.RGBA.html)." GdkRGBA
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.Rectangle.html)." GdkRectangle
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.TextureDownloader.html)." GdkTextureDownloader
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.TimeCoord.html)." GdkTimeCoord
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.ToplevelLayout.html)." GdkToplevelLayout
    GLib.@Giface GdkDevicePad libgtk4 gdk_device_pad_get_type
    GLib.@Giface GdkDragSurface libgtk4 gdk_drag_surface_get_type
    GLib.@Giface GdkPaintable libgtk4 gdk_paintable_get_type
    GLib.@Giface GdkPopup libgtk4 gdk_popup_get_type
    GLib.@Giface GdkToplevel libgtk4 gdk_toplevel_get_type
    const gtype_wrapper_cache = Dict{Symbol, Type}()
    abstract type GdkAppLaunchContext <: GAppLaunchContext end
    mutable struct GdkAppLaunchContextLeaf <: GdkAppLaunchContext
        handle::Ptr{GObject}
        function GdkAppLaunchContextLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkAppLaunchContextLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkAppLaunchContext] = GdkAppLaunchContextLeaf
    (GLib.g_type(::Type{T}) where T <: GdkAppLaunchContext) = ccall(("gdk_app_launch_context_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkAppLaunchContext})
        signalnames(supertype(GdkAppLaunchContext))
    end
    abstract type GdkEvent <: GTypeInstance end
    Base.convert(::Type{GdkEvent}, ptr::Ptr{GdkEvent}) = GdkEventLeaf(ptr)
    Base.unsafe_convert(::Type{Ptr{GdkEvent}}, o::GdkEvent) = o.handle
    mutable struct GdkEventLeaf <: GdkEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkButtonEvent <: GdkEvent end
    mutable struct GdkButtonEventLeaf <: GdkButtonEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkDrawContext <: GObject end
    mutable struct GdkDrawContextLeaf <: GdkDrawContext
        handle::Ptr{GObject}
        function GdkDrawContextLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkDrawContextLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkDrawContext] = GdkDrawContextLeaf
    (GLib.g_type(::Type{T}) where T <: GdkDrawContext) = ccall(("gdk_draw_context_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkDrawContext})
        signalnames(supertype(GdkDrawContext))
    end
    abstract type GdkCairoContext <: GdkDrawContext end
    mutable struct GdkCairoContextLeaf <: GdkCairoContext
        handle::Ptr{GObject}
        function GdkCairoContextLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkCairoContextLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkCairoContext] = GdkCairoContextLeaf
    (GLib.g_type(::Type{T}) where T <: GdkCairoContext) = ccall(("gdk_cairo_context_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkCairoContext})
        signalnames(supertype(GdkCairoContext))
    end
    abstract type GdkCicpParams <: GObject end
    mutable struct GdkCicpParamsLeaf <: GdkCicpParams
        handle::Ptr{GObject}
        function GdkCicpParamsLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkCicpParamsLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkCicpParams] = GdkCicpParamsLeaf
    (GLib.g_type(::Type{T}) where T <: GdkCicpParams) = ccall(("gdk_cicp_params_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkCicpParams})
        signalnames(supertype(GdkCicpParams))
    end
    abstract type GdkClipboard <: GObject end
    mutable struct GdkClipboardLeaf <: GdkClipboard
        handle::Ptr{GObject}
        function GdkClipboardLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkClipboardLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkClipboard] = GdkClipboardLeaf
    (GLib.g_type(::Type{T}) where T <: GdkClipboard) = ccall(("gdk_clipboard_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkClipboard})
        vcat([:changed], signalnames(supertype(GdkClipboard)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :changed => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkClipboard
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkClipboard
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkContentDeserializer <: GObject end
    mutable struct GdkContentDeserializerLeaf <: GdkContentDeserializer
        handle::Ptr{GObject}
        function GdkContentDeserializerLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkContentDeserializerLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkContentDeserializer] = GdkContentDeserializerLeaf
    (GLib.g_type(::Type{T}) where T <: GdkContentDeserializer) = ccall(("gdk_content_deserializer_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkContentDeserializer})
        signalnames(supertype(GdkContentDeserializer))
    end
    abstract type GdkContentProvider <: GObject end
    mutable struct GdkContentProviderLeaf <: GdkContentProvider
        handle::Ptr{GObject}
        function GdkContentProviderLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkContentProviderLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkContentProvider] = GdkContentProviderLeaf
    (GLib.g_type(::Type{T}) where T <: GdkContentProvider) = ccall(("gdk_content_provider_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkContentProvider})
        vcat([:content_changed], signalnames(supertype(GdkContentProvider)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :content_changed => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkContentProvider
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkContentProvider
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkContentSerializer <: GObject end
    mutable struct GdkContentSerializerLeaf <: GdkContentSerializer
        handle::Ptr{GObject}
        function GdkContentSerializerLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkContentSerializerLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkContentSerializer] = GdkContentSerializerLeaf
    (GLib.g_type(::Type{T}) where T <: GdkContentSerializer) = ccall(("gdk_content_serializer_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkContentSerializer})
        signalnames(supertype(GdkContentSerializer))
    end
    abstract type GdkCrossingEvent <: GdkEvent end
    mutable struct GdkCrossingEventLeaf <: GdkCrossingEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkCursor <: GObject end
    mutable struct GdkCursorLeaf <: GdkCursor
        handle::Ptr{GObject}
        function GdkCursorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkCursorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkCursor] = GdkCursorLeaf
    (GLib.g_type(::Type{T}) where T <: GdkCursor) = ccall(("gdk_cursor_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkCursor})
        signalnames(supertype(GdkCursor))
    end
    abstract type GdkDNDEvent <: GdkEvent end
    mutable struct GdkDNDEventLeaf <: GdkDNDEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkDeleteEvent <: GdkEvent end
    mutable struct GdkDeleteEventLeaf <: GdkDeleteEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkDevice <: GObject end
    mutable struct GdkDeviceLeaf <: GdkDevice
        handle::Ptr{GObject}
        function GdkDeviceLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkDeviceLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkDevice] = GdkDeviceLeaf
    (GLib.g_type(::Type{T}) where T <: GdkDevice) = ccall(("gdk_device_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkDevice})
        vcat([:changed, :tool_changed], signalnames(supertype(GdkDevice)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :tool_changed => (:Nothing, Expr[:(Ptr{GObject})]), :changed => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkDevice
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkDevice
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkDeviceTool <: GObject end
    mutable struct GdkDeviceToolLeaf <: GdkDeviceTool
        handle::Ptr{GObject}
        function GdkDeviceToolLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkDeviceToolLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkDeviceTool] = GdkDeviceToolLeaf
    (GLib.g_type(::Type{T}) where T <: GdkDeviceTool) = ccall(("gdk_device_tool_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkDeviceTool})
        signalnames(supertype(GdkDeviceTool))
    end
    abstract type GdkDisplay <: GObject end
    mutable struct GdkDisplayLeaf <: GdkDisplay
        handle::Ptr{GObject}
        function GdkDisplayLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkDisplayLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkDisplay] = GdkDisplayLeaf
    (GLib.g_type(::Type{T}) where T <: GdkDisplay) = ccall(("gdk_display_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkDisplay})
        vcat([:closed, :opened, :seat_added, :seat_removed, :setting_changed], signalnames(supertype(GdkDisplay)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :opened => (:Nothing, Any[]), :setting_changed => (:Nothing, [:Cstring]), :seat_removed => (:Nothing, Expr[:(Ptr{GObject})]), :seat_added => (:Nothing, Expr[:(Ptr{GObject})]), :closed => (:Nothing, [:Cint]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkDisplay
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkDisplay
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkDisplayManager <: GObject end
    mutable struct GdkDisplayManagerLeaf <: GdkDisplayManager
        handle::Ptr{GObject}
        function GdkDisplayManagerLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkDisplayManagerLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkDisplayManager] = GdkDisplayManagerLeaf
    (GLib.g_type(::Type{T}) where T <: GdkDisplayManager) = ccall(("gdk_display_manager_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkDisplayManager})
        vcat([:display_opened], signalnames(supertype(GdkDisplayManager)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :display_opened => (:Nothing, Expr[:(Ptr{GObject})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkDisplayManager
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkDisplayManager
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkTexture <: GObject end
    mutable struct GdkTextureLeaf <: GdkTexture
        handle::Ptr{GObject}
        function GdkTextureLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkTextureLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkTexture] = GdkTextureLeaf
    (GLib.g_type(::Type{T}) where T <: GdkTexture) = ccall(("gdk_texture_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkTexture})
        vcat([:invalidate_contents, :invalidate_size], signalnames(supertype(GdkTexture)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkTexture
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkTexture
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkDmabufTexture <: GdkTexture end
    mutable struct GdkDmabufTextureLeaf <: GdkDmabufTexture
        handle::Ptr{GObject}
        function GdkDmabufTextureLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkDmabufTextureLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkDmabufTexture] = GdkDmabufTextureLeaf
    (GLib.g_type(::Type{T}) where T <: GdkDmabufTexture) = ccall(("gdk_dmabuf_texture_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkDmabufTexture})
        vcat([:invalidate_contents, :invalidate_size], signalnames(supertype(GdkDmabufTexture)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkDmabufTexture
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkDmabufTexture
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkDmabufTextureBuilder <: GObject end
    mutable struct GdkDmabufTextureBuilderLeaf <: GdkDmabufTextureBuilder
        handle::Ptr{GObject}
        function GdkDmabufTextureBuilderLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkDmabufTextureBuilderLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkDmabufTextureBuilder] = GdkDmabufTextureBuilderLeaf
    (GLib.g_type(::Type{T}) where T <: GdkDmabufTextureBuilder) = ccall(("gdk_dmabuf_texture_builder_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkDmabufTextureBuilder})
        signalnames(supertype(GdkDmabufTextureBuilder))
    end
    abstract type GdkDrag <: GObject end
    mutable struct GdkDragLeaf <: GdkDrag
        handle::Ptr{GObject}
        function GdkDragLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkDragLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkDrag] = GdkDragLeaf
    (GLib.g_type(::Type{T}) where T <: GdkDrag) = ccall(("gdk_drag_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkDrag})
        vcat([:cancel, :dnd_finished, :drop_performed], signalnames(supertype(GdkDrag)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :dnd_finished => (:Nothing, Any[]), :cancel => (:Nothing, [:UInt32]), :drop_performed => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkDrag
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkDrag
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkDrop <: GObject end
    mutable struct GdkDropLeaf <: GdkDrop
        handle::Ptr{GObject}
        function GdkDropLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkDropLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkDrop] = GdkDropLeaf
    (GLib.g_type(::Type{T}) where T <: GdkDrop) = ccall(("gdk_drop_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkDrop})
        signalnames(supertype(GdkDrop))
    end
    abstract type GdkFocusEvent <: GdkEvent end
    mutable struct GdkFocusEventLeaf <: GdkFocusEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkFrameClock <: GObject end
    mutable struct GdkFrameClockLeaf <: GdkFrameClock
        handle::Ptr{GObject}
        function GdkFrameClockLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkFrameClockLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkFrameClock] = GdkFrameClockLeaf
    (GLib.g_type(::Type{T}) where T <: GdkFrameClock) = ccall(("gdk_frame_clock_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkFrameClock})
        vcat([:after_paint, :before_paint, :flush_events, :layout, :paint, :resume_events, :update], signalnames(supertype(GdkFrameClock)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :before_paint => (:Nothing, Any[]), :update => (:Nothing, Any[]), :flush_events => (:Nothing, Any[]), :layout => (:Nothing, Any[]), :after_paint => (:Nothing, Any[]), :resume_events => (:Nothing, Any[]), :paint => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkFrameClock
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkFrameClock
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkGLContext <: GdkDrawContext end
    mutable struct GdkGLContextLeaf <: GdkGLContext
        handle::Ptr{GObject}
        function GdkGLContextLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkGLContextLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkGLContext] = GdkGLContextLeaf
    (GLib.g_type(::Type{T}) where T <: GdkGLContext) = ccall(("gdk_gl_context_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkGLContext})
        signalnames(supertype(GdkGLContext))
    end
    abstract type GdkGLTexture <: GdkTexture end
    mutable struct GdkGLTextureLeaf <: GdkGLTexture
        handle::Ptr{GObject}
        function GdkGLTextureLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkGLTextureLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkGLTexture] = GdkGLTextureLeaf
    (GLib.g_type(::Type{T}) where T <: GdkGLTexture) = ccall(("gdk_gl_texture_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkGLTexture})
        vcat([:invalidate_contents, :invalidate_size], signalnames(supertype(GdkGLTexture)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkGLTexture
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkGLTexture
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkGLTextureBuilder <: GObject end
    mutable struct GdkGLTextureBuilderLeaf <: GdkGLTextureBuilder
        handle::Ptr{GObject}
        function GdkGLTextureBuilderLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkGLTextureBuilderLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkGLTextureBuilder] = GdkGLTextureBuilderLeaf
    (GLib.g_type(::Type{T}) where T <: GdkGLTextureBuilder) = ccall(("gdk_gl_texture_builder_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkGLTextureBuilder})
        signalnames(supertype(GdkGLTextureBuilder))
    end
    abstract type GdkGrabBrokenEvent <: GdkEvent end
    mutable struct GdkGrabBrokenEventLeaf <: GdkGrabBrokenEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkKeyEvent <: GdkEvent end
    mutable struct GdkKeyEventLeaf <: GdkKeyEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkMemoryTexture <: GdkTexture end
    mutable struct GdkMemoryTextureLeaf <: GdkMemoryTexture
        handle::Ptr{GObject}
        function GdkMemoryTextureLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkMemoryTextureLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkMemoryTexture] = GdkMemoryTextureLeaf
    (GLib.g_type(::Type{T}) where T <: GdkMemoryTexture) = ccall(("gdk_memory_texture_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkMemoryTexture})
        vcat([:invalidate_contents, :invalidate_size], signalnames(supertype(GdkMemoryTexture)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkMemoryTexture
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkMemoryTexture
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkMemoryTextureBuilder <: GObject end
    mutable struct GdkMemoryTextureBuilderLeaf <: GdkMemoryTextureBuilder
        handle::Ptr{GObject}
        function GdkMemoryTextureBuilderLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkMemoryTextureBuilderLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkMemoryTextureBuilder] = GdkMemoryTextureBuilderLeaf
    (GLib.g_type(::Type{T}) where T <: GdkMemoryTextureBuilder) = ccall(("gdk_memory_texture_builder_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkMemoryTextureBuilder})
        signalnames(supertype(GdkMemoryTextureBuilder))
    end
    abstract type GdkMonitor <: GObject end
    mutable struct GdkMonitorLeaf <: GdkMonitor
        handle::Ptr{GObject}
        function GdkMonitorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkMonitorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkMonitor] = GdkMonitorLeaf
    (GLib.g_type(::Type{T}) where T <: GdkMonitor) = ccall(("gdk_monitor_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkMonitor})
        vcat([:invalidate], signalnames(supertype(GdkMonitor)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :invalidate => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkMonitor
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkMonitor
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkMotionEvent <: GdkEvent end
    mutable struct GdkMotionEventLeaf <: GdkMotionEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkPadEvent <: GdkEvent end
    mutable struct GdkPadEventLeaf <: GdkPadEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkProximityEvent <: GdkEvent end
    mutable struct GdkProximityEventLeaf <: GdkProximityEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkScrollEvent <: GdkEvent end
    mutable struct GdkScrollEventLeaf <: GdkScrollEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkSeat <: GObject end
    mutable struct GdkSeatLeaf <: GdkSeat
        handle::Ptr{GObject}
        function GdkSeatLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkSeatLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkSeat] = GdkSeatLeaf
    (GLib.g_type(::Type{T}) where T <: GdkSeat) = ccall(("gdk_seat_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkSeat})
        vcat([:device_added, :device_removed, :tool_added, :tool_removed], signalnames(supertype(GdkSeat)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :tool_removed => (:Nothing, Expr[:(Ptr{GObject})]), :device_added => (:Nothing, Expr[:(Ptr{GObject})]), :tool_added => (:Nothing, Expr[:(Ptr{GObject})]), :device_removed => (:Nothing, Expr[:(Ptr{GObject})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkSeat
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkSeat
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkSnapshot <: GObject end
    mutable struct GdkSnapshotLeaf <: GdkSnapshot
        handle::Ptr{GObject}
        function GdkSnapshotLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkSnapshotLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkSnapshot] = GdkSnapshotLeaf
    (GLib.g_type(::Type{T}) where T <: GdkSnapshot) = ccall(("gdk_snapshot_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkSnapshot})
        signalnames(supertype(GdkSnapshot))
    end
    abstract type GdkSurface <: GObject end
    mutable struct GdkSurfaceLeaf <: GdkSurface
        handle::Ptr{GObject}
        function GdkSurfaceLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GdkSurfaceLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GdkSurface] = GdkSurfaceLeaf
    (GLib.g_type(::Type{T}) where T <: GdkSurface) = ccall(("gdk_surface_get_type", libgtk4), GType, ())
    function GLib.signalnames(::Type{GdkSurface})
        vcat([:enter_monitor, :event, :layout, :leave_monitor, :render], signalnames(supertype(GdkSurface)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Cint, Expr[:(Ptr{GdkEvent})]), :render => (:Cint, [:cairoRegion]), :layout => (:Nothing, [:Int32, :Int32]), :enter_monitor => (:Nothing, Expr[:(Ptr{GObject})]), :leave_monitor => (:Nothing, Expr[:(Ptr{GObject})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkSurface
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkSurface
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GdkTouchEvent <: GdkEvent end
    mutable struct GdkTouchEventLeaf <: GdkTouchEvent
        handle::Ptr{GdkEvent}
    end
    abstract type GdkTouchpadEvent <: GdkEvent end
    mutable struct GdkTouchpadEventLeaf <: GdkTouchpadEvent
        handle::Ptr{GdkEvent}
    end
    gtype_wrapper_cache_init() = merge!(GLib.gtype_wrappers, gtype_wrapper_cache)
    function GdkCicpParams(; kwargs...)
        obj = G_.CicpParams_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkContentProvider(_mime_type::Union{AbstractString, Symbol}, _bytes::GBytes; kwargs...)
        obj = G_.ContentProvider_new_for_bytes(_mime_type, _bytes)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkContentProvider(_value::GValueLike; kwargs...)
        obj = G_.ContentProvider_new_for_value(_value)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkContentProvider(_providers; kwargs...)
        obj = G_.ContentProvider_new_union(_providers)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkCursor(_callback::Function, _destroy::Function, _fallback::Maybe(GdkCursor); kwargs...)
        obj = G_.Cursor_new_from_callback(_callback, _destroy, _fallback)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkCursor(_name::Union{AbstractString, Symbol}, _fallback::Maybe(GdkCursor); kwargs...)
        obj = G_.Cursor_new_from_name(_name, _fallback)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkCursor(_texture::GdkTexture, _hotspot_x::Integer, _hotspot_y::Integer, _fallback::Maybe(GdkCursor); kwargs...)
        obj = G_.Cursor_new_from_texture(_texture, _hotspot_x, _hotspot_y, _fallback)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkDmabufTextureBuilder(; kwargs...)
        obj = G_.DmabufTextureBuilder_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkGLTextureBuilder(; kwargs...)
        obj = G_.GLTextureBuilder_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkMemoryTexture(_width::Integer, _height::Integer, _format, _bytes::GBytes, _stride::Integer)
        G_.MemoryTexture_new(_width, _height, _format, _bytes, _stride)
    end
    function GdkMemoryTextureBuilder(; kwargs...)
        obj = G_.MemoryTextureBuilder_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkSurface(_parent::GdkSurface, _autohide::Bool; kwargs...)
        obj = G_.Surface_new_popup(_parent, _autohide)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkSurface(_display::GdkDisplay; kwargs...)
        obj = G_.Surface_new_toplevel(_display)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkTexture(_pixbuf::GdkPixbuf; kwargs...)
        obj = G_.Texture_new_for_pixbuf(_pixbuf)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkTexture(_bytes::GBytes; kwargs...)
        obj = G_.Texture_new_from_bytes(_bytes)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkTexture(_file::GFile; kwargs...)
        obj = G_.Texture_new_from_file(_file)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkTexture(_path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Texture_new_from_filename(_path)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkContentFormats(_mime_types)
        G_.ContentFormats_new(_mime_types)
    end
    function GdkContentFormats(_type::Integer)
        G_.ContentFormats_new_for_gtype(_type)
    end
    function GdkContentFormatsBuilder()
        G_.ContentFormatsBuilder_new()
    end
    function GdkFileList(_files)
        G_.FileList_new_from_array(_files)
    end
    function GdkFileList(_files::GLib.LList{GLib._GSList{Ptr{GObject}}})
        G_.FileList_new_from_list(_files)
    end
    function GdkPopupLayout(_anchor_rect::GdkRectangleLike, _rect_anchor, _surface_anchor)
        G_.PopupLayout_new(_anchor_rect, _rect_anchor, _surface_anchor)
    end
    function GdkTextureDownloader(_texture::GdkTexture)
        G_.TextureDownloader_new(_texture)
    end
    function GdkToplevelLayout()
        G_.ToplevelLayout_new()
    end
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.AppLaunchContext.html)." GdkAppLaunchContext
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ButtonEvent.html)." GdkButtonEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.CairoContext.html)." GdkCairoContext
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.CicpParams.html)." GdkCicpParams
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Clipboard.html)." GdkClipboard
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ContentDeserializer.html)." GdkContentDeserializer
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ContentProvider.html)." GdkContentProvider
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ContentSerializer.html)." GdkContentSerializer
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.CrossingEvent.html)." GdkCrossingEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Cursor.html)." GdkCursor
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DNDEvent.html)." GdkDNDEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DeleteEvent.html)." GdkDeleteEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Device.html)." GdkDevice
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DeviceTool.html)." GdkDeviceTool
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Display.html)." GdkDisplay
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DisplayManager.html)." GdkDisplayManager
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DmabufTexture.html)." GdkDmabufTexture
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DmabufTextureBuilder.html)." GdkDmabufTextureBuilder
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Drag.html)." GdkDrag
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DrawContext.html)." GdkDrawContext
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Drop.html)." GdkDrop
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Event.html)." GdkEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.FocusEvent.html)." GdkFocusEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.FrameClock.html)." GdkFrameClock
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.GLContext.html)." GdkGLContext
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.GLTexture.html)." GdkGLTexture
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.GLTextureBuilder.html)." GdkGLTextureBuilder
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.GrabBrokenEvent.html)." GdkGrabBrokenEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.KeyEvent.html)." GdkKeyEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.MemoryTexture.html)." GdkMemoryTexture
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.MemoryTextureBuilder.html)." GdkMemoryTextureBuilder
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Monitor.html)." GdkMonitor
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.MotionEvent.html)." GdkMotionEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.PadEvent.html)." GdkPadEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ProximityEvent.html)." GdkProximityEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ScrollEvent.html)." GdkScrollEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Seat.html)." GdkSeat
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Snapshot.html)." GdkSnapshot
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Surface.html)." GdkSurface
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Texture.html)." GdkTexture
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.TouchEvent.html)." GdkTouchEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.TouchpadEvent.html)." GdkTouchpadEvent
    function on_changed(f, object::GdkClipboard, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "changed", Nothing, (), after, user_data)
    end
    function on_content_changed(f, object::GdkContentProvider, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "content-changed", Nothing, (), after, user_data)
    end
    function on_changed(f, object::GdkDevice, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "changed", Nothing, (), after, user_data)
    end
    function on_tool_changed(f, object::GdkDevice, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "tool-changed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_closed(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "closed", Nothing, (Cint,), after, user_data)
    end
    function on_opened(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "opened", Nothing, (), after, user_data)
    end
    function on_seat_added(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "seat-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_seat_removed(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "seat-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_setting_changed(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "setting-changed", Nothing, (Cstring,), after, user_data)
    end
    function on_display_opened(f, object::GdkDisplayManager, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "display-opened", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_invalidate_contents(f, object::GdkDmabufTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-contents", Nothing, (), after, user_data)
    end
    function on_invalidate_size(f, object::GdkDmabufTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-size", Nothing, (), after, user_data)
    end
    function on_cancel(f, object::GdkDrag, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "cancel", Nothing, (UInt32,), after, user_data)
    end
    function on_dnd_finished(f, object::GdkDrag, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "dnd-finished", Nothing, (), after, user_data)
    end
    function on_drop_performed(f, object::GdkDrag, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drop-performed", Nothing, (), after, user_data)
    end
    function on_after_paint(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "after-paint", Nothing, (), after, user_data)
    end
    function on_before_paint(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "before-paint", Nothing, (), after, user_data)
    end
    function on_flush_events(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "flush-events", Nothing, (), after, user_data)
    end
    function on_layout(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "layout", Nothing, (), after, user_data)
    end
    function on_paint(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "paint", Nothing, (), after, user_data)
    end
    function on_resume_events(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "resume-events", Nothing, (), after, user_data)
    end
    function on_update(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "update", Nothing, (), after, user_data)
    end
    function on_invalidate_contents(f, object::GdkGLTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-contents", Nothing, (), after, user_data)
    end
    function on_invalidate_size(f, object::GdkGLTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-size", Nothing, (), after, user_data)
    end
    function on_invalidate_contents(f, object::GdkMemoryTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-contents", Nothing, (), after, user_data)
    end
    function on_invalidate_size(f, object::GdkMemoryTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-size", Nothing, (), after, user_data)
    end
    function on_invalidate(f, object::GdkMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate", Nothing, (), after, user_data)
    end
    function on_device_added(f, object::GdkSeat, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "device-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_device_removed(f, object::GdkSeat, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "device-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_tool_added(f, object::GdkSeat, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "tool-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_tool_removed(f, object::GdkSeat, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "tool-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_enter_monitor(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "enter-monitor", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_event(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "event", Cint, (Ptr{GdkEvent},), after, user_data)
    end
    function on_layout(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "layout", Nothing, (Int32, Int32), after, user_data)
    end
    function on_leave_monitor(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "leave-monitor", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_render(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "render", Cint, (cairoRegion,), after, user_data)
    end
    function on_invalidate_contents(f, object::GdkTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-contents", Nothing, (), after, user_data)
    end
    function on_invalidate_size(f, object::GdkTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-size", Nothing, (), after, user_data)
    end
    function GdkCursorGetTextureCallback(cursor, cursor_size, scale, width, height, hotspot_x, hotspot_y, data)
        cursor = convert(GdkCursor, cursor, false)
        f = data
        ret = f(cursor, cursor_size, scale, width, height, hotspot_x, hotspot_y)
        ret != C_NULL && GLib.glib_ref(ret)
        convert(Ptr{GObject}, GLib.get_pointer(ret))
    end
    export GdkColorState, GdkContentFormats, GdkContentFormatsBuilder, GdkDmabufFormats, GdkDragSurfaceSize, GdkEventSequence, GdkFileList, GdkFrameTimings, GdkKeymapKey, GdkKeymapKeyLike, _GdkKeymapKey, GdkPopupLayout, GdkRGBA, GdkRGBALike, _GdkRGBA, GdkRectangle, GdkRectangleLike, _GdkRectangle, GdkTextureDownloader, GdkTimeCoord, GdkTimeCoordLike, _GdkTimeCoord, GdkToplevelLayout, GdkDevicePad, GdkDragSurface, GdkPaintable, GdkPopup, GdkToplevel, GdkAppLaunchContext, GdkAppLaunchContextLeaf, GdkButtonEvent, GdkButtonEventLeaf, GdkCairoContext, GdkCicpParams, GdkCicpParamsLeaf, GdkClipboard, GdkClipboardLeaf, GdkContentDeserializer, GdkContentDeserializerLeaf, GdkContentProvider, GdkContentProviderLeaf, GdkContentSerializer, GdkContentSerializerLeaf, GdkCrossingEvent, GdkCrossingEventLeaf, GdkCursor, GdkCursorLeaf, GdkDNDEvent, GdkDNDEventLeaf, GdkDeleteEvent, GdkDeleteEventLeaf, GdkDevice, GdkDeviceTool, GdkDeviceToolLeaf, GdkDisplay, GdkDisplayLeaf, GdkDisplayManager, GdkDisplayManagerLeaf, GdkDmabufTexture, GdkDmabufTextureLeaf, GdkDmabufTextureBuilder, GdkDmabufTextureBuilderLeaf, GdkDrag, GdkDrawContext, GdkDrop, GdkEvent, GdkFocusEvent, GdkFocusEventLeaf, GdkFrameClock, GdkGLContext, GdkGLTexture, GdkGLTextureLeaf, GdkGLTextureBuilder, GdkGLTextureBuilderLeaf, GdkGrabBrokenEvent, GdkGrabBrokenEventLeaf, GdkKeyEvent, GdkKeyEventLeaf, GdkMemoryTexture, GdkMemoryTextureLeaf, GdkMemoryTextureBuilder, GdkMemoryTextureBuilderLeaf, GdkMonitor, GdkMonitorLeaf, GdkMotionEvent, GdkMotionEventLeaf, GdkPadEvent, GdkPadEventLeaf, GdkProximityEvent, GdkProximityEventLeaf, GdkScrollEvent, GdkScrollEventLeaf, GdkSeat, GdkSnapshot, GdkSurface, GdkTexture, GdkTouchEvent, GdkTouchEventLeaf, GdkTouchpadEvent, GdkTouchpadEventLeaf, GdkCursorGetTextureCallback
end
