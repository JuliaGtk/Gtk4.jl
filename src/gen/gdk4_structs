quote
$(Expr(:toplevel, quote
    begin
        nothing
        mutable struct GdkContentFormats <: GBoxed
            handle::Ptr{GdkContentFormats}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkContentFormats) = begin
                        ccall(("gdk_content_formats_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GdkContentFormats(ref::Ptr{GdkContentFormats}, own::Bool = false)
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                function Base.setindex!(v::GLib.GV, ::Type{T}) where T <: GdkContentFormats
                    gtype = ccall(($(QuoteNode("gdk_content_formats_get_type")), "libgtk-4.so.1"), GType, ())
                    ccall((:g_value_init, libgobject), Nothing, (Ptr{GValue}, Csize_t), v, gtype)
                    v
                end
            end
        end
        nothing
    end
    begin
        nothing
        mutable struct GdkContentFormatsBuilder <: GBoxed
            handle::Ptr{GdkContentFormatsBuilder}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkContentFormatsBuilder) = begin
                        ccall(("gdk_content_formats_builder_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GdkContentFormatsBuilder(ref::Ptr{GdkContentFormatsBuilder}, own::Bool = false)
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                function Base.setindex!(v::GLib.GV, ::Type{T}) where T <: GdkContentFormatsBuilder
                    gtype = ccall(($(QuoteNode("gdk_content_formats_builder_get_type")), "libgtk-4.so.1"), GType, ())
                    ccall((:g_value_init, libgobject), Nothing, (Ptr{GValue}, Csize_t), v, gtype)
                    v
                end
            end
        end
        nothing
    end
    begin
        nothing
        mutable struct GdkEventSequence <: GBoxed
            handle::Ptr{GdkEventSequence}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkEventSequence) = begin
                        ccall(("gdk_event_sequence_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GdkEventSequence(ref::Ptr{GdkEventSequence}, own::Bool = false)
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                function Base.setindex!(v::GLib.GV, ::Type{T}) where T <: GdkEventSequence
                    gtype = ccall(($(QuoteNode("gdk_event_sequence_get_type")), "libgtk-4.so.1"), GType, ())
                    ccall((:g_value_init, libgobject), Nothing, (Ptr{GValue}, Csize_t), v, gtype)
                    v
                end
            end
        end
        nothing
    end
    begin
        nothing
        mutable struct GdkFrameTimings <: GBoxed
            handle::Ptr{GdkFrameTimings}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkFrameTimings) = begin
                        ccall(("gdk_frame_timings_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GdkFrameTimings(ref::Ptr{GdkFrameTimings}, own::Bool = false)
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                function Base.setindex!(v::GLib.GV, ::Type{T}) where T <: GdkFrameTimings
                    gtype = ccall(($(QuoteNode("gdk_frame_timings_get_type")), "libgtk-4.so.1"), GType, ())
                    ccall((:g_value_init, libgobject), Nothing, (Ptr{GValue}, Csize_t), v, gtype)
                    v
                end
            end
        end
        nothing
    end
    begin
        begin
            struct _GdkKeymapKey
                keycode::UInt32
                group::Int32
                level::Int32
            end
        end
        mutable struct GdkKeymapKey
            handle::Ptr{GdkKeymapKey}
        end
        begin
            function Base.getproperty(s::GdkKeymapKey, sym::Symbol)
                if sym === :handle
                    return getfield(s, :handle)
                elseif sym in fieldnames(_GdkKeymapKey)
                    u = unsafe_load(Ptr{_GdkKeymapKey}(s.handle))
                    return getfield(u, sym)
                end
            end
        end
    end
    begin
        nothing
        mutable struct GdkPopupLayout <: GBoxed
            handle::Ptr{GdkPopupLayout}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkPopupLayout) = begin
                        ccall(("gdk_popup_layout_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GdkPopupLayout(ref::Ptr{GdkPopupLayout}, own::Bool = false)
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                function Base.setindex!(v::GLib.GV, ::Type{T}) where T <: GdkPopupLayout
                    gtype = ccall(($(QuoteNode("gdk_popup_layout_get_type")), "libgtk-4.so.1"), GType, ())
                    ccall((:g_value_init, libgobject), Nothing, (Ptr{GValue}, Csize_t), v, gtype)
                    v
                end
            end
        end
        nothing
    end
    begin
        begin
            struct _GdkRGBA
                red::Float32
                green::Float32
                blue::Float32
                alpha::Float32
            end
        end
        mutable struct GdkRGBA <: GBoxed
            handle::Ptr{GdkRGBA}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkRGBA) = begin
                        ccall(("gdk_rgba_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GdkRGBA(ref::Ptr{GdkRGBA}, own::Bool = false)
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                function Base.setindex!(v::GLib.GV, ::Type{T}) where T <: GdkRGBA
                    gtype = ccall(($(QuoteNode("gdk_rgba_get_type")), "libgtk-4.so.1"), GType, ())
                    ccall((:g_value_init, libgobject), Nothing, (Ptr{GValue}, Csize_t), v, gtype)
                    v
                end
            end
        end
        begin
            function Base.getproperty(s::GdkRGBA, sym::Symbol)
                if sym === :handle
                    return getfield(s, :handle)
                elseif sym in fieldnames(_GdkRGBA)
                    u = unsafe_load(Ptr{_GdkRGBA}(s.handle))
                    return getfield(u, sym)
                end
            end
        end
    end
    begin
        begin
            struct _GdkRectangle
                x::Int32
                y::Int32
                width::Int32
                height::Int32
            end
        end
        mutable struct GdkRectangle <: GBoxed
            handle::Ptr{GdkRectangle}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkRectangle) = begin
                        ccall(("gdk_rectangle_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GdkRectangle(ref::Ptr{GdkRectangle}, own::Bool = false)
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                function Base.setindex!(v::GLib.GV, ::Type{T}) where T <: GdkRectangle
                    gtype = ccall(($(QuoteNode("gdk_rectangle_get_type")), "libgtk-4.so.1"), GType, ())
                    ccall((:g_value_init, libgobject), Nothing, (Ptr{GValue}, Csize_t), v, gtype)
                    v
                end
            end
        end
        begin
            function Base.getproperty(s::GdkRectangle, sym::Symbol)
                if sym === :handle
                    return getfield(s, :handle)
                elseif sym in fieldnames(_GdkRectangle)
                    u = unsafe_load(Ptr{_GdkRectangle}(s.handle))
                    return getfield(u, sym)
                end
            end
        end
    end
    begin
        nothing
        mutable struct GdkTimeCoord
            handle::Ptr{GdkTimeCoord}
        end
        nothing
    end
    begin
        nothing
        mutable struct GdkToplevelLayout <: GBoxed
            handle::Ptr{GdkToplevelLayout}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkToplevelLayout) = begin
                        ccall(("gdk_toplevel_layout_get_type", "libgtk-4.so.1"), GType, ())
                    end
                function GdkToplevelLayout(ref::Ptr{GdkToplevelLayout}, own::Bool = false)
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                function Base.setindex!(v::GLib.GV, ::Type{T}) where T <: GdkToplevelLayout
                    gtype = ccall(($(QuoteNode("gdk_toplevel_layout_get_type")), "libgtk-4.so.1"), GType, ())
                    ccall((:g_value_init, libgobject), Nothing, (Ptr{GValue}, Csize_t), v, gtype)
                    v
                end
            end
        end
        nothing
    end
    begin
        gtype_wrapper_cache = Dict{Symbol, Type}()
    end
    begin
        abstract type GdkAppLaunchContext <: GAppLaunchContext end
    end
    begin
        mutable struct GdkAppLaunchContextLeaf <: GdkAppLaunchContext
            handle::Ptr{GObject}
            function GdkAppLaunchContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkAppLaunchContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkAppLaunchContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkAppLaunchContextLeaf, args))
            end
            w = GdkAppLaunchContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkAppLaunchContext] = GdkAppLaunchContextLeaf
        function GdkAppLaunchContext(args...; kwargs...)
            GdkAppLaunchContextLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkAppLaunchContextLeaf) = begin
                [:handle, :display]
            end
        function Base.getproperty(o::GdkAppLaunchContextLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:display => (:GdkDisplay, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkAppLaunchContextLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:display => (:GdkDisplay, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkDrawContext <: GObject end
    end
    begin
        mutable struct GdkDrawContextLeaf <: GdkDrawContext
            handle::Ptr{GObject}
            function GdkDrawContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkDrawContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkDrawContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDrawContextLeaf, args))
            end
            w = GdkDrawContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDrawContext] = GdkDrawContextLeaf
        function GdkDrawContext(args...; kwargs...)
            GdkDrawContextLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkDrawContextLeaf) = begin
                [:handle, :surface, :display]
            end
        function Base.getproperty(o::GdkDrawContextLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:surface => (:GdkSurface, 0, 11), :display => (:GdkDisplay, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkDrawContextLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:surface => (:GdkSurface, 0, 11), :display => (:GdkDisplay, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkCairoContext <: GdkDrawContext end
    end
    begin
        mutable struct GdkCairoContextLeaf <: GdkCairoContext
            handle::Ptr{GObject}
            function GdkCairoContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkCairoContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkCairoContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkCairoContextLeaf, args))
            end
            w = GdkCairoContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkCairoContext] = GdkCairoContextLeaf
        function GdkCairoContext(args...; kwargs...)
            GdkCairoContextLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkCairoContextLeaf) = begin
                [:handle]
            end
        function Base.getproperty(o::GdkCairoContextLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkCairoContextLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkClipboard <: GObject end
    end
    begin
        mutable struct GdkClipboardLeaf <: GdkClipboard
            handle::Ptr{GObject}
            function GdkClipboardLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkClipboardLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkClipboardLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkClipboardLeaf, args))
            end
            w = GdkClipboardLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkClipboard] = GdkClipboardLeaf
        function GdkClipboard(args...; kwargs...)
            GdkClipboardLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkClipboardLeaf) = begin
                [:handle, :content, :local, :display, :formats]
            end
        function Base.getproperty(o::GdkClipboardLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:content => (:GdkContentProvider, 0, 1), :local => (:Bool, 0, 1), :display => (:GdkDisplay, 0, 11), :formats => (:GdkContentFormats, 0, 1))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkClipboardLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:display => (:GdkDisplay, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkContentDeserializer <: GObject end
    end
    begin
        mutable struct GdkContentDeserializerLeaf <: GdkContentDeserializer
            handle::Ptr{GObject}
            function GdkContentDeserializerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkContentDeserializerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkContentDeserializerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkContentDeserializerLeaf, args))
            end
            w = GdkContentDeserializerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkContentDeserializer] = GdkContentDeserializerLeaf
        function GdkContentDeserializer(args...; kwargs...)
            GdkContentDeserializerLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkContentDeserializerLeaf) = begin
                [:handle]
            end
        function Base.getproperty(o::GdkContentDeserializerLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkContentDeserializerLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkContentProvider <: GObject end
    end
    begin
        mutable struct GdkContentProviderLeaf <: GdkContentProvider
            handle::Ptr{GObject}
            function GdkContentProviderLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkContentProviderLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkContentProviderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkContentProviderLeaf, args))
            end
            w = GdkContentProviderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkContentProvider] = GdkContentProviderLeaf
        function GdkContentProvider(args...; kwargs...)
            GdkContentProviderLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkContentProviderLeaf) = begin
                [:handle, :formats, :storable_formats]
            end
        function Base.getproperty(o::GdkContentProviderLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:formats => (:GdkContentFormats, 0, 1), :storable_formats => (:GdkContentFormats, 0, 1))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkContentProviderLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkContentSerializer <: GObject end
    end
    begin
        mutable struct GdkContentSerializerLeaf <: GdkContentSerializer
            handle::Ptr{GObject}
            function GdkContentSerializerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkContentSerializerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkContentSerializerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkContentSerializerLeaf, args))
            end
            w = GdkContentSerializerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkContentSerializer] = GdkContentSerializerLeaf
        function GdkContentSerializer(args...; kwargs...)
            GdkContentSerializerLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkContentSerializerLeaf) = begin
                [:handle]
            end
        function Base.getproperty(o::GdkContentSerializerLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkContentSerializerLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkCursor <: GObject end
    end
    begin
        mutable struct GdkCursorLeaf <: GdkCursor
            handle::Ptr{GObject}
            function GdkCursorLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkCursorLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkCursorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkCursorLeaf, args))
            end
            w = GdkCursorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkCursor] = GdkCursorLeaf
        function GdkCursor(args...; kwargs...)
            GdkCursorLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkCursorLeaf) = begin
                [:handle, :texture, :name, :hotspot_x, :hotspot_y, :fallback]
            end
        function Base.getproperty(o::GdkCursorLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:texture => (:GdkTexture, 0, 11), :name => (:String, 0, 11), :hotspot_x => (:Int32, 0, 11), :hotspot_y => (:Int32, 0, 11), :fallback => (:GdkCursor, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkCursorLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:texture => (:GdkTexture, 0, 11), :name => (:String, 0, 11), :hotspot_x => (:Int32, 0, 11), :hotspot_y => (:Int32, 0, 11), :fallback => (:GdkCursor, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkDevice <: GObject end
    end
    begin
        mutable struct GdkDeviceLeaf <: GdkDevice
            handle::Ptr{GObject}
            function GdkDeviceLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkDeviceLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkDeviceLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDeviceLeaf, args))
            end
            w = GdkDeviceLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDevice] = GdkDeviceLeaf
        function GdkDevice(args...; kwargs...)
            GdkDeviceLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkDeviceLeaf) = begin
                [:handle, :vendor_id, :tool, :caps_lock_state, :scroll_lock_state, :has_bidi_layouts, :has_cursor, :n_axes, :name, :modifier_state, :display, :num_lock_state, :seat, :num_touches, :direction, :product_id, :source]
            end
        function Base.getproperty(o::GdkDeviceLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:source => (:Int32, 0, 11), :tool => (:GdkDeviceTool, 0, 1), :caps_lock_state => (:Bool, 0, 1), :scroll_lock_state => (:Bool, 0, 1), :has_bidi_layouts => (:Bool, 0, 1), :has_cursor => (:Bool, 0, 11), :n_axes => (:UInt32, 0, 1), :name => (:String, 0, 11), :modifier_state => (:Int32, 0, 1), :display => (:GdkDisplay, 0, 11), :num_lock_state => (:Bool, 0, 1), :seat => (:GdkSeat, 0, 3), :num_touches => (:UInt32, 0, 11), :direction => (:Int32, 0, 1), :product_id => (:String, 0, 11), :vendor_id => (:String, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkDeviceLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:seat => (:GdkSeat, 0, 3), :source => (:Int32, 0, 11), :name => (:String, 0, 11), :num_touches => (:UInt32, 0, 11), :has_cursor => (:Bool, 0, 11), :display => (:GdkDisplay, 0, 11), :product_id => (:String, 0, 11), :vendor_id => (:String, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkDeviceTool <: GObject end
    end
    begin
        mutable struct GdkDeviceToolLeaf <: GdkDeviceTool
            handle::Ptr{GObject}
            function GdkDeviceToolLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkDeviceToolLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkDeviceToolLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDeviceToolLeaf, args))
            end
            w = GdkDeviceToolLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDeviceTool] = GdkDeviceToolLeaf
        function GdkDeviceTool(args...; kwargs...)
            GdkDeviceToolLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkDeviceToolLeaf) = begin
                [:handle, :serial, :hardware_id, :axes, :tool_type]
            end
        function Base.getproperty(o::GdkDeviceToolLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:serial => (:UInt64, 0, 11), :hardware_id => (:UInt64, 0, 11), :axes => (:Int32, 0, 11), :tool_type => (:Int32, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkDeviceToolLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:serial => (:UInt64, 0, 11), :hardware_id => (:UInt64, 0, 11), :axes => (:Int32, 0, 11), :tool_type => (:Int32, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkDisplay <: GObject end
    end
    begin
        mutable struct GdkDisplayLeaf <: GdkDisplay
            handle::Ptr{GObject}
            function GdkDisplayLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkDisplayLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkDisplayLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDisplayLeaf, args))
            end
            w = GdkDisplayLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDisplay] = GdkDisplayLeaf
        function GdkDisplay(args...; kwargs...)
            GdkDisplayLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkDisplayLeaf) = begin
                [:handle, :input_shapes, :composited, :rgba]
            end
        function Base.getproperty(o::GdkDisplayLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:input_shapes => (:Bool, 0, 1), :composited => (:Bool, 0, 1), :rgba => (:Bool, 0, 1))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkDisplayLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkDisplayManager <: GObject end
    end
    begin
        mutable struct GdkDisplayManagerLeaf <: GdkDisplayManager
            handle::Ptr{GObject}
            function GdkDisplayManagerLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkDisplayManagerLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkDisplayManagerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDisplayManagerLeaf, args))
            end
            w = GdkDisplayManagerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDisplayManager] = GdkDisplayManagerLeaf
        function GdkDisplayManager(args...; kwargs...)
            GdkDisplayManagerLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkDisplayManagerLeaf) = begin
                [:handle, :default_display]
            end
        function Base.getproperty(o::GdkDisplayManagerLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:default_display => (:GdkDisplay, 0, 3))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkDisplayManagerLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:default_display => (:GdkDisplay, 0, 3))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkDrag <: GObject end
    end
    begin
        mutable struct GdkDragLeaf <: GdkDrag
            handle::Ptr{GObject}
            function GdkDragLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkDragLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkDragLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDragLeaf, args))
            end
            w = GdkDragLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDrag] = GdkDragLeaf
        function GdkDrag(args...; kwargs...)
            GdkDragLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkDragLeaf) = begin
                [:handle, :surface, :actions, :device, :selected_action, :content, :display, :formats]
            end
        function Base.getproperty(o::GdkDragLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:surface => (:GdkSurface, 0, 11), :actions => (:Int32, 0, 3), :device => (:GdkDevice, 0, 11), :selected_action => (:Int32, 0, 3), :content => (:GdkContentProvider, 0, 11), :display => (:GdkDisplay, 0, 1), :formats => (:GdkContentFormats, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkDragLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:surface => (:GdkSurface, 0, 11), :actions => (:Int32, 0, 3), :device => (:GdkDevice, 0, 11), :selected_action => (:Int32, 0, 3), :content => (:GdkContentProvider, 0, 11), :formats => (:GdkContentFormats, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkDrop <: GObject end
    end
    begin
        mutable struct GdkDropLeaf <: GdkDrop
            handle::Ptr{GObject}
            function GdkDropLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkDropLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkDropLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDropLeaf, args))
            end
            w = GdkDropLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDrop] = GdkDropLeaf
        function GdkDrop(args...; kwargs...)
            GdkDropLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkDropLeaf) = begin
                [:handle, :drag, :actions, :surface, :device, :display, :formats]
            end
        function Base.getproperty(o::GdkDropLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:drag => (:GdkDrag, 0, 11), :actions => (:Int32, 0, 11), :surface => (:GdkSurface, 0, 11), :device => (:GdkDevice, 0, 11), :display => (:GdkDisplay, 0, 1), :formats => (:GdkContentFormats, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkDropLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:drag => (:GdkDrag, 0, 11), :actions => (:Int32, 0, 11), :surface => (:GdkSurface, 0, 11), :device => (:GdkDevice, 0, 11), :formats => (:GdkContentFormats, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkFrameClock <: GObject end
    end
    begin
        mutable struct GdkFrameClockLeaf <: GdkFrameClock
            handle::Ptr{GObject}
            function GdkFrameClockLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkFrameClockLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkFrameClockLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkFrameClockLeaf, args))
            end
            w = GdkFrameClockLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkFrameClock] = GdkFrameClockLeaf
        function GdkFrameClock(args...; kwargs...)
            GdkFrameClockLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkFrameClockLeaf) = begin
                [:handle]
            end
        function Base.getproperty(o::GdkFrameClockLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkFrameClockLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkGLContext <: GdkDrawContext end
    end
    begin
        mutable struct GdkGLContextLeaf <: GdkGLContext
            handle::Ptr{GObject}
            function GdkGLContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkGLContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkGLContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkGLContextLeaf, args))
            end
            w = GdkGLContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkGLContext] = GdkGLContextLeaf
        function GdkGLContext(args...; kwargs...)
            GdkGLContextLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkGLContextLeaf) = begin
                [:handle, :shared_context]
            end
        function Base.getproperty(o::GdkGLContextLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:shared_context => (:GdkGLContext, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkGLContextLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:shared_context => (:GdkGLContext, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkTexture <: GObject end
    end
    begin
        mutable struct GdkTextureLeaf <: GdkTexture
            handle::Ptr{GObject}
            function GdkTextureLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkTextureLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkTextureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkTextureLeaf, args))
            end
            w = GdkTextureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkTexture] = GdkTextureLeaf
        function GdkTexture(args...; kwargs...)
            GdkTextureLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkTextureLeaf) = begin
                [:handle, :height, :width]
            end
        function Base.getproperty(o::GdkTextureLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:height => (:Int32, 0, 11), :width => (:Int32, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkTextureLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:height => (:Int32, 0, 11), :width => (:Int32, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkGLTexture <: GdkTexture end
    end
    begin
        mutable struct GdkGLTextureLeaf <: GdkGLTexture
            handle::Ptr{GObject}
            function GdkGLTextureLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkGLTextureLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkGLTextureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkGLTextureLeaf, args))
            end
            w = GdkGLTextureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkGLTexture] = GdkGLTextureLeaf
        function GdkGLTexture(args...; kwargs...)
            GdkGLTextureLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkGLTextureLeaf) = begin
                [:handle]
            end
        function Base.getproperty(o::GdkGLTextureLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkGLTextureLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkMemoryTexture <: GdkTexture end
    end
    begin
        mutable struct GdkMemoryTextureLeaf <: GdkMemoryTexture
            handle::Ptr{GObject}
            function GdkMemoryTextureLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkMemoryTextureLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkMemoryTextureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkMemoryTextureLeaf, args))
            end
            w = GdkMemoryTextureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkMemoryTexture] = GdkMemoryTextureLeaf
        function GdkMemoryTexture(args...; kwargs...)
            GdkMemoryTextureLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkMemoryTextureLeaf) = begin
                [:handle]
            end
        function Base.getproperty(o::GdkMemoryTextureLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkMemoryTextureLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkMonitor <: GObject end
    end
    begin
        mutable struct GdkMonitorLeaf <: GdkMonitor
            handle::Ptr{GObject}
            function GdkMonitorLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkMonitorLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkMonitorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkMonitorLeaf, args))
            end
            w = GdkMonitorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkMonitor] = GdkMonitorLeaf
        function GdkMonitor(args...; kwargs...)
            GdkMonitorLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkMonitorLeaf) = begin
                [:handle, :geometry, :height_mm, :subpixel_layout, :refresh_rate, :width_mm, :valid, :display, :model, :manufacturer, :connector, :scale_factor]
            end
        function Base.getproperty(o::GdkMonitorLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:geometry => (:GdkRectangle, 0, 1), :height_mm => (:Int32, 0, 1), :subpixel_layout => (:Int32, 0, 1), :refresh_rate => (:Int32, 0, 1), :width_mm => (:Int32, 0, 1), :valid => (:Bool, 0, 1), :display => (:GdkDisplay, 0, 11), :model => (:String, 0, 1), :manufacturer => (:String, 0, 1), :connector => (:String, 0, 1), :scale_factor => (:Int32, 0, 1))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkMonitorLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:display => (:GdkDisplay, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkSeat <: GObject end
    end
    begin
        mutable struct GdkSeatLeaf <: GdkSeat
            handle::Ptr{GObject}
            function GdkSeatLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkSeatLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkSeatLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkSeatLeaf, args))
            end
            w = GdkSeatLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkSeat] = GdkSeatLeaf
        function GdkSeat(args...; kwargs...)
            GdkSeatLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkSeatLeaf) = begin
                [:handle, :display]
            end
        function Base.getproperty(o::GdkSeatLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:display => (:GdkDisplay, 0, 11))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkSeatLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:display => (:GdkDisplay, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkSnapshot <: GObject end
    end
    begin
        mutable struct GdkSnapshotLeaf <: GdkSnapshot
            handle::Ptr{GObject}
            function GdkSnapshotLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkSnapshotLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkSnapshotLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkSnapshotLeaf, args))
            end
            w = GdkSnapshotLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkSnapshot] = GdkSnapshotLeaf
        function GdkSnapshot(args...; kwargs...)
            GdkSnapshotLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkSnapshotLeaf) = begin
                [:handle]
            end
        function Base.getproperty(o::GdkSnapshotLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkSnapshotLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkSurface <: GObject end
    end
    begin
        mutable struct GdkSurfaceLeaf <: GdkSurface
            handle::Ptr{GObject}
            function GdkSurfaceLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkSurfaceLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkSurfaceLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkSurfaceLeaf, args))
            end
            w = GdkSurfaceLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkSurface] = GdkSurfaceLeaf
        function GdkSurface(args...; kwargs...)
            GdkSurfaceLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkSurfaceLeaf) = begin
                [:handle, :width, :cursor, :height, :frame_clock, :display, :scale_factor, :mapped]
            end
        function Base.getproperty(o::GdkSurfaceLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:mapped => (:Bool, 0, 1), :cursor => (:GdkCursor, 0, 3), :height => (:Int32, 0, 1), :frame_clock => (:GdkFrameClock, 0, 11), :display => (:GdkDisplay, 0, 11), :scale_factor => (:Int32, 0, 1), :width => (:Int32, 0, 1))
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkSurfaceLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:cursor => (:GdkCursor, 0, 3), :frame_clock => (:GdkFrameClock, 0, 11), :display => (:GdkDisplay, 0, 11))
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        abstract type GdkVulkanContext <: GdkDrawContext end
    end
    begin
        mutable struct GdkVulkanContextLeaf <: GdkVulkanContext
            handle::Ptr{GObject}
            function GdkVulkanContextLeaf(handle::Ptr{GObject})
                if handle == C_NULL
                    error("Cannot construct GdkVulkanContextLeaf with a NULL pointer")
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs, T
        function GdkVulkanContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkVulkanContextLeaf, args))
            end
            w = GdkVulkanContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkVulkanContext] = GdkVulkanContextLeaf
        function GdkVulkanContext(args...; kwargs...)
            GdkVulkanContextLeaf(args...; kwargs...)
        end
        Base.propertynames(o::GdkVulkanContextLeaf) = begin
                [:handle]
            end
        function Base.getproperty(o::GdkVulkanContextLeaf, name::Symbol)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                return get_gtk_property(o, name, eval((d[name])[1]))
            else
                return getfield(o, name)
            end
        end
        function Base.setproperty!(o::GdkVulkanContextLeaf, name::Symbol, x)
            d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
            if name in keys(d)
                set_gtk_property!(o, name, x)
            else
                setfield!(o, name, x)
            end
        end
    end
    begin
        gtype_wrapper_cache_init() = begin
                merge!(GLib.gtype_wrappers, gtype_wrapper_cache)
            end
    end
    begin
        struct GdkDevicePad <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkDevicePad(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GdkDragSurface <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkDragSurface(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GdkPaintable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkPaintable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GdkPopup <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkPopup(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GdkToplevel <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkToplevel(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    export GdkContentFormats, GdkContentFormatsBuilder, GdkEventSequence, GdkFrameTimings, GdkKeymapKey, GdkPopupLayout, GdkRGBA, GdkRectangle, GdkTimeCoord, GdkToplevelLayout, GdkAppLaunchContext, GdkCairoContext, GdkClipboard, GdkContentDeserializer, GdkContentProvider, GdkContentSerializer, GdkCursor, GdkDevice, GdkDeviceTool, GdkDisplay, GdkDisplayManager, GdkDrag, GdkDrawContext, GdkDrop, GdkFrameClock, GdkGLContext, GdkGLTexture, GdkMemoryTexture, GdkMonitor, GdkSeat, GdkSnapshot, GdkSurface, GdkTexture, GdkVulkanContext, GdkDevicePad, GdkDragSurface, GdkPaintable, GdkPopup, GdkToplevel
end))
end
