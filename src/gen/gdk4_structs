quote
$(Expr(:toplevel, quote
    begin
        gboxed_types = Any[]
    end
    mutable struct GdkContentFormats <: GBoxed
        handle::Ptr{GdkContentFormats}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkContentFormats) = begin
                    ccall(("gdk_content_formats_get_type", libgtk4), GType, ())
                end
            function GdkContentFormats(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkContentFormats)
        end
    end
    mutable struct GdkContentFormatsBuilder <: GBoxed
        handle::Ptr{GdkContentFormatsBuilder}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkContentFormatsBuilder) = begin
                    ccall(("gdk_content_formats_builder_get_type", libgtk4), GType, ())
                end
            function GdkContentFormatsBuilder(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkContentFormatsBuilder)
        end
    end
    mutable struct GdkEventSequence <: GBoxed
        handle::Ptr{GdkEventSequence}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkEventSequence) = begin
                    ccall(("gdk_event_sequence_get_type", libgtk4), GType, ())
                end
            function GdkEventSequence(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkEventSequence)
        end
    end
    mutable struct GdkFrameTimings <: GBoxed
        handle::Ptr{GdkFrameTimings}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkFrameTimings) = begin
                    ccall(("gdk_frame_timings_get_type", libgtk4), GType, ())
                end
            function GdkFrameTimings(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkFrameTimings)
        end
    end
    begin
        struct _GdkKeymapKey
            keycode::UInt32
            group::Int32
            level::Int32
        end
        begin
            mutable struct GdkKeymapKey
                handle::Ptr{_GdkKeymapKey}
            end
        end
    end
    mutable struct GdkPopupLayout <: GBoxed
        handle::Ptr{GdkPopupLayout}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkPopupLayout) = begin
                    ccall(("gdk_popup_layout_get_type", libgtk4), GType, ())
                end
            function GdkPopupLayout(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkPopupLayout)
        end
    end
    begin
        struct _GdkRGBA
            red::Float32
            green::Float32
            blue::Float32
            alpha::Float32
        end
        begin
            mutable struct GdkRGBA <: GBoxed
                handle::Ptr{_GdkRGBA}
                begin
                    (GLib.g_type(::Type{T}) where T <: GdkRGBA) = begin
                            ccall(("gdk_rgba_get_type", libgtk4), GType, ())
                        end
                    function GdkRGBA(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                        x = new(ref)
                        if own
                            finalizer(x) do x
                                GLib.delboxed(x)
                            end
                        end
                        x
                    end
                    push!(gboxed_types, GdkRGBA)
                end
            end
        end
    end
    begin
        struct _GdkRectangle
            x::Int32
            y::Int32
            width::Int32
            height::Int32
        end
        begin
            mutable struct GdkRectangle <: GBoxed
                handle::Ptr{_GdkRectangle}
                begin
                    (GLib.g_type(::Type{T}) where T <: GdkRectangle) = begin
                            ccall(("gdk_rectangle_get_type", libgtk4), GType, ())
                        end
                    function GdkRectangle(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                        x = new(ref)
                        if own
                            finalizer(x) do x
                                GLib.delboxed(x)
                            end
                        end
                        x
                    end
                    push!(gboxed_types, GdkRectangle)
                end
            end
        end
    end
    begin
        begin
            mutable struct GdkTimeCoord
                handle::Ptr{GdkTimeCoord}
            end
        end
        const _GdkTimeCoord = GdkTimeCoord
    end
    mutable struct GdkToplevelLayout <: GBoxed
        handle::Ptr{GdkToplevelLayout}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkToplevelLayout) = begin
                    ccall(("gdk_toplevel_layout_get_type", libgtk4), GType, ())
                end
            function GdkToplevelLayout(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkToplevelLayout)
        end
    end
    begin
        gboxed_cache_init() = begin
                append!(GLib.gboxed_types, gboxed_types)
            end
    end
    begin
        gtype_wrapper_cache = Dict{Symbol, Type}()
    end
    begin
        abstract type GdkAppLaunchContext <: GAppLaunchContext end
    end
    begin
        mutable struct GdkAppLaunchContextLeaf <: GdkAppLaunchContext
            handle::Ptr{GObject}
            function GdkAppLaunchContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkAppLaunchContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkAppLaunchContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkAppLaunchContextLeaf, args))
            end
            w = GdkAppLaunchContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkAppLaunchContext] = GdkAppLaunchContextLeaf
        function GdkAppLaunchContext(args...; kwargs...)
            GdkAppLaunchContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkDrawContext <: GObject end
    end
    begin
        mutable struct GdkDrawContextLeaf <: GdkDrawContext
            handle::Ptr{GObject}
            function GdkDrawContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDrawContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkDrawContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDrawContextLeaf, args))
            end
            w = GdkDrawContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDrawContext] = GdkDrawContextLeaf
        function GdkDrawContext(args...; kwargs...)
            GdkDrawContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkCairoContext <: GdkDrawContext end
    end
    begin
        mutable struct GdkCairoContextLeaf <: GdkCairoContext
            handle::Ptr{GObject}
            function GdkCairoContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkCairoContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkCairoContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkCairoContextLeaf, args))
            end
            w = GdkCairoContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkCairoContext] = GdkCairoContextLeaf
        function GdkCairoContext(args...; kwargs...)
            GdkCairoContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkClipboard <: GObject end
    end
    begin
        mutable struct GdkClipboardLeaf <: GdkClipboard
            handle::Ptr{GObject}
            function GdkClipboardLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkClipboardLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkClipboardLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkClipboardLeaf, args))
            end
            w = GdkClipboardLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkClipboard] = GdkClipboardLeaf
        function GdkClipboard(args...; kwargs...)
            GdkClipboardLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkContentDeserializer <: GObject end
    end
    begin
        mutable struct GdkContentDeserializerLeaf <: GdkContentDeserializer
            handle::Ptr{GObject}
            function GdkContentDeserializerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkContentDeserializerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkContentDeserializerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkContentDeserializerLeaf, args))
            end
            w = GdkContentDeserializerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkContentDeserializer] = GdkContentDeserializerLeaf
        function GdkContentDeserializer(args...; kwargs...)
            GdkContentDeserializerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkContentProvider <: GObject end
    end
    begin
        mutable struct GdkContentProviderLeaf <: GdkContentProvider
            handle::Ptr{GObject}
            function GdkContentProviderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkContentProviderLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkContentProviderLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkContentProviderLeaf, args))
            end
            w = GdkContentProviderLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkContentProvider] = GdkContentProviderLeaf
        function GdkContentProvider(args...; kwargs...)
            GdkContentProviderLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkContentSerializer <: GObject end
    end
    begin
        mutable struct GdkContentSerializerLeaf <: GdkContentSerializer
            handle::Ptr{GObject}
            function GdkContentSerializerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkContentSerializerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkContentSerializerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkContentSerializerLeaf, args))
            end
            w = GdkContentSerializerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkContentSerializer] = GdkContentSerializerLeaf
        function GdkContentSerializer(args...; kwargs...)
            GdkContentSerializerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkCursor <: GObject end
    end
    begin
        mutable struct GdkCursorLeaf <: GdkCursor
            handle::Ptr{GObject}
            function GdkCursorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkCursorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkCursorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkCursorLeaf, args))
            end
            w = GdkCursorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkCursor] = GdkCursorLeaf
        function GdkCursor(args...; kwargs...)
            GdkCursorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkDevice <: GObject end
    end
    begin
        mutable struct GdkDeviceLeaf <: GdkDevice
            handle::Ptr{GObject}
            function GdkDeviceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDeviceLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkDeviceLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDeviceLeaf, args))
            end
            w = GdkDeviceLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDevice] = GdkDeviceLeaf
        function GdkDevice(args...; kwargs...)
            GdkDeviceLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkDeviceTool <: GObject end
    end
    begin
        mutable struct GdkDeviceToolLeaf <: GdkDeviceTool
            handle::Ptr{GObject}
            function GdkDeviceToolLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDeviceToolLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkDeviceToolLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDeviceToolLeaf, args))
            end
            w = GdkDeviceToolLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDeviceTool] = GdkDeviceToolLeaf
        function GdkDeviceTool(args...; kwargs...)
            GdkDeviceToolLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkDisplay <: GObject end
    end
    begin
        mutable struct GdkDisplayLeaf <: GdkDisplay
            handle::Ptr{GObject}
            function GdkDisplayLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDisplayLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkDisplayLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDisplayLeaf, args))
            end
            w = GdkDisplayLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDisplay] = GdkDisplayLeaf
        function GdkDisplay(args...; kwargs...)
            GdkDisplayLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkDisplayManager <: GObject end
    end
    begin
        mutable struct GdkDisplayManagerLeaf <: GdkDisplayManager
            handle::Ptr{GObject}
            function GdkDisplayManagerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDisplayManagerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkDisplayManagerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDisplayManagerLeaf, args))
            end
            w = GdkDisplayManagerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDisplayManager] = GdkDisplayManagerLeaf
        function GdkDisplayManager(args...; kwargs...)
            GdkDisplayManagerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkDrag <: GObject end
    end
    begin
        mutable struct GdkDragLeaf <: GdkDrag
            handle::Ptr{GObject}
            function GdkDragLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDragLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkDragLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDragLeaf, args))
            end
            w = GdkDragLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDrag] = GdkDragLeaf
        function GdkDrag(args...; kwargs...)
            GdkDragLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkDrop <: GObject end
    end
    begin
        mutable struct GdkDropLeaf <: GdkDrop
            handle::Ptr{GObject}
            function GdkDropLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDropLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkDropLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkDropLeaf, args))
            end
            w = GdkDropLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkDrop] = GdkDropLeaf
        function GdkDrop(args...; kwargs...)
            GdkDropLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkFrameClock <: GObject end
    end
    begin
        mutable struct GdkFrameClockLeaf <: GdkFrameClock
            handle::Ptr{GObject}
            function GdkFrameClockLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkFrameClockLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkFrameClockLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkFrameClockLeaf, args))
            end
            w = GdkFrameClockLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkFrameClock] = GdkFrameClockLeaf
        function GdkFrameClock(args...; kwargs...)
            GdkFrameClockLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkGLContext <: GdkDrawContext end
    end
    begin
        mutable struct GdkGLContextLeaf <: GdkGLContext
            handle::Ptr{GObject}
            function GdkGLContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkGLContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkGLContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkGLContextLeaf, args))
            end
            w = GdkGLContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkGLContext] = GdkGLContextLeaf
        function GdkGLContext(args...; kwargs...)
            GdkGLContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkTexture <: GObject end
    end
    begin
        mutable struct GdkTextureLeaf <: GdkTexture
            handle::Ptr{GObject}
            function GdkTextureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkTextureLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkTextureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkTextureLeaf, args))
            end
            w = GdkTextureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkTexture] = GdkTextureLeaf
        function GdkTexture(args...; kwargs...)
            GdkTextureLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkGLTexture <: GdkTexture end
    end
    begin
        mutable struct GdkGLTextureLeaf <: GdkGLTexture
            handle::Ptr{GObject}
            function GdkGLTextureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkGLTextureLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkGLTextureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkGLTextureLeaf, args))
            end
            w = GdkGLTextureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkGLTexture] = GdkGLTextureLeaf
        function GdkGLTexture(args...; kwargs...)
            GdkGLTextureLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkMemoryTexture <: GdkTexture end
    end
    begin
        mutable struct GdkMemoryTextureLeaf <: GdkMemoryTexture
            handle::Ptr{GObject}
            function GdkMemoryTextureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkMemoryTextureLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkMemoryTextureLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkMemoryTextureLeaf, args))
            end
            w = GdkMemoryTextureLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkMemoryTexture] = GdkMemoryTextureLeaf
        function GdkMemoryTexture(args...; kwargs...)
            GdkMemoryTextureLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkMonitor <: GObject end
    end
    begin
        mutable struct GdkMonitorLeaf <: GdkMonitor
            handle::Ptr{GObject}
            function GdkMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkMonitorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkMonitorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkMonitorLeaf, args))
            end
            w = GdkMonitorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkMonitor] = GdkMonitorLeaf
        function GdkMonitor(args...; kwargs...)
            GdkMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkSeat <: GObject end
    end
    begin
        mutable struct GdkSeatLeaf <: GdkSeat
            handle::Ptr{GObject}
            function GdkSeatLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkSeatLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkSeatLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkSeatLeaf, args))
            end
            w = GdkSeatLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkSeat] = GdkSeatLeaf
        function GdkSeat(args...; kwargs...)
            GdkSeatLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkSnapshot <: GObject end
    end
    begin
        mutable struct GdkSnapshotLeaf <: GdkSnapshot
            handle::Ptr{GObject}
            function GdkSnapshotLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkSnapshotLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkSnapshotLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkSnapshotLeaf, args))
            end
            w = GdkSnapshotLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkSnapshot] = GdkSnapshotLeaf
        function GdkSnapshot(args...; kwargs...)
            GdkSnapshotLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkSurface <: GObject end
    end
    begin
        mutable struct GdkSurfaceLeaf <: GdkSurface
            handle::Ptr{GObject}
            function GdkSurfaceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkSurfaceLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkSurfaceLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkSurfaceLeaf, args))
            end
            w = GdkSurfaceLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkSurface] = GdkSurfaceLeaf
        function GdkSurface(args...; kwargs...)
            GdkSurfaceLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GdkVulkanContext <: GdkDrawContext end
    end
    begin
        mutable struct GdkVulkanContextLeaf <: GdkVulkanContext
            handle::Ptr{GObject}
            function GdkVulkanContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkVulkanContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    GLib.gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GdkVulkanContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GdkVulkanContextLeaf, args))
            end
            w = GdkVulkanContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GdkVulkanContext] = GdkVulkanContextLeaf
        function GdkVulkanContext(args...; kwargs...)
            GdkVulkanContextLeaf(args...; kwargs...)
        end
    end
    begin
        gtype_wrapper_cache_init() = begin
                merge!(GLib.gtype_wrappers, gtype_wrapper_cache)
            end
    end
    begin
        struct GdkDevicePad <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkDevicePad(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GdkDragSurface <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkDragSurface(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GdkPaintable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkPaintable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GdkPopup <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkPopup(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GdkToplevel <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GdkToplevel(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    export GdkContentFormats, GdkContentFormatsBuilder, GdkEventSequence, GdkFrameTimings, GdkKeymapKey, _GdkKeymapKey, GdkPopupLayout, GdkRGBA, _GdkRGBA, GdkRectangle, _GdkRectangle, GdkTimeCoord, _GdkTimeCoord, GdkToplevelLayout, GdkAppLaunchContext, GdkCairoContext, GdkClipboard, GdkContentDeserializer, GdkContentProvider, GdkContentSerializer, GdkCursor, GdkDevice, GdkDeviceTool, GdkDisplay, GdkDisplayManager, GdkDrag, GdkDrawContext, GdkDrop, GdkFrameClock, GdkGLContext, GdkGLTexture, GdkMemoryTexture, GdkMonitor, GdkSeat, GdkSnapshot, GdkSurface, GdkTexture, GdkVulkanContext, GdkDevicePad, GdkDragSurface, GdkPaintable, GdkPopup, GdkToplevel
end))
end
