quote
$(Expr(:toplevel, quote
    const gboxed_types = Any[]
    mutable struct GdkContentFormats <: GBoxed
        handle::Ptr{GdkContentFormats}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkContentFormats) = begin
                    ccall(("gdk_content_formats_get_type", libgtk4), GType, ())
                end
            function GdkContentFormats(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkContentFormats)
        end
    end
    mutable struct GdkContentFormatsBuilder <: GBoxed
        handle::Ptr{GdkContentFormatsBuilder}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkContentFormatsBuilder) = begin
                    ccall(("gdk_content_formats_builder_get_type", libgtk4), GType, ())
                end
            function GdkContentFormatsBuilder(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkContentFormatsBuilder)
        end
    end
    mutable struct GdkDragSurfaceSize
        handle::Ptr{GdkDragSurfaceSize}
    end
    mutable struct GdkEventSequence <: GBoxed
        handle::Ptr{GdkEventSequence}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkEventSequence) = begin
                    ccall(("gdk_event_sequence_get_type", libgtk4), GType, ())
                end
            function GdkEventSequence(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkEventSequence)
        end
    end
    mutable struct GdkFileList <: GBoxed
        handle::Ptr{GdkFileList}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkFileList) = begin
                    ccall(("gdk_file_list_get_type", libgtk4), GType, ())
                end
            function GdkFileList(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkFileList)
        end
    end
    mutable struct GdkFrameTimings <: GBoxed
        handle::Ptr{GdkFrameTimings}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkFrameTimings) = begin
                    ccall(("gdk_frame_timings_get_type", libgtk4), GType, ())
                end
            function GdkFrameTimings(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkFrameTimings)
        end
    end
    begin
        struct _GdkKeymapKey
            keycode::UInt32
            group::Int32
            level::Int32
        end
        mutable struct GdkKeymapKey
            handle::Ptr{_GdkKeymapKey}
        end
        begin
            unsafe_convert(::Type{Ptr{_GdkKeymapKey}}, box::GdkKeymapKey) = begin
                    convert(Ptr{_GdkKeymapKey}, box.handle)
                end
            convert(::Type{GdkKeymapKey}, p::Ptr{_GdkKeymapKey}, owns = false) = begin
                    GdkKeymapKey(p, owns)
                end
        end
    end
    mutable struct GdkPopupLayout <: GBoxed
        handle::Ptr{GdkPopupLayout}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkPopupLayout) = begin
                    ccall(("gdk_popup_layout_get_type", libgtk4), GType, ())
                end
            function GdkPopupLayout(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkPopupLayout)
        end
    end
    begin
        struct _GdkRGBA
            red::Float32
            green::Float32
            blue::Float32
            alpha::Float32
        end
        mutable struct GdkRGBA <: GBoxed
            handle::Ptr{_GdkRGBA}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkRGBA) = begin
                        ccall(("gdk_rgba_get_type", libgtk4), GType, ())
                    end
                function GdkRGBA(ref::Ptr{T}, own::Bool = false) where T <: Union{GBoxed, _GdkRGBA}
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GdkRGBA)
            end
        end
        begin
            unsafe_convert(::Type{Ptr{_GdkRGBA}}, box::GdkRGBA) = begin
                    convert(Ptr{_GdkRGBA}, box.handle)
                end
            convert(::Type{GdkRGBA}, p::Ptr{_GdkRGBA}, owns = false) = begin
                    GdkRGBA(p, owns)
                end
        end
    end
    begin
        struct _GdkRectangle
            x::Int32
            y::Int32
            width::Int32
            height::Int32
        end
        mutable struct GdkRectangle <: GBoxed
            handle::Ptr{_GdkRectangle}
            begin
                (GLib.g_type(::Type{T}) where T <: GdkRectangle) = begin
                        ccall(("gdk_rectangle_get_type", libgtk4), GType, ())
                    end
                function GdkRectangle(ref::Ptr{T}, own::Bool = false) where T <: Union{GBoxed, _GdkRectangle}
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GdkRectangle)
            end
        end
        begin
            unsafe_convert(::Type{Ptr{_GdkRectangle}}, box::GdkRectangle) = begin
                    convert(Ptr{_GdkRectangle}, box.handle)
                end
            convert(::Type{GdkRectangle}, p::Ptr{_GdkRectangle}, owns = false) = begin
                    GdkRectangle(p, owns)
                end
        end
    end
    mutable struct GdkTextureDownloader <: GBoxed
        handle::Ptr{GdkTextureDownloader}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkTextureDownloader) = begin
                    ccall(("gdk_texture_downloader_get_type", libgtk4), GType, ())
                end
            function GdkTextureDownloader(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkTextureDownloader)
        end
    end
    begin
        mutable struct GdkTimeCoord
            handle::Ptr{GdkTimeCoord}
        end
        const _GdkTimeCoord = GdkTimeCoord
    end
    mutable struct GdkToplevelLayout <: GBoxed
        handle::Ptr{GdkToplevelLayout}
        begin
            (GLib.g_type(::Type{T}) where T <: GdkToplevelLayout) = begin
                    ccall(("gdk_toplevel_layout_get_type", libgtk4), GType, ())
                end
            function GdkToplevelLayout(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GdkToplevelLayout)
        end
    end
    gboxed_cache_init() = begin
            append!(GLib.gboxed_types, gboxed_types)
        end
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.ContentFormats.html)." GdkContentFormats
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.ContentFormatsBuilder.html)." GdkContentFormatsBuilder
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.DragSurfaceSize.html)." GdkDragSurfaceSize
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.EventSequence.html)." GdkEventSequence
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.FileList.html)." GdkFileList
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.FrameTimings.html)." GdkFrameTimings
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.KeymapKey.html)." GdkKeymapKey
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.PopupLayout.html)." GdkPopupLayout
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.RGBA.html)." GdkRGBA
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.Rectangle.html)." GdkRectangle
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.TextureDownloader.html)." GdkTextureDownloader
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.TimeCoord.html)." GdkTimeCoord
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/struct.ToplevelLayout.html)." GdkToplevelLayout
    struct GdkDevicePad <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GdkDevicePad(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GdkDragSurface <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GdkDragSurface(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GdkPaintable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GdkPaintable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GdkPopup <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GdkPopup(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GdkToplevel <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GdkToplevel(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    const gtype_wrapper_cache = Dict{Symbol, Type}()
    begin
        abstract type GdkAppLaunchContext <: GAppLaunchContext end
        mutable struct GdkAppLaunchContextLeaf <: GdkAppLaunchContext
            handle::Ptr{GObject}
            function GdkAppLaunchContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkAppLaunchContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkAppLaunchContext] = GdkAppLaunchContextLeaf
        (GLib.g_type(::Type{T}) where T <: GdkAppLaunchContext) = begin
                ccall(("gdk_app_launch_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkAppLaunchContext})
            signalnames(supertype(GdkAppLaunchContext))
        end
    end
    begin
        abstract type GdkEvent <: GTypeInstance end
        Base.convert(::Type{GdkEvent}, ptr::Ptr{GdkEvent}) = begin
                GdkEventLeaf(ptr)
            end
        Base.unsafe_convert(::Type{Ptr{GdkEvent}}, o::GdkEvent) = begin
                o.handle
            end
    end
    begin
        mutable struct GdkEventLeaf <: GdkEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkButtonEvent <: GdkEvent end
    end
    begin
        mutable struct GdkButtonEventLeaf <: GdkButtonEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkDrawContext <: GObject end
        mutable struct GdkDrawContextLeaf <: GdkDrawContext
            handle::Ptr{GObject}
            function GdkDrawContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDrawContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkDrawContext] = GdkDrawContextLeaf
        (GLib.g_type(::Type{T}) where T <: GdkDrawContext) = begin
                ccall(("gdk_draw_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkDrawContext})
            signalnames(supertype(GdkDrawContext))
        end
    end
    begin
        abstract type GdkCairoContext <: GdkDrawContext end
        mutable struct GdkCairoContextLeaf <: GdkCairoContext
            handle::Ptr{GObject}
            function GdkCairoContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkCairoContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkCairoContext] = GdkCairoContextLeaf
        (GLib.g_type(::Type{T}) where T <: GdkCairoContext) = begin
                ccall(("gdk_cairo_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkCairoContext})
            signalnames(supertype(GdkCairoContext))
        end
    end
    begin
        abstract type GdkClipboard <: GObject end
        mutable struct GdkClipboardLeaf <: GdkClipboard
            handle::Ptr{GObject}
            function GdkClipboardLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkClipboardLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkClipboard] = GdkClipboardLeaf
        (GLib.g_type(::Type{T}) where T <: GdkClipboard) = begin
                ccall(("gdk_clipboard_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkClipboard})
            vcat([:changed], signalnames(supertype(GdkClipboard)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :changed => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkClipboard
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkClipboard
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkContentDeserializer <: GObject end
        mutable struct GdkContentDeserializerLeaf <: GdkContentDeserializer
            handle::Ptr{GObject}
            function GdkContentDeserializerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkContentDeserializerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkContentDeserializer] = GdkContentDeserializerLeaf
        (GLib.g_type(::Type{T}) where T <: GdkContentDeserializer) = begin
                ccall(("gdk_content_deserializer_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkContentDeserializer})
            signalnames(supertype(GdkContentDeserializer))
        end
    end
    begin
        abstract type GdkContentProvider <: GObject end
        mutable struct GdkContentProviderLeaf <: GdkContentProvider
            handle::Ptr{GObject}
            function GdkContentProviderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkContentProviderLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkContentProvider] = GdkContentProviderLeaf
        (GLib.g_type(::Type{T}) where T <: GdkContentProvider) = begin
                ccall(("gdk_content_provider_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkContentProvider})
            vcat([:content_changed], signalnames(supertype(GdkContentProvider)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :content_changed => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkContentProvider
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkContentProvider
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkContentSerializer <: GObject end
        mutable struct GdkContentSerializerLeaf <: GdkContentSerializer
            handle::Ptr{GObject}
            function GdkContentSerializerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkContentSerializerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkContentSerializer] = GdkContentSerializerLeaf
        (GLib.g_type(::Type{T}) where T <: GdkContentSerializer) = begin
                ccall(("gdk_content_serializer_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkContentSerializer})
            signalnames(supertype(GdkContentSerializer))
        end
    end
    begin
        abstract type GdkCrossingEvent <: GdkEvent end
    end
    begin
        mutable struct GdkCrossingEventLeaf <: GdkCrossingEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkCursor <: GObject end
        mutable struct GdkCursorLeaf <: GdkCursor
            handle::Ptr{GObject}
            function GdkCursorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkCursorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkCursor] = GdkCursorLeaf
        (GLib.g_type(::Type{T}) where T <: GdkCursor) = begin
                ccall(("gdk_cursor_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkCursor})
            signalnames(supertype(GdkCursor))
        end
    end
    begin
        abstract type GdkDNDEvent <: GdkEvent end
    end
    begin
        mutable struct GdkDNDEventLeaf <: GdkDNDEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkDeleteEvent <: GdkEvent end
    end
    begin
        mutable struct GdkDeleteEventLeaf <: GdkDeleteEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkDevice <: GObject end
        mutable struct GdkDeviceLeaf <: GdkDevice
            handle::Ptr{GObject}
            function GdkDeviceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDeviceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkDevice] = GdkDeviceLeaf
        (GLib.g_type(::Type{T}) where T <: GdkDevice) = begin
                ccall(("gdk_device_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkDevice})
            vcat([:changed, :tool_changed], signalnames(supertype(GdkDevice)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :tool_changed => (:Nothing, Expr[:(Ptr{GObject})]), :changed => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkDevice
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkDevice
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkDeviceTool <: GObject end
        mutable struct GdkDeviceToolLeaf <: GdkDeviceTool
            handle::Ptr{GObject}
            function GdkDeviceToolLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDeviceToolLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkDeviceTool] = GdkDeviceToolLeaf
        (GLib.g_type(::Type{T}) where T <: GdkDeviceTool) = begin
                ccall(("gdk_device_tool_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkDeviceTool})
            signalnames(supertype(GdkDeviceTool))
        end
    end
    begin
        abstract type GdkDisplay <: GObject end
        mutable struct GdkDisplayLeaf <: GdkDisplay
            handle::Ptr{GObject}
            function GdkDisplayLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDisplayLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkDisplay] = GdkDisplayLeaf
        (GLib.g_type(::Type{T}) where T <: GdkDisplay) = begin
                ccall(("gdk_display_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkDisplay})
            vcat([:closed, :opened, :seat_added, :seat_removed, :setting_changed], signalnames(supertype(GdkDisplay)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :opened => (:Nothing, Any[]), :setting_changed => (:Nothing, [:Cstring]), :seat_removed => (:Nothing, Expr[:(Ptr{GObject})]), :seat_added => (:Nothing, Expr[:(Ptr{GObject})]), :closed => (:Nothing, [:Cint]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkDisplay
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkDisplay
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkDisplayManager <: GObject end
        mutable struct GdkDisplayManagerLeaf <: GdkDisplayManager
            handle::Ptr{GObject}
            function GdkDisplayManagerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDisplayManagerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkDisplayManager] = GdkDisplayManagerLeaf
        (GLib.g_type(::Type{T}) where T <: GdkDisplayManager) = begin
                ccall(("gdk_display_manager_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkDisplayManager})
            vcat([:display_opened], signalnames(supertype(GdkDisplayManager)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :display_opened => (:Nothing, Expr[:(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkDisplayManager
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkDisplayManager
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkDrag <: GObject end
        mutable struct GdkDragLeaf <: GdkDrag
            handle::Ptr{GObject}
            function GdkDragLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDragLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkDrag] = GdkDragLeaf
        (GLib.g_type(::Type{T}) where T <: GdkDrag) = begin
                ccall(("gdk_drag_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkDrag})
            vcat([:cancel, :dnd_finished, :drop_performed], signalnames(supertype(GdkDrag)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :dnd_finished => (:Nothing, Any[]), :cancel => (:Nothing, [:UInt32]), :drop_performed => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkDrag
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkDrag
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkDrop <: GObject end
        mutable struct GdkDropLeaf <: GdkDrop
            handle::Ptr{GObject}
            function GdkDropLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkDropLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkDrop] = GdkDropLeaf
        (GLib.g_type(::Type{T}) where T <: GdkDrop) = begin
                ccall(("gdk_drop_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkDrop})
            signalnames(supertype(GdkDrop))
        end
    end
    begin
        abstract type GdkFocusEvent <: GdkEvent end
    end
    begin
        mutable struct GdkFocusEventLeaf <: GdkFocusEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkFrameClock <: GObject end
        mutable struct GdkFrameClockLeaf <: GdkFrameClock
            handle::Ptr{GObject}
            function GdkFrameClockLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkFrameClockLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkFrameClock] = GdkFrameClockLeaf
        (GLib.g_type(::Type{T}) where T <: GdkFrameClock) = begin
                ccall(("gdk_frame_clock_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkFrameClock})
            vcat([:after_paint, :before_paint, :flush_events, :layout, :paint, :resume_events, :update], signalnames(supertype(GdkFrameClock)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :before_paint => (:Nothing, Any[]), :update => (:Nothing, Any[]), :flush_events => (:Nothing, Any[]), :layout => (:Nothing, Any[]), :after_paint => (:Nothing, Any[]), :resume_events => (:Nothing, Any[]), :paint => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkFrameClock
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkFrameClock
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkGLContext <: GdkDrawContext end
        mutable struct GdkGLContextLeaf <: GdkGLContext
            handle::Ptr{GObject}
            function GdkGLContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkGLContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkGLContext] = GdkGLContextLeaf
        (GLib.g_type(::Type{T}) where T <: GdkGLContext) = begin
                ccall(("gdk_gl_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkGLContext})
            signalnames(supertype(GdkGLContext))
        end
    end
    begin
        abstract type GdkTexture <: GObject end
        mutable struct GdkTextureLeaf <: GdkTexture
            handle::Ptr{GObject}
            function GdkTextureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkTextureLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkTexture] = GdkTextureLeaf
        (GLib.g_type(::Type{T}) where T <: GdkTexture) = begin
                ccall(("gdk_texture_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkTexture})
            vcat([:invalidate_contents, :invalidate_size], signalnames(supertype(GdkTexture)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkTexture
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkTexture
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkGLTexture <: GdkTexture end
        mutable struct GdkGLTextureLeaf <: GdkGLTexture
            handle::Ptr{GObject}
            function GdkGLTextureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkGLTextureLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkGLTexture] = GdkGLTextureLeaf
        (GLib.g_type(::Type{T}) where T <: GdkGLTexture) = begin
                ccall(("gdk_gl_texture_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkGLTexture})
            vcat([:invalidate_contents, :invalidate_size], signalnames(supertype(GdkGLTexture)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkGLTexture
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkGLTexture
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkGLTextureBuilder <: GObject end
        mutable struct GdkGLTextureBuilderLeaf <: GdkGLTextureBuilder
            handle::Ptr{GObject}
            function GdkGLTextureBuilderLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkGLTextureBuilderLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkGLTextureBuilder] = GdkGLTextureBuilderLeaf
        (GLib.g_type(::Type{T}) where T <: GdkGLTextureBuilder) = begin
                ccall(("gdk_gl_texture_builder_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkGLTextureBuilder})
            signalnames(supertype(GdkGLTextureBuilder))
        end
    end
    begin
        abstract type GdkGrabBrokenEvent <: GdkEvent end
    end
    begin
        mutable struct GdkGrabBrokenEventLeaf <: GdkGrabBrokenEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkKeyEvent <: GdkEvent end
    end
    begin
        mutable struct GdkKeyEventLeaf <: GdkKeyEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkMemoryTexture <: GdkTexture end
        mutable struct GdkMemoryTextureLeaf <: GdkMemoryTexture
            handle::Ptr{GObject}
            function GdkMemoryTextureLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkMemoryTextureLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkMemoryTexture] = GdkMemoryTextureLeaf
        (GLib.g_type(::Type{T}) where T <: GdkMemoryTexture) = begin
                ccall(("gdk_memory_texture_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkMemoryTexture})
            vcat([:invalidate_contents, :invalidate_size], signalnames(supertype(GdkMemoryTexture)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkMemoryTexture
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkMemoryTexture
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkMonitor <: GObject end
        mutable struct GdkMonitorLeaf <: GdkMonitor
            handle::Ptr{GObject}
            function GdkMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkMonitor] = GdkMonitorLeaf
        (GLib.g_type(::Type{T}) where T <: GdkMonitor) = begin
                ccall(("gdk_monitor_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkMonitor})
            vcat([:invalidate], signalnames(supertype(GdkMonitor)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :invalidate => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkMonitor
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkMonitor
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkMotionEvent <: GdkEvent end
    end
    begin
        mutable struct GdkMotionEventLeaf <: GdkMotionEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkPadEvent <: GdkEvent end
    end
    begin
        mutable struct GdkPadEventLeaf <: GdkPadEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkProximityEvent <: GdkEvent end
    end
    begin
        mutable struct GdkProximityEventLeaf <: GdkProximityEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkScrollEvent <: GdkEvent end
    end
    begin
        mutable struct GdkScrollEventLeaf <: GdkScrollEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkSeat <: GObject end
        mutable struct GdkSeatLeaf <: GdkSeat
            handle::Ptr{GObject}
            function GdkSeatLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkSeatLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkSeat] = GdkSeatLeaf
        (GLib.g_type(::Type{T}) where T <: GdkSeat) = begin
                ccall(("gdk_seat_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkSeat})
            vcat([:device_added, :device_removed, :tool_added, :tool_removed], signalnames(supertype(GdkSeat)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :tool_removed => (:Nothing, Expr[:(Ptr{GObject})]), :device_added => (:Nothing, Expr[:(Ptr{GObject})]), :tool_added => (:Nothing, Expr[:(Ptr{GObject})]), :device_removed => (:Nothing, Expr[:(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkSeat
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkSeat
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkSnapshot <: GObject end
        mutable struct GdkSnapshotLeaf <: GdkSnapshot
            handle::Ptr{GObject}
            function GdkSnapshotLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkSnapshotLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkSnapshot] = GdkSnapshotLeaf
        (GLib.g_type(::Type{T}) where T <: GdkSnapshot) = begin
                ccall(("gdk_snapshot_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkSnapshot})
            signalnames(supertype(GdkSnapshot))
        end
    end
    begin
        abstract type GdkSurface <: GObject end
        mutable struct GdkSurfaceLeaf <: GdkSurface
            handle::Ptr{GObject}
            function GdkSurfaceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkSurfaceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkSurface] = GdkSurfaceLeaf
        (GLib.g_type(::Type{T}) where T <: GdkSurface) = begin
                ccall(("gdk_surface_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkSurface})
            vcat([:enter_monitor, :event, :layout, :leave_monitor, :render], signalnames(supertype(GdkSurface)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Cint, Expr[:(Ptr{GdkEvent})]), :render => (:Cint, [:cairoRegion]), :layout => (:Nothing, [:Int32, :Int32]), :enter_monitor => (:Nothing, Expr[:(Ptr{GObject})]), :leave_monitor => (:Nothing, Expr[:(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkSurface
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkSurface
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GdkTouchEvent <: GdkEvent end
    end
    begin
        mutable struct GdkTouchEventLeaf <: GdkTouchEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkTouchpadEvent <: GdkEvent end
    end
    begin
        mutable struct GdkTouchpadEventLeaf <: GdkTouchpadEvent
            handle::Ptr{GdkEvent}
        end
    end
    begin
        abstract type GdkVulkanContext <: GdkDrawContext end
        mutable struct GdkVulkanContextLeaf <: GdkVulkanContext
            handle::Ptr{GObject}
            function GdkVulkanContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GdkVulkanContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GdkVulkanContext] = GdkVulkanContextLeaf
        (GLib.g_type(::Type{T}) where T <: GdkVulkanContext) = begin
                ccall(("gdk_vulkan_context_get_type", libgtk4), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GdkVulkanContext})
            vcat([:images_updated], signalnames(supertype(GdkVulkanContext)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :images_updated => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GdkVulkanContext
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GdkVulkanContext
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        gtype_wrapper_cache_init() = begin
                merge!(GLib.gtype_wrappers, gtype_wrapper_cache)
            end
    end
    function GdkContentProvider(_mime_type::Union{AbstractString, Symbol}, _bytes::GBytes; kwargs...)
        obj = G_.ContentProvider_new_for_bytes(_mime_type, _bytes)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkContentProvider(_value::Union{GValue, Ref{_GValue}}; kwargs...)
        obj = G_.ContentProvider_new_for_value(_value)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkContentProvider(_providers; kwargs...)
        obj = G_.ContentProvider_new_union(_providers)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkCursor(_name::Union{AbstractString, Symbol}, _fallback::Maybe(GdkCursor); kwargs...)
        obj = G_.Cursor_new_from_name(_name, _fallback)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkCursor(_texture::GdkTexture, _hotspot_x::Integer, _hotspot_y::Integer, _fallback::Maybe(GdkCursor); kwargs...)
        obj = G_.Cursor_new_from_texture(_texture, _hotspot_x, _hotspot_y, _fallback)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkGLTextureBuilder(; kwargs...)
        obj = G_.GLTextureBuilder_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkMemoryTexture(_width::Integer, _height::Integer, _format, _bytes::GBytes, _stride::Integer)
        G_.MemoryTexture_new(_width, _height, _format, _bytes, _stride)
    end
    function GdkSurface(_parent::GdkSurface, _autohide::Bool; kwargs...)
        obj = G_.Surface_new_popup(_parent, _autohide)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkSurface(_display::GdkDisplay; kwargs...)
        obj = G_.Surface_new_toplevel(_display)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkTexture(_pixbuf::GdkPixbuf; kwargs...)
        obj = G_.Texture_new_for_pixbuf(_pixbuf)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkTexture(_bytes::GBytes; kwargs...)
        obj = G_.Texture_new_from_bytes(_bytes)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkTexture(_file::GFile; kwargs...)
        obj = G_.Texture_new_from_file(_file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkTexture(_path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Texture_new_from_filename(_path)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GdkContentFormats(_mime_types)
        G_.ContentFormats_new(_mime_types)
    end
    function GdkContentFormats(_type::Integer)
        G_.ContentFormats_new_for_gtype(_type)
    end
    function GdkContentFormatsBuilder()
        G_.ContentFormatsBuilder_new()
    end
    function GdkFileList(_files)
        G_.FileList_new_from_array(_files)
    end
    function GdkFileList(_files::GLib.LList{GLib._GSList{Ptr{GObject}}})
        G_.FileList_new_from_list(_files)
    end
    function GdkPopupLayout(_anchor_rect::Union{GdkRectangle, Ref{_GdkRectangle}}, _rect_anchor, _surface_anchor)
        G_.PopupLayout_new(_anchor_rect, _rect_anchor, _surface_anchor)
    end
    function GdkTextureDownloader(_texture::GdkTexture)
        G_.TextureDownloader_new(_texture)
    end
    function GdkToplevelLayout()
        G_.ToplevelLayout_new()
    end
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.AppLaunchContext.html)." GdkAppLaunchContext
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ButtonEvent.html)." GdkButtonEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.CairoContext.html)." GdkCairoContext
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Clipboard.html)." GdkClipboard
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ContentDeserializer.html)." GdkContentDeserializer
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ContentProvider.html)." GdkContentProvider
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ContentSerializer.html)." GdkContentSerializer
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.CrossingEvent.html)." GdkCrossingEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Cursor.html)." GdkCursor
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DNDEvent.html)." GdkDNDEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DeleteEvent.html)." GdkDeleteEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Device.html)." GdkDevice
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DeviceTool.html)." GdkDeviceTool
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Display.html)." GdkDisplay
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DisplayManager.html)." GdkDisplayManager
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Drag.html)." GdkDrag
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.DrawContext.html)." GdkDrawContext
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Drop.html)." GdkDrop
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Event.html)." GdkEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.FocusEvent.html)." GdkFocusEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.FrameClock.html)." GdkFrameClock
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.GLContext.html)." GdkGLContext
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.GLTexture.html)." GdkGLTexture
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.GLTextureBuilder.html)." GdkGLTextureBuilder
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.GrabBrokenEvent.html)." GdkGrabBrokenEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.KeyEvent.html)." GdkKeyEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.MemoryTexture.html)." GdkMemoryTexture
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Monitor.html)." GdkMonitor
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.MotionEvent.html)." GdkMotionEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.PadEvent.html)." GdkPadEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ProximityEvent.html)." GdkProximityEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.ScrollEvent.html)." GdkScrollEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Seat.html)." GdkSeat
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Snapshot.html)." GdkSnapshot
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Surface.html)." GdkSurface
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.Texture.html)." GdkTexture
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.TouchEvent.html)." GdkTouchEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.TouchpadEvent.html)." GdkTouchpadEvent
    @doc "See the [GTK docs](https://docs.gtk.org/gdk4/class.VulkanContext.html)." GdkVulkanContext
    function on_changed(f, object::GdkClipboard, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "changed", Nothing, (), after, user_data)
    end
    function on_content_changed(f, object::GdkContentProvider, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "content-changed", Nothing, (), after, user_data)
    end
    function on_changed(f, object::GdkDevice, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "changed", Nothing, (), after, user_data)
    end
    function on_tool_changed(f, object::GdkDevice, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "tool-changed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_closed(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "closed", Nothing, (Cint,), after, user_data)
    end
    function on_opened(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "opened", Nothing, (), after, user_data)
    end
    function on_seat_added(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "seat-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_seat_removed(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "seat-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_setting_changed(f, object::GdkDisplay, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "setting-changed", Nothing, (Cstring,), after, user_data)
    end
    function on_display_opened(f, object::GdkDisplayManager, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "display-opened", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_cancel(f, object::GdkDrag, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "cancel", Nothing, (UInt32,), after, user_data)
    end
    function on_dnd_finished(f, object::GdkDrag, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "dnd-finished", Nothing, (), after, user_data)
    end
    function on_drop_performed(f, object::GdkDrag, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drop-performed", Nothing, (), after, user_data)
    end
    function on_after_paint(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "after-paint", Nothing, (), after, user_data)
    end
    function on_before_paint(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "before-paint", Nothing, (), after, user_data)
    end
    function on_flush_events(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "flush-events", Nothing, (), after, user_data)
    end
    function on_layout(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "layout", Nothing, (), after, user_data)
    end
    function on_paint(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "paint", Nothing, (), after, user_data)
    end
    function on_resume_events(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "resume-events", Nothing, (), after, user_data)
    end
    function on_update(f, object::GdkFrameClock, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "update", Nothing, (), after, user_data)
    end
    function on_invalidate_contents(f, object::GdkGLTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-contents", Nothing, (), after, user_data)
    end
    function on_invalidate_size(f, object::GdkGLTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-size", Nothing, (), after, user_data)
    end
    function on_invalidate_contents(f, object::GdkMemoryTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-contents", Nothing, (), after, user_data)
    end
    function on_invalidate_size(f, object::GdkMemoryTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-size", Nothing, (), after, user_data)
    end
    function on_invalidate(f, object::GdkMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate", Nothing, (), after, user_data)
    end
    function on_device_added(f, object::GdkSeat, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "device-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_device_removed(f, object::GdkSeat, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "device-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_tool_added(f, object::GdkSeat, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "tool-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_tool_removed(f, object::GdkSeat, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "tool-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_enter_monitor(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "enter-monitor", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_event(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "event", Cint, (Ptr{GdkEvent},), after, user_data)
    end
    function on_layout(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "layout", Nothing, (Int32, Int32), after, user_data)
    end
    function on_leave_monitor(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "leave-monitor", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_render(f, object::GdkSurface, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "render", Cint, (cairoRegion,), after, user_data)
    end
    function on_invalidate_contents(f, object::GdkTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-contents", Nothing, (), after, user_data)
    end
    function on_invalidate_size(f, object::GdkTexture, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "invalidate-size", Nothing, (), after, user_data)
    end
    function on_images_updated(f, object::GdkVulkanContext, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "images-updated", Nothing, (), after, user_data)
    end
    export GdkContentFormats, GdkContentFormatsBuilder, GdkDragSurfaceSize, GdkEventSequence, GdkFileList, GdkFrameTimings, GdkKeymapKey, _GdkKeymapKey, GdkPopupLayout, GdkRGBA, _GdkRGBA, GdkRectangle, _GdkRectangle, GdkTextureDownloader, GdkTimeCoord, _GdkTimeCoord, GdkToplevelLayout, GdkDevicePad, GdkDragSurface, GdkPaintable, GdkPopup, GdkToplevel, GdkAppLaunchContext, GdkAppLaunchContextLeaf, GdkButtonEvent, GdkButtonEventLeaf, GdkCairoContext, GdkClipboard, GdkClipboardLeaf, GdkContentDeserializer, GdkContentDeserializerLeaf, GdkContentProvider, GdkContentProviderLeaf, GdkContentSerializer, GdkContentSerializerLeaf, GdkCrossingEvent, GdkCrossingEventLeaf, GdkCursor, GdkCursorLeaf, GdkDNDEvent, GdkDNDEventLeaf, GdkDeleteEvent, GdkDeleteEventLeaf, GdkDevice, GdkDeviceTool, GdkDeviceToolLeaf, GdkDisplay, GdkDisplayLeaf, GdkDisplayManager, GdkDisplayManagerLeaf, GdkDrag, GdkDrawContext, GdkDrop, GdkEvent, GdkFocusEvent, GdkFocusEventLeaf, GdkFrameClock, GdkGLContext, GdkGLTexture, GdkGLTextureLeaf, GdkGLTextureBuilder, GdkGLTextureBuilderLeaf, GdkGrabBrokenEvent, GdkGrabBrokenEventLeaf, GdkKeyEvent, GdkKeyEventLeaf, GdkMemoryTexture, GdkMemoryTextureLeaf, GdkMonitor, GdkMonitorLeaf, GdkMotionEvent, GdkMotionEventLeaf, GdkPadEvent, GdkPadEventLeaf, GdkProximityEvent, GdkProximityEventLeaf, GdkScrollEvent, GdkScrollEventLeaf, GdkSeat, GdkSnapshot, GdkSurface, GdkTexture, GdkTouchEvent, GdkTouchEventLeaf, GdkTouchpadEvent, GdkTouchpadEventLeaf, GdkVulkanContext
end))
end
