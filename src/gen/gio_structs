quote
$(Expr(:toplevel, quote
    begin
        struct _GDBusErrorEntry
            error_code::Int32
            dbus_error_name::Cstring
        end
        mutable struct GDBusErrorEntry
            handle::Ptr{_GDBusErrorEntry}
        end
        unsafe_convert(::Type{Ptr{_GDBusErrorEntry}}, box::GDBusErrorEntry) = begin
                convert(Ptr{_GDBusErrorEntry}, box.handle)
            end
    end
    begin
        struct _GFileAttributeInfo
            name::Cstring
            type::UInt32
            flags::UInt32
        end
        mutable struct GFileAttributeInfo
            handle::Ptr{_GFileAttributeInfo}
        end
        unsafe_convert(::Type{Ptr{_GFileAttributeInfo}}, box::GFileAttributeInfo) = begin
                convert(Ptr{_GFileAttributeInfo}, box.handle)
            end
    end
    begin
        struct _GFileAttributeInfoList
            infos::Ptr{_GFileAttributeInfo}
            n_infos::Int32
        end
        mutable struct GFileAttributeInfoList <: GBoxed
            handle::Ptr{_GFileAttributeInfoList}
            begin
                (GLib.g_type(::Type{T}) where T <: GFileAttributeInfoList) = begin
                        ccall(("g_file_attribute_info_list_get_type", libgio), GType, ())
                    end
                function GFileAttributeInfoList(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GFileAttributeInfoList)
            end
        end
        unsafe_convert(::Type{Ptr{_GFileAttributeInfoList}}, box::GFileAttributeInfoList) = begin
                convert(Ptr{_GFileAttributeInfoList}, box.handle)
            end
    end
    mutable struct GFileAttributeMatcher <: GBoxed
        handle::Ptr{GFileAttributeMatcher}
        begin
            (GLib.g_type(::Type{T}) where T <: GFileAttributeMatcher) = begin
                    ccall(("g_file_attribute_matcher_get_type", libgio), GType, ())
                end
            function GFileAttributeMatcher(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GFileAttributeMatcher)
        end
    end
    begin
        struct _GInputVector
            buffer::Ptr{Nothing}
            size::UInt64
        end
        mutable struct GInputVector
            handle::Ptr{_GInputVector}
        end
        unsafe_convert(::Type{Ptr{_GInputVector}}, box::GInputVector) = begin
                convert(Ptr{_GInputVector}, box.handle)
            end
    end
    begin
        struct _GOutputVector
            buffer::Ptr{Nothing}
            size::UInt64
        end
        mutable struct GOutputVector
            handle::Ptr{_GOutputVector}
        end
        unsafe_convert(::Type{Ptr{_GOutputVector}}, box::GOutputVector) = begin
                convert(Ptr{_GOutputVector}, box.handle)
            end
    end
    mutable struct GResource <: GBoxed
        handle::Ptr{GResource}
        begin
            (GLib.g_type(::Type{T}) where T <: GResource) = begin
                    ccall(("g_resource_get_type", libgio), GType, ())
                end
            function GResource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GResource)
        end
    end
    mutable struct GSettingsSchema <: GBoxed
        handle::Ptr{GSettingsSchema}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchema) = begin
                    ccall(("g_settings_schema_get_type", libgio), GType, ())
                end
            function GSettingsSchema(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchema)
        end
    end
    mutable struct GSettingsSchemaKey <: GBoxed
        handle::Ptr{GSettingsSchemaKey}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchemaKey) = begin
                    ccall(("g_settings_schema_key_get_type", libgio), GType, ())
                end
            function GSettingsSchemaKey(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchemaKey)
        end
    end
    mutable struct GSettingsSchemaSource <: GBoxed
        handle::Ptr{GSettingsSchemaSource}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchemaSource) = begin
                    ccall(("g_settings_schema_source_get_type", libgio), GType, ())
                end
            function GSettingsSchemaSource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchemaSource)
        end
    end
    mutable struct GSrvTarget <: GBoxed
        handle::Ptr{GSrvTarget}
        begin
            (GLib.g_type(::Type{T}) where T <: GSrvTarget) = begin
                    ccall(("g_srv_target_get_type", libgio), GType, ())
                end
            function GSrvTarget(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSrvTarget)
        end
    end
    begin
        struct _GXdpDocumentsIface
            parent_iface::_GTypeInterface
            handle_add::Ptr{Cvoid}
            handle_add_full::Ptr{Cvoid}
            handle_add_named::Ptr{Cvoid}
            handle_add_named_full::Ptr{Cvoid}
            handle_delete::Ptr{Cvoid}
            handle_get_mount_point::Ptr{Cvoid}
            handle_grant_permissions::Ptr{Cvoid}
            handle_info::Ptr{Cvoid}
            handle_list::Ptr{Cvoid}
            handle_lookup::Ptr{Cvoid}
            handle_revoke_permissions::Ptr{Cvoid}
            get_version::Ptr{Cvoid}
        end
        mutable struct GXdpDocumentsIface
            handle::Ptr{_GXdpDocumentsIface}
        end
        unsafe_convert(::Type{Ptr{_GXdpDocumentsIface}}, box::GXdpDocumentsIface) = begin
                convert(Ptr{_GXdpDocumentsIface}, box.handle)
            end
    end
    begin
        struct _GXdpOpenURIIface
            parent_iface::_GTypeInterface
            handle_open_directory::Ptr{Cvoid}
            handle_open_file::Ptr{Cvoid}
            handle_open_uri::Ptr{Cvoid}
            get_version::Ptr{Cvoid}
        end
        mutable struct GXdpOpenURIIface
            handle::Ptr{_GXdpOpenURIIface}
        end
        unsafe_convert(::Type{Ptr{_GXdpOpenURIIface}}, box::GXdpOpenURIIface) = begin
                convert(Ptr{_GXdpOpenURIIface}, box.handle)
            end
    end
    begin
        struct _GXdpProxyResolverIface
            parent_iface::_GTypeInterface
            handle_lookup::Ptr{Cvoid}
            get_version::Ptr{Cvoid}
        end
        mutable struct GXdpProxyResolverIface
            handle::Ptr{_GXdpProxyResolverIface}
        end
        unsafe_convert(::Type{Ptr{_GXdpProxyResolverIface}}, box::GXdpProxyResolverIface) = begin
                convert(Ptr{_GXdpProxyResolverIface}, box.handle)
            end
    end
    begin
        struct _GXdpTrashIface
            parent_iface::_GTypeInterface
            handle_trash_file::Ptr{Cvoid}
            get_version::Ptr{Cvoid}
        end
        mutable struct GXdpTrashIface
            handle::Ptr{_GXdpTrashIface}
        end
        unsafe_convert(::Type{Ptr{_GXdpTrashIface}}, box::GXdpTrashIface) = begin
                convert(Ptr{_GXdpTrashIface}, box.handle)
            end
    end
    begin
        struct _G_FreedesktopDBusIface
            parent_iface::_GTypeInterface
            handle_add_match::Ptr{Nothing}
            handle_get_connection_selinux_security_context::Ptr{Nothing}
            handle_get_connection_unix_process_id::Ptr{Nothing}
            handle_get_connection_unix_user::Ptr{Nothing}
            handle_get_id::Ptr{Nothing}
            handle_get_name_owner::Ptr{Nothing}
            handle_hello::Ptr{Nothing}
            handle_list_activatable_names::Ptr{Nothing}
            handle_list_names::Ptr{Nothing}
            handle_list_queued_owners::Ptr{Nothing}
            handle_name_has_owner::Ptr{Nothing}
            handle_release_name::Ptr{Nothing}
            handle_reload_config::Ptr{Nothing}
            handle_remove_match::Ptr{Nothing}
            handle_request_name::Ptr{Nothing}
            handle_start_service_by_name::Ptr{Nothing}
            handle_update_activation_environment::Ptr{Nothing}
            name_acquired::Ptr{Nothing}
            name_lost::Ptr{Nothing}
            name_owner_changed::Ptr{Nothing}
        end
        mutable struct G_FreedesktopDBusIface
            handle::Ptr{_G_FreedesktopDBusIface}
        end
        unsafe_convert(::Type{Ptr{_G_FreedesktopDBusIface}}, box::G_FreedesktopDBusIface) = begin
                convert(Ptr{_G_FreedesktopDBusIface}, box.handle)
            end
    end
    begin
        struct _G_FreedesktopDBusProxy
            parent_instance::Ptr{GObject}
            priv::Ptr{Nothing}
        end
        mutable struct G_FreedesktopDBusProxy
            handle::Ptr{_G_FreedesktopDBusProxy}
        end
        unsafe_convert(::Type{Ptr{_G_FreedesktopDBusProxy}}, box::G_FreedesktopDBusProxy) = begin
                convert(Ptr{_G_FreedesktopDBusProxy}, box.handle)
            end
    end
    begin
        struct _G_FreedesktopDBusSkeleton
            parent_instance::Ptr{GObject}
            priv::Ptr{Nothing}
        end
        mutable struct G_FreedesktopDBusSkeleton
            handle::Ptr{_G_FreedesktopDBusSkeleton}
        end
        unsafe_convert(::Type{Ptr{_G_FreedesktopDBusSkeleton}}, box::G_FreedesktopDBusSkeleton) = begin
                convert(Ptr{_G_FreedesktopDBusSkeleton}, box.handle)
            end
    end
    function GFileAttributeInfoList()
        G_.FileAttributeInfoList_new()
    end
    function GFileAttributeMatcher(_attributes::Union{AbstractString, Symbol})
        G_.FileAttributeMatcher_new(_attributes)
    end
    function GResource(_data::GBytes)
        G_.Resource_new_from_data(_data)
    end
    function GSettingsSchemaSource(_directory::Union{AbstractString, Symbol}, _parent::Maybe(GSettingsSchemaSource), _trusted::Bool)
        G_.SettingsSchemaSource_new_from_directory(_directory, _parent, _trusted)
    end
    function GSrvTarget(_hostname::Union{AbstractString, Symbol}, _port::Integer, _priority::Integer, _weight::Integer)
        G_.SrvTarget_new(_hostname, _port, _priority, _weight)
    end
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.DBusErrorEntry.html)." GDBusErrorEntry
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.FileAttributeInfo.html)." GFileAttributeInfo
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.FileAttributeInfoList.html)." GFileAttributeInfoList
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.FileAttributeMatcher.html)." GFileAttributeMatcher
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.InputVector.html)." GInputVector
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.OutputVector.html)." GOutputVector
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.Resource.html)." GResource
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.SettingsSchema.html)." GSettingsSchema
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.SettingsSchemaKey.html)." GSettingsSchemaKey
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.SettingsSchemaSource.html)." GSettingsSchemaSource
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.SrvTarget.html)." GSrvTarget
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.XdpDocumentsIface.html)." GXdpDocumentsIface
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.XdpOpenURIIface.html)." GXdpOpenURIIface
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.XdpProxyResolverIface.html)." GXdpProxyResolverIface
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.XdpTrashIface.html)." GXdpTrashIface
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct._FreedesktopDBusIface.html)." G_FreedesktopDBusIface
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct._FreedesktopDBusProxy.html)." G_FreedesktopDBusProxy
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct._FreedesktopDBusSkeleton.html)." G_FreedesktopDBusSkeleton
    struct GAction <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GAction(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GActionGroup <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GActionGroup(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GActionMap <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GActionMap(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GAppInfo <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GAppInfo(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GAsyncInitable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GAsyncInitable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GAsyncResult <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GAsyncResult(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GConverter <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GConverter(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDBusInterface <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDBusInterface(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDBusObject <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDBusObject(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDBusObjectManager <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDBusObjectManager(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDatagramBased <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDatagramBased(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDebugController <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDebugController(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDrive <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDrive(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDtlsClientConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDtlsClientConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDtlsConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDtlsConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDtlsServerConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDtlsServerConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GFile <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GFile(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GFileDescriptorBased <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GFileDescriptorBased(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GIcon <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GIcon(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GInitable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GInitable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GListModel <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GListModel(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GLoadableIcon <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GLoadableIcon(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GMemoryMonitor <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GMemoryMonitor(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GMount <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GMount(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GNetworkMonitor <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GNetworkMonitor(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GPollableInputStream <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GPollableInputStream(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GPollableOutputStream <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GPollableOutputStream(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GPowerProfileMonitor <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GPowerProfileMonitor(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GProxy <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GProxy(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GProxyResolver <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GProxyResolver(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GRemoteActionGroup <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GRemoteActionGroup(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GSeekable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GSeekable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GSocketConnectable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GSocketConnectable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GTlsBackend <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GTlsBackend(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GTlsClientConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GTlsClientConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GTlsFileDatabase <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GTlsFileDatabase(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GTlsServerConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GTlsServerConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GVolume <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GVolume(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    begin
        abstract type GAppInfoMonitor <: GObject end
        mutable struct GAppInfoMonitorLeaf <: GAppInfoMonitor
            handle::Ptr{GObject}
            function GAppInfoMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GAppInfoMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GAppInfoMonitor] = GAppInfoMonitorLeaf
        (GLib.g_type(::Type{T}) where T <: GAppInfoMonitor) = begin
                ccall(("g_app_info_monitor_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GAppInfoMonitor})
            vcat([:changed], signalnames(supertype(GAppInfoMonitor)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :changed => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GAppInfoMonitor
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GAppInfoMonitor
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GAppLaunchContext <: GObject end
        mutable struct GAppLaunchContextLeaf <: GAppLaunchContext
            handle::Ptr{GObject}
            function GAppLaunchContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GAppLaunchContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GAppLaunchContext] = GAppLaunchContextLeaf
        (GLib.g_type(::Type{T}) where T <: GAppLaunchContext) = begin
                ccall(("g_app_launch_context_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GAppLaunchContext})
            vcat([:launch_failed, :launch_started, :launched], signalnames(supertype(GAppLaunchContext)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :launch_failed => (:Nothing, [:Cstring]), :launched => (:Nothing, Any[:(Ptr{GObject}), :GVariant]), :launch_started => (:Nothing, Any[:(Ptr{GObject}), :GVariant]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GAppLaunchContext
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GAppLaunchContext
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GApplication <: GObject end
        mutable struct GApplicationLeaf <: GApplication
            handle::Ptr{GObject}
            function GApplicationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GApplicationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GApplication] = GApplicationLeaf
        (GLib.g_type(::Type{T}) where T <: GApplication) = begin
                ccall(("g_application_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GApplication})
            vcat([:activate, :command_line, :handle_local_options, :name_lost, :open, :shutdown, :startup, :action_added, :action_enabled_changed, :action_removed, :action_state_changed], signalnames(supertype(GApplication)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :startup => (:Nothing, Any[]), :shutdown => (:Nothing, Any[]), :command_line => (:Int32, Expr[:(Ptr{GObject})]), :name_lost => (:Cint, Any[]), :open => (:Nothing, Any[:(Ptr{Ptr{GObject}}), :Int32, :Cstring]), :activate => (:Nothing, Any[]), :handle_local_options => (:Int32, [:GVariantDict]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GApplication
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GApplication
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GApplicationCommandLine <: GObject end
        mutable struct GApplicationCommandLineLeaf <: GApplicationCommandLine
            handle::Ptr{GObject}
            function GApplicationCommandLineLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GApplicationCommandLineLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GApplicationCommandLine] = GApplicationCommandLineLeaf
        (GLib.g_type(::Type{T}) where T <: GApplicationCommandLine) = begin
                ccall(("g_application_command_line_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GApplicationCommandLine})
            signalnames(supertype(GApplicationCommandLine))
        end
    end
    begin
        abstract type GInputStream <: GObject end
        mutable struct GInputStreamLeaf <: GInputStream
            handle::Ptr{GObject}
            function GInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GInputStream] = GInputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GInputStream) = begin
                ccall(("g_input_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GInputStream})
            signalnames(supertype(GInputStream))
        end
    end
    begin
        abstract type GFilterInputStream <: GInputStream end
        mutable struct GFilterInputStreamLeaf <: GFilterInputStream
            handle::Ptr{GObject}
            function GFilterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilterInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFilterInputStream] = GFilterInputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GFilterInputStream) = begin
                ccall(("g_filter_input_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFilterInputStream})
            signalnames(supertype(GFilterInputStream))
        end
    end
    begin
        abstract type GBufferedInputStream <: GFilterInputStream end
        mutable struct GBufferedInputStreamLeaf <: GBufferedInputStream
            handle::Ptr{GObject}
            function GBufferedInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBufferedInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GBufferedInputStream] = GBufferedInputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GBufferedInputStream) = begin
                ccall(("g_buffered_input_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GBufferedInputStream})
            signalnames(supertype(GBufferedInputStream))
        end
    end
    begin
        abstract type GOutputStream <: GObject end
        mutable struct GOutputStreamLeaf <: GOutputStream
            handle::Ptr{GObject}
            function GOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GOutputStream] = GOutputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GOutputStream) = begin
                ccall(("g_output_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GOutputStream})
            signalnames(supertype(GOutputStream))
        end
    end
    begin
        abstract type GFilterOutputStream <: GOutputStream end
        mutable struct GFilterOutputStreamLeaf <: GFilterOutputStream
            handle::Ptr{GObject}
            function GFilterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilterOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFilterOutputStream] = GFilterOutputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GFilterOutputStream) = begin
                ccall(("g_filter_output_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFilterOutputStream})
            signalnames(supertype(GFilterOutputStream))
        end
    end
    begin
        abstract type GBufferedOutputStream <: GFilterOutputStream end
        mutable struct GBufferedOutputStreamLeaf <: GBufferedOutputStream
            handle::Ptr{GObject}
            function GBufferedOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBufferedOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GBufferedOutputStream] = GBufferedOutputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GBufferedOutputStream) = begin
                ccall(("g_buffered_output_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GBufferedOutputStream})
            signalnames(supertype(GBufferedOutputStream))
        end
    end
    begin
        abstract type GBytesIcon <: GObject end
        mutable struct GBytesIconLeaf <: GBytesIcon
            handle::Ptr{GObject}
            function GBytesIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBytesIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GBytesIcon] = GBytesIconLeaf
        (GLib.g_type(::Type{T}) where T <: GBytesIcon) = begin
                ccall(("g_bytes_icon_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GBytesIcon})
            signalnames(supertype(GBytesIcon))
        end
    end
    begin
        abstract type GCancellable <: GObject end
        mutable struct GCancellableLeaf <: GCancellable
            handle::Ptr{GObject}
            function GCancellableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCancellableLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GCancellable] = GCancellableLeaf
        (GLib.g_type(::Type{T}) where T <: GCancellable) = begin
                ccall(("g_cancellable_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GCancellable})
            vcat([:cancelled], signalnames(supertype(GCancellable)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :cancelled => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GCancellable
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GCancellable
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GCharsetConverter <: GObject end
        mutable struct GCharsetConverterLeaf <: GCharsetConverter
            handle::Ptr{GObject}
            function GCharsetConverterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCharsetConverterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GCharsetConverter] = GCharsetConverterLeaf
        (GLib.g_type(::Type{T}) where T <: GCharsetConverter) = begin
                ccall(("g_charset_converter_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GCharsetConverter})
            signalnames(supertype(GCharsetConverter))
        end
    end
    begin
        abstract type GConverterInputStream <: GFilterInputStream end
        mutable struct GConverterInputStreamLeaf <: GConverterInputStream
            handle::Ptr{GObject}
            function GConverterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GConverterInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GConverterInputStream] = GConverterInputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GConverterInputStream) = begin
                ccall(("g_converter_input_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GConverterInputStream})
            signalnames(supertype(GConverterInputStream))
        end
    end
    begin
        abstract type GConverterOutputStream <: GFilterOutputStream end
        mutable struct GConverterOutputStreamLeaf <: GConverterOutputStream
            handle::Ptr{GObject}
            function GConverterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GConverterOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GConverterOutputStream] = GConverterOutputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GConverterOutputStream) = begin
                ccall(("g_converter_output_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GConverterOutputStream})
            signalnames(supertype(GConverterOutputStream))
        end
    end
    begin
        abstract type GCredentials <: GObject end
        mutable struct GCredentialsLeaf <: GCredentials
            handle::Ptr{GObject}
            function GCredentialsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCredentialsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GCredentials] = GCredentialsLeaf
        (GLib.g_type(::Type{T}) where T <: GCredentials) = begin
                ccall(("g_credentials_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GCredentials})
            signalnames(supertype(GCredentials))
        end
    end
    begin
        abstract type GDBusActionGroup <: GObject end
        mutable struct GDBusActionGroupLeaf <: GDBusActionGroup
            handle::Ptr{GObject}
            function GDBusActionGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusActionGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusActionGroup] = GDBusActionGroupLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusActionGroup) = begin
                ccall(("g_dbus_action_group_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusActionGroup})
            vcat([:action_added, :action_enabled_changed, :action_removed, :action_state_changed], signalnames(supertype(GDBusActionGroup)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusActionGroup
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusActionGroup
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDBusAuthObserver <: GObject end
        mutable struct GDBusAuthObserverLeaf <: GDBusAuthObserver
            handle::Ptr{GObject}
            function GDBusAuthObserverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusAuthObserverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusAuthObserver] = GDBusAuthObserverLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusAuthObserver) = begin
                ccall(("g_dbus_auth_observer_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusAuthObserver})
            vcat([:allow_mechanism, :authorize_authenticated_peer], signalnames(supertype(GDBusAuthObserver)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :authorize_authenticated_peer => (:Cint, Expr[:(Ptr{GObject}), :(Ptr{GObject})]), :allow_mechanism => (:Cint, [:Cstring]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusAuthObserver
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusAuthObserver
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDBusConnection <: GObject end
        mutable struct GDBusConnectionLeaf <: GDBusConnection
            handle::Ptr{GObject}
            function GDBusConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusConnection] = GDBusConnectionLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusConnection) = begin
                ccall(("g_dbus_connection_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusConnection})
            vcat([:closed], signalnames(supertype(GDBusConnection)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :closed => (:Nothing, Any[:Cint, :(Ptr{GError})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusConnection
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusConnection
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDBusInterfaceSkeleton <: GObject end
        mutable struct GDBusInterfaceSkeletonLeaf <: GDBusInterfaceSkeleton
            handle::Ptr{GObject}
            function GDBusInterfaceSkeletonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusInterfaceSkeletonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusInterfaceSkeleton] = GDBusInterfaceSkeletonLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusInterfaceSkeleton) = begin
                ccall(("g_dbus_interface_skeleton_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusInterfaceSkeleton})
            vcat([:g_authorize_method], signalnames(supertype(GDBusInterfaceSkeleton)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :g_authorize_method => (:Cint, Expr[:(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusInterfaceSkeleton
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusInterfaceSkeleton
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GMenuModel <: GObject end
        mutable struct GMenuModelLeaf <: GMenuModel
            handle::Ptr{GObject}
            function GMenuModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GMenuModel] = GMenuModelLeaf
        (GLib.g_type(::Type{T}) where T <: GMenuModel) = begin
                ccall(("g_menu_model_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GMenuModel})
            vcat([:items_changed], signalnames(supertype(GMenuModel)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :items_changed => (:Nothing, [:Int32, :Int32, :Int32]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GMenuModel
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GMenuModel
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDBusMenuModel <: GMenuModel end
        mutable struct GDBusMenuModelLeaf <: GDBusMenuModel
            handle::Ptr{GObject}
            function GDBusMenuModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMenuModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusMenuModel] = GDBusMenuModelLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusMenuModel) = begin
                ccall(("g_dbus_menu_model_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusMenuModel})
            signalnames(supertype(GDBusMenuModel))
        end
    end
    begin
        abstract type GDBusMessage <: GObject end
        mutable struct GDBusMessageLeaf <: GDBusMessage
            handle::Ptr{GObject}
            function GDBusMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMessageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusMessage] = GDBusMessageLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusMessage) = begin
                ccall(("g_dbus_message_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusMessage})
            signalnames(supertype(GDBusMessage))
        end
    end
    begin
        abstract type GDBusMethodInvocation <: GObject end
        mutable struct GDBusMethodInvocationLeaf <: GDBusMethodInvocation
            handle::Ptr{GObject}
            function GDBusMethodInvocationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMethodInvocationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusMethodInvocation] = GDBusMethodInvocationLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusMethodInvocation) = begin
                ccall(("g_dbus_method_invocation_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusMethodInvocation})
            signalnames(supertype(GDBusMethodInvocation))
        end
    end
    begin
        abstract type GDBusObjectManagerClient <: GObject end
        mutable struct GDBusObjectManagerClientLeaf <: GDBusObjectManagerClient
            handle::Ptr{GObject}
            function GDBusObjectManagerClientLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectManagerClientLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusObjectManagerClient] = GDBusObjectManagerClientLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusObjectManagerClient) = begin
                ccall(("g_dbus_object_manager_client_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusObjectManagerClient})
            vcat([:interface_proxy_properties_changed, :interface_proxy_signal, :interface_added, :interface_removed, :object_added, :object_removed], signalnames(supertype(GDBusObjectManagerClient)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :interface_proxy_signal => (:Nothing, Any[:(Ptr{GObject}), :(Ptr{GObject}), :Cstring, :Cstring, :GVariant]), :interface_proxy_properties_changed => (:Nothing, Any[:(Ptr{GObject}), :(Ptr{GObject}), :GVariant, :(Ptr{Cstring})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusObjectManagerClient
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusObjectManagerClient
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDBusObjectManagerServer <: GObject end
        mutable struct GDBusObjectManagerServerLeaf <: GDBusObjectManagerServer
            handle::Ptr{GObject}
            function GDBusObjectManagerServerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectManagerServerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusObjectManagerServer] = GDBusObjectManagerServerLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusObjectManagerServer) = begin
                ccall(("g_dbus_object_manager_server_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusObjectManagerServer})
            vcat([:interface_added, :interface_removed, :object_added, :object_removed], signalnames(supertype(GDBusObjectManagerServer)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusObjectManagerServer
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusObjectManagerServer
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDBusObjectProxy <: GObject end
        mutable struct GDBusObjectProxyLeaf <: GDBusObjectProxy
            handle::Ptr{GObject}
            function GDBusObjectProxyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectProxyLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusObjectProxy] = GDBusObjectProxyLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusObjectProxy) = begin
                ccall(("g_dbus_object_proxy_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusObjectProxy})
            vcat([:interface_added, :interface_removed], signalnames(supertype(GDBusObjectProxy)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusObjectProxy
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusObjectProxy
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDBusObjectSkeleton <: GObject end
        mutable struct GDBusObjectSkeletonLeaf <: GDBusObjectSkeleton
            handle::Ptr{GObject}
            function GDBusObjectSkeletonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectSkeletonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusObjectSkeleton] = GDBusObjectSkeletonLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusObjectSkeleton) = begin
                ccall(("g_dbus_object_skeleton_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusObjectSkeleton})
            vcat([:authorize_method, :interface_added, :interface_removed], signalnames(supertype(GDBusObjectSkeleton)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :authorize_method => (:Cint, Expr[:(Ptr{GObject}), :(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusObjectSkeleton
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusObjectSkeleton
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDBusProxy <: GObject end
        mutable struct GDBusProxyLeaf <: GDBusProxy
            handle::Ptr{GObject}
            function GDBusProxyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusProxyLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusProxy] = GDBusProxyLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusProxy) = begin
                ccall(("g_dbus_proxy_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusProxy})
            vcat([:g_properties_changed, :g_signal], signalnames(supertype(GDBusProxy)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :g_signal => (:Nothing, [:Cstring, :Cstring, :GVariant]), :g_properties_changed => (:Nothing, Any[:GVariant, :(Ptr{Cstring})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusProxy
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusProxy
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDBusServer <: GObject end
        mutable struct GDBusServerLeaf <: GDBusServer
            handle::Ptr{GObject}
            function GDBusServerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusServerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDBusServer] = GDBusServerLeaf
        (GLib.g_type(::Type{T}) where T <: GDBusServer) = begin
                ccall(("g_dbus_server_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDBusServer})
            vcat([:new_connection], signalnames(supertype(GDBusServer)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :new_connection => (:Cint, Expr[:(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusServer
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusServer
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GDataInputStream <: GBufferedInputStream end
        mutable struct GDataInputStreamLeaf <: GDataInputStream
            handle::Ptr{GObject}
            function GDataInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDataInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDataInputStream] = GDataInputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GDataInputStream) = begin
                ccall(("g_data_input_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDataInputStream})
            signalnames(supertype(GDataInputStream))
        end
    end
    begin
        abstract type GDataOutputStream <: GFilterOutputStream end
        mutable struct GDataOutputStreamLeaf <: GDataOutputStream
            handle::Ptr{GObject}
            function GDataOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDataOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDataOutputStream] = GDataOutputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GDataOutputStream) = begin
                ccall(("g_data_output_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDataOutputStream})
            signalnames(supertype(GDataOutputStream))
        end
    end
    begin
        abstract type GDesktopAppInfo <: GObject end
        mutable struct GDesktopAppInfoLeaf <: GDesktopAppInfo
            handle::Ptr{GObject}
            function GDesktopAppInfoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDesktopAppInfoLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GDesktopAppInfo] = GDesktopAppInfoLeaf
        (GLib.g_type(::Type{T}) where T <: GDesktopAppInfo) = begin
                ccall(("g_desktop_app_info_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GDesktopAppInfo})
            signalnames(supertype(GDesktopAppInfo))
        end
    end
    begin
        abstract type GEmblem <: GObject end
        mutable struct GEmblemLeaf <: GEmblem
            handle::Ptr{GObject}
            function GEmblemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GEmblemLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GEmblem] = GEmblemLeaf
        (GLib.g_type(::Type{T}) where T <: GEmblem) = begin
                ccall(("g_emblem_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GEmblem})
            signalnames(supertype(GEmblem))
        end
    end
    begin
        abstract type GEmblemedIcon <: GObject end
        mutable struct GEmblemedIconLeaf <: GEmblemedIcon
            handle::Ptr{GObject}
            function GEmblemedIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GEmblemedIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GEmblemedIcon] = GEmblemedIconLeaf
        (GLib.g_type(::Type{T}) where T <: GEmblemedIcon) = begin
                ccall(("g_emblemed_icon_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GEmblemedIcon})
            signalnames(supertype(GEmblemedIcon))
        end
    end
    begin
        abstract type GFileEnumerator <: GObject end
        mutable struct GFileEnumeratorLeaf <: GFileEnumerator
            handle::Ptr{GObject}
            function GFileEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileEnumeratorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFileEnumerator] = GFileEnumeratorLeaf
        (GLib.g_type(::Type{T}) where T <: GFileEnumerator) = begin
                ccall(("g_file_enumerator_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFileEnumerator})
            signalnames(supertype(GFileEnumerator))
        end
    end
    begin
        abstract type GIOStream <: GObject end
        mutable struct GIOStreamLeaf <: GIOStream
            handle::Ptr{GObject}
            function GIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GIOStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GIOStream] = GIOStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GIOStream) = begin
                ccall(("g_io_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GIOStream})
            signalnames(supertype(GIOStream))
        end
    end
    begin
        abstract type GFileIOStream <: GIOStream end
        mutable struct GFileIOStreamLeaf <: GFileIOStream
            handle::Ptr{GObject}
            function GFileIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileIOStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFileIOStream] = GFileIOStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GFileIOStream) = begin
                ccall(("g_file_io_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFileIOStream})
            signalnames(supertype(GFileIOStream))
        end
    end
    begin
        abstract type GFileIcon <: GObject end
        mutable struct GFileIconLeaf <: GFileIcon
            handle::Ptr{GObject}
            function GFileIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFileIcon] = GFileIconLeaf
        (GLib.g_type(::Type{T}) where T <: GFileIcon) = begin
                ccall(("g_file_icon_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFileIcon})
            signalnames(supertype(GFileIcon))
        end
    end
    begin
        abstract type GFileInfo <: GObject end
        mutable struct GFileInfoLeaf <: GFileInfo
            handle::Ptr{GObject}
            function GFileInfoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileInfoLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFileInfo] = GFileInfoLeaf
        (GLib.g_type(::Type{T}) where T <: GFileInfo) = begin
                ccall(("g_file_info_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFileInfo})
            signalnames(supertype(GFileInfo))
        end
    end
    begin
        abstract type GFileInputStream <: GInputStream end
        mutable struct GFileInputStreamLeaf <: GFileInputStream
            handle::Ptr{GObject}
            function GFileInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFileInputStream] = GFileInputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GFileInputStream) = begin
                ccall(("g_file_input_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFileInputStream})
            signalnames(supertype(GFileInputStream))
        end
    end
    begin
        abstract type GFileMonitor <: GObject end
        mutable struct GFileMonitorLeaf <: GFileMonitor
            handle::Ptr{GObject}
            function GFileMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFileMonitor] = GFileMonitorLeaf
        (GLib.g_type(::Type{T}) where T <: GFileMonitor) = begin
                ccall(("g_file_monitor_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFileMonitor})
            vcat([:changed], signalnames(supertype(GFileMonitor)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :changed => (:Nothing, Any[:(Ptr{GObject}), :(Ptr{GObject}), :UInt32]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GFileMonitor
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GFileMonitor
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GFileOutputStream <: GOutputStream end
        mutable struct GFileOutputStreamLeaf <: GFileOutputStream
            handle::Ptr{GObject}
            function GFileOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFileOutputStream] = GFileOutputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GFileOutputStream) = begin
                ccall(("g_file_output_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFileOutputStream})
            signalnames(supertype(GFileOutputStream))
        end
    end
    begin
        abstract type GFilenameCompleter <: GObject end
        mutable struct GFilenameCompleterLeaf <: GFilenameCompleter
            handle::Ptr{GObject}
            function GFilenameCompleterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilenameCompleterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GFilenameCompleter] = GFilenameCompleterLeaf
        (GLib.g_type(::Type{T}) where T <: GFilenameCompleter) = begin
                ccall(("g_filename_completer_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GFilenameCompleter})
            vcat([:got_completion_data], signalnames(supertype(GFilenameCompleter)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :got_completion_data => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GFilenameCompleter
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GFilenameCompleter
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GIOModule <: GTypeModule end
        mutable struct GIOModuleLeaf <: GIOModule
            handle::Ptr{GObject}
            function GIOModuleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GIOModuleLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GIOModule] = GIOModuleLeaf
        (GLib.g_type(::Type{T}) where T <: GIOModule) = begin
                ccall(("g_io_module_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GIOModule})
            signalnames(supertype(GIOModule))
        end
    end
    begin
        abstract type GInetAddress <: GObject end
        mutable struct GInetAddressLeaf <: GInetAddress
            handle::Ptr{GObject}
            function GInetAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GInetAddress] = GInetAddressLeaf
        (GLib.g_type(::Type{T}) where T <: GInetAddress) = begin
                ccall(("g_inet_address_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GInetAddress})
            signalnames(supertype(GInetAddress))
        end
    end
    begin
        abstract type GInetAddressMask <: GObject end
        mutable struct GInetAddressMaskLeaf <: GInetAddressMask
            handle::Ptr{GObject}
            function GInetAddressMaskLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetAddressMaskLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GInetAddressMask] = GInetAddressMaskLeaf
        (GLib.g_type(::Type{T}) where T <: GInetAddressMask) = begin
                ccall(("g_inet_address_mask_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GInetAddressMask})
            signalnames(supertype(GInetAddressMask))
        end
    end
    begin
        abstract type GSocketAddress <: GObject end
        mutable struct GSocketAddressLeaf <: GSocketAddress
            handle::Ptr{GObject}
            function GSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSocketAddress] = GSocketAddressLeaf
        (GLib.g_type(::Type{T}) where T <: GSocketAddress) = begin
                ccall(("g_socket_address_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSocketAddress})
            signalnames(supertype(GSocketAddress))
        end
    end
    begin
        abstract type GInetSocketAddress <: GSocketAddress end
        mutable struct GInetSocketAddressLeaf <: GInetSocketAddress
            handle::Ptr{GObject}
            function GInetSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetSocketAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GInetSocketAddress] = GInetSocketAddressLeaf
        (GLib.g_type(::Type{T}) where T <: GInetSocketAddress) = begin
                ccall(("g_inet_socket_address_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GInetSocketAddress})
            signalnames(supertype(GInetSocketAddress))
        end
    end
    begin
        abstract type GListStore <: GObject end
        mutable struct GListStoreLeaf <: GListStore
            handle::Ptr{GObject}
            function GListStoreLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GListStoreLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GListStore] = GListStoreLeaf
        (GLib.g_type(::Type{T}) where T <: GListStore) = begin
                ccall(("g_list_store_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GListStore})
            vcat([:items_changed], signalnames(supertype(GListStore)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GListStore
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GListStore
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GMemoryInputStream <: GInputStream end
        mutable struct GMemoryInputStreamLeaf <: GMemoryInputStream
            handle::Ptr{GObject}
            function GMemoryInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMemoryInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GMemoryInputStream] = GMemoryInputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GMemoryInputStream) = begin
                ccall(("g_memory_input_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GMemoryInputStream})
            signalnames(supertype(GMemoryInputStream))
        end
    end
    begin
        abstract type GMemoryOutputStream <: GOutputStream end
        mutable struct GMemoryOutputStreamLeaf <: GMemoryOutputStream
            handle::Ptr{GObject}
            function GMemoryOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMemoryOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GMemoryOutputStream] = GMemoryOutputStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GMemoryOutputStream) = begin
                ccall(("g_memory_output_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GMemoryOutputStream})
            signalnames(supertype(GMemoryOutputStream))
        end
    end
    begin
        abstract type GMenu <: GMenuModel end
        mutable struct GMenuLeaf <: GMenu
            handle::Ptr{GObject}
            function GMenuLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GMenu] = GMenuLeaf
        (GLib.g_type(::Type{T}) where T <: GMenu) = begin
                ccall(("g_menu_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GMenu})
            signalnames(supertype(GMenu))
        end
    end
    begin
        abstract type GMenuAttributeIter <: GObject end
        mutable struct GMenuAttributeIterLeaf <: GMenuAttributeIter
            handle::Ptr{GObject}
            function GMenuAttributeIterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuAttributeIterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GMenuAttributeIter] = GMenuAttributeIterLeaf
        (GLib.g_type(::Type{T}) where T <: GMenuAttributeIter) = begin
                ccall(("g_menu_attribute_iter_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GMenuAttributeIter})
            signalnames(supertype(GMenuAttributeIter))
        end
    end
    begin
        abstract type GMenuItem <: GObject end
        mutable struct GMenuItemLeaf <: GMenuItem
            handle::Ptr{GObject}
            function GMenuItemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuItemLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GMenuItem] = GMenuItemLeaf
        (GLib.g_type(::Type{T}) where T <: GMenuItem) = begin
                ccall(("g_menu_item_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GMenuItem})
            signalnames(supertype(GMenuItem))
        end
    end
    begin
        abstract type GMenuLinkIter <: GObject end
        mutable struct GMenuLinkIterLeaf <: GMenuLinkIter
            handle::Ptr{GObject}
            function GMenuLinkIterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuLinkIterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GMenuLinkIter] = GMenuLinkIterLeaf
        (GLib.g_type(::Type{T}) where T <: GMenuLinkIter) = begin
                ccall(("g_menu_link_iter_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GMenuLinkIter})
            signalnames(supertype(GMenuLinkIter))
        end
    end
    begin
        abstract type GMountOperation <: GObject end
        mutable struct GMountOperationLeaf <: GMountOperation
            handle::Ptr{GObject}
            function GMountOperationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMountOperationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GMountOperation] = GMountOperationLeaf
        (GLib.g_type(::Type{T}) where T <: GMountOperation) = begin
                ccall(("g_mount_operation_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GMountOperation})
            vcat([:aborted, :ask_password, :ask_question, :reply, :show_processes, :show_unmount_progress], signalnames(supertype(GMountOperation)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :show_unmount_progress => (:Nothing, [:Cstring, :Int64, :Int64]), :show_processes => (:Nothing, Any[:Cstring, :(Ptr{GArray}), :(Ptr{Cstring})]), :ask_password => (:Nothing, [:Cstring, :Cstring, :Cstring, :UInt32]), :aborted => (:Nothing, Any[]), :ask_question => (:Nothing, Any[:Cstring, :(Ptr{Cstring})]), :reply => (:Nothing, [:UInt32]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GMountOperation
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GMountOperation
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GNativeSocketAddress <: GSocketAddress end
        mutable struct GNativeSocketAddressLeaf <: GNativeSocketAddress
            handle::Ptr{GObject}
            function GNativeSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNativeSocketAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GNativeSocketAddress] = GNativeSocketAddressLeaf
        (GLib.g_type(::Type{T}) where T <: GNativeSocketAddress) = begin
                ccall(("g_native_socket_address_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GNativeSocketAddress})
            signalnames(supertype(GNativeSocketAddress))
        end
    end
    begin
        abstract type GVolumeMonitor <: GObject end
        mutable struct GVolumeMonitorLeaf <: GVolumeMonitor
            handle::Ptr{GObject}
            function GVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GVolumeMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GVolumeMonitor] = GVolumeMonitorLeaf
        (GLib.g_type(::Type{T}) where T <: GVolumeMonitor) = begin
                ccall(("g_volume_monitor_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GVolumeMonitor})
            vcat([:drive_changed, :drive_connected, :drive_disconnected, :drive_eject_button, :drive_stop_button, :mount_added, :mount_changed, :mount_pre_unmount, :mount_removed, :volume_added, :volume_changed, :volume_removed], signalnames(supertype(GVolumeMonitor)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :volume_added => (:Nothing, Expr[:(Ptr{GObject})]), :mount_removed => (:Nothing, Expr[:(Ptr{GObject})]), :volume_changed => (:Nothing, Expr[:(Ptr{GObject})]), :drive_disconnected => (:Nothing, Expr[:(Ptr{GObject})]), :volume_removed => (:Nothing, Expr[:(Ptr{GObject})]), :mount_pre_unmount => (:Nothing, Expr[:(Ptr{GObject})]), :drive_changed => (:Nothing, Expr[:(Ptr{GObject})]), :drive_stop_button => (:Nothing, Expr[:(Ptr{GObject})]), :mount_added => (:Nothing, Expr[:(Ptr{GObject})]), :drive_eject_button => (:Nothing, Expr[:(Ptr{GObject})]), :mount_changed => (:Nothing, Expr[:(Ptr{GObject})]), :drive_connected => (:Nothing, Expr[:(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GVolumeMonitor
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GVolumeMonitor
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GNativeVolumeMonitor <: GVolumeMonitor end
        mutable struct GNativeVolumeMonitorLeaf <: GNativeVolumeMonitor
            handle::Ptr{GObject}
            function GNativeVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNativeVolumeMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GNativeVolumeMonitor] = GNativeVolumeMonitorLeaf
        (GLib.g_type(::Type{T}) where T <: GNativeVolumeMonitor) = begin
                ccall(("g_native_volume_monitor_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GNativeVolumeMonitor})
            signalnames(supertype(GNativeVolumeMonitor))
        end
    end
    begin
        abstract type GNetworkAddress <: GObject end
        mutable struct GNetworkAddressLeaf <: GNetworkAddress
            handle::Ptr{GObject}
            function GNetworkAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNetworkAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GNetworkAddress] = GNetworkAddressLeaf
        (GLib.g_type(::Type{T}) where T <: GNetworkAddress) = begin
                ccall(("g_network_address_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GNetworkAddress})
            signalnames(supertype(GNetworkAddress))
        end
    end
    begin
        abstract type GNetworkService <: GObject end
        mutable struct GNetworkServiceLeaf <: GNetworkService
            handle::Ptr{GObject}
            function GNetworkServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNetworkServiceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GNetworkService] = GNetworkServiceLeaf
        (GLib.g_type(::Type{T}) where T <: GNetworkService) = begin
                ccall(("g_network_service_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GNetworkService})
            signalnames(supertype(GNetworkService))
        end
    end
    begin
        abstract type GNotification <: GObject end
        mutable struct GNotificationLeaf <: GNotification
            handle::Ptr{GObject}
            function GNotificationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNotificationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GNotification] = GNotificationLeaf
        (GLib.g_type(::Type{T}) where T <: GNotification) = begin
                ccall(("g_notification_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GNotification})
            signalnames(supertype(GNotification))
        end
    end
    begin
        abstract type GPermission <: GObject end
        mutable struct GPermissionLeaf <: GPermission
            handle::Ptr{GObject}
            function GPermissionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GPermissionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GPermission] = GPermissionLeaf
        (GLib.g_type(::Type{T}) where T <: GPermission) = begin
                ccall(("g_permission_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GPermission})
            signalnames(supertype(GPermission))
        end
    end
    begin
        abstract type GPropertyAction <: GObject end
        mutable struct GPropertyActionLeaf <: GPropertyAction
            handle::Ptr{GObject}
            function GPropertyActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GPropertyActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GPropertyAction] = GPropertyActionLeaf
        (GLib.g_type(::Type{T}) where T <: GPropertyAction) = begin
                ccall(("g_property_action_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GPropertyAction})
            signalnames(supertype(GPropertyAction))
        end
    end
    begin
        abstract type GProxyAddress <: GInetSocketAddress end
        mutable struct GProxyAddressLeaf <: GProxyAddress
            handle::Ptr{GObject}
            function GProxyAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GProxyAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GProxyAddress] = GProxyAddressLeaf
        (GLib.g_type(::Type{T}) where T <: GProxyAddress) = begin
                ccall(("g_proxy_address_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GProxyAddress})
            signalnames(supertype(GProxyAddress))
        end
    end
    begin
        abstract type GSocketAddressEnumerator <: GObject end
        mutable struct GSocketAddressEnumeratorLeaf <: GSocketAddressEnumerator
            handle::Ptr{GObject}
            function GSocketAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketAddressEnumeratorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSocketAddressEnumerator] = GSocketAddressEnumeratorLeaf
        (GLib.g_type(::Type{T}) where T <: GSocketAddressEnumerator) = begin
                ccall(("g_socket_address_enumerator_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSocketAddressEnumerator})
            signalnames(supertype(GSocketAddressEnumerator))
        end
    end
    begin
        abstract type GProxyAddressEnumerator <: GSocketAddressEnumerator end
        mutable struct GProxyAddressEnumeratorLeaf <: GProxyAddressEnumerator
            handle::Ptr{GObject}
            function GProxyAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GProxyAddressEnumeratorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GProxyAddressEnumerator] = GProxyAddressEnumeratorLeaf
        (GLib.g_type(::Type{T}) where T <: GProxyAddressEnumerator) = begin
                ccall(("g_proxy_address_enumerator_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GProxyAddressEnumerator})
            signalnames(supertype(GProxyAddressEnumerator))
        end
    end
    begin
        abstract type GResolver <: GObject end
        mutable struct GResolverLeaf <: GResolver
            handle::Ptr{GObject}
            function GResolverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GResolverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GResolver] = GResolverLeaf
        (GLib.g_type(::Type{T}) where T <: GResolver) = begin
                ccall(("g_resolver_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GResolver})
            vcat([:reload], signalnames(supertype(GResolver)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :reload => (:Nothing, Any[]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GResolver
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GResolver
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GSettings <: GObject end
        mutable struct GSettingsLeaf <: GSettings
            handle::Ptr{GObject}
            function GSettingsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSettingsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSettings] = GSettingsLeaf
        (GLib.g_type(::Type{T}) where T <: GSettings) = begin
                ccall(("g_settings_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSettings})
            vcat([:change_event, :changed, :writable_change_event, :writable_changed], signalnames(supertype(GSettings)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :change_event => (:Cint, Any[:(Ptr{UInt32}), :Int32]), :changed => (:Nothing, [:Cstring]), :writable_change_event => (:Cint, [:UInt32]), :writable_changed => (:Nothing, [:Cstring]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSettings
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSettings
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GSettingsBackend <: GObject end
        mutable struct GSettingsBackendLeaf <: GSettingsBackend
            handle::Ptr{GObject}
            function GSettingsBackendLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSettingsBackendLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSettingsBackend] = GSettingsBackendLeaf
        (GLib.g_type(::Type{T}) where T <: GSettingsBackend) = begin
                ccall(("g_settings_backend_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSettingsBackend})
            signalnames(supertype(GSettingsBackend))
        end
    end
    begin
        abstract type GSimpleAction <: GObject end
        mutable struct GSimpleActionLeaf <: GSimpleAction
            handle::Ptr{GObject}
            function GSimpleActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSimpleAction] = GSimpleActionLeaf
        (GLib.g_type(::Type{T}) where T <: GSimpleAction) = begin
                ccall(("g_simple_action_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSimpleAction})
            vcat([:activate, :change_state], signalnames(supertype(GSimpleAction)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :change_state => (:Nothing, [:GVariant]), :activate => (:Nothing, [:GVariant]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSimpleAction
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSimpleAction
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GSimpleActionGroup <: GObject end
        mutable struct GSimpleActionGroupLeaf <: GSimpleActionGroup
            handle::Ptr{GObject}
            function GSimpleActionGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleActionGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSimpleActionGroup] = GSimpleActionGroupLeaf
        (GLib.g_type(::Type{T}) where T <: GSimpleActionGroup) = begin
                ccall(("g_simple_action_group_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSimpleActionGroup})
            vcat([:action_added, :action_enabled_changed, :action_removed, :action_state_changed], signalnames(supertype(GSimpleActionGroup)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSimpleActionGroup
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSimpleActionGroup
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GSimpleAsyncResult <: GObject end
        mutable struct GSimpleAsyncResultLeaf <: GSimpleAsyncResult
            handle::Ptr{GObject}
            function GSimpleAsyncResultLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleAsyncResultLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSimpleAsyncResult] = GSimpleAsyncResultLeaf
        (GLib.g_type(::Type{T}) where T <: GSimpleAsyncResult) = begin
                ccall(("g_simple_async_result_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSimpleAsyncResult})
            signalnames(supertype(GSimpleAsyncResult))
        end
    end
    begin
        abstract type GSimpleIOStream <: GIOStream end
        mutable struct GSimpleIOStreamLeaf <: GSimpleIOStream
            handle::Ptr{GObject}
            function GSimpleIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleIOStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSimpleIOStream] = GSimpleIOStreamLeaf
        (GLib.g_type(::Type{T}) where T <: GSimpleIOStream) = begin
                ccall(("g_simple_io_stream_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSimpleIOStream})
            signalnames(supertype(GSimpleIOStream))
        end
    end
    begin
        abstract type GSimplePermission <: GPermission end
        mutable struct GSimplePermissionLeaf <: GSimplePermission
            handle::Ptr{GObject}
            function GSimplePermissionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimplePermissionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSimplePermission] = GSimplePermissionLeaf
        (GLib.g_type(::Type{T}) where T <: GSimplePermission) = begin
                ccall(("g_simple_permission_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSimplePermission})
            signalnames(supertype(GSimplePermission))
        end
    end
    begin
        abstract type GSimpleProxyResolver <: GObject end
        mutable struct GSimpleProxyResolverLeaf <: GSimpleProxyResolver
            handle::Ptr{GObject}
            function GSimpleProxyResolverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleProxyResolverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSimpleProxyResolver] = GSimpleProxyResolverLeaf
        (GLib.g_type(::Type{T}) where T <: GSimpleProxyResolver) = begin
                ccall(("g_simple_proxy_resolver_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSimpleProxyResolver})
            signalnames(supertype(GSimpleProxyResolver))
        end
    end
    begin
        abstract type GSocket <: GObject end
        mutable struct GSocketLeaf <: GSocket
            handle::Ptr{GObject}
            function GSocketLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSocket] = GSocketLeaf
        (GLib.g_type(::Type{T}) where T <: GSocket) = begin
                ccall(("g_socket_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSocket})
            signalnames(supertype(GSocket))
        end
    end
    begin
        abstract type GSocketClient <: GObject end
        mutable struct GSocketClientLeaf <: GSocketClient
            handle::Ptr{GObject}
            function GSocketClientLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketClientLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSocketClient] = GSocketClientLeaf
        (GLib.g_type(::Type{T}) where T <: GSocketClient) = begin
                ccall(("g_socket_client_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSocketClient})
            vcat([:event], signalnames(supertype(GSocketClient)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Nothing, Any[:UInt32, :(Ptr{GObject}), :(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSocketClient
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSocketClient
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GSocketConnection <: GIOStream end
        mutable struct GSocketConnectionLeaf <: GSocketConnection
            handle::Ptr{GObject}
            function GSocketConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSocketConnection] = GSocketConnectionLeaf
        (GLib.g_type(::Type{T}) where T <: GSocketConnection) = begin
                ccall(("g_socket_connection_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSocketConnection})
            signalnames(supertype(GSocketConnection))
        end
    end
    begin
        abstract type GSocketControlMessage <: GObject end
        mutable struct GSocketControlMessageLeaf <: GSocketControlMessage
            handle::Ptr{GObject}
            function GSocketControlMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketControlMessageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSocketControlMessage] = GSocketControlMessageLeaf
        (GLib.g_type(::Type{T}) where T <: GSocketControlMessage) = begin
                ccall(("g_socket_control_message_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSocketControlMessage})
            signalnames(supertype(GSocketControlMessage))
        end
    end
    begin
        abstract type GSocketListener <: GObject end
        mutable struct GSocketListenerLeaf <: GSocketListener
            handle::Ptr{GObject}
            function GSocketListenerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketListenerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSocketListener] = GSocketListenerLeaf
        (GLib.g_type(::Type{T}) where T <: GSocketListener) = begin
                ccall(("g_socket_listener_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSocketListener})
            vcat([:event], signalnames(supertype(GSocketListener)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Nothing, Any[:UInt32, :(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSocketListener
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSocketListener
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GSocketService <: GSocketListener end
        mutable struct GSocketServiceLeaf <: GSocketService
            handle::Ptr{GObject}
            function GSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketServiceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSocketService] = GSocketServiceLeaf
        (GLib.g_type(::Type{T}) where T <: GSocketService) = begin
                ccall(("g_socket_service_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSocketService})
            vcat([:incoming], signalnames(supertype(GSocketService)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Nothing, Any[:UInt32, :(Ptr{GObject})]), :incoming => (:Cint, Expr[:(Ptr{GObject}), :(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSocketService
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSocketService
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GSubprocess <: GObject end
        mutable struct GSubprocessLeaf <: GSubprocess
            handle::Ptr{GObject}
            function GSubprocessLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSubprocessLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSubprocess] = GSubprocessLeaf
        (GLib.g_type(::Type{T}) where T <: GSubprocess) = begin
                ccall(("g_subprocess_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSubprocess})
            signalnames(supertype(GSubprocess))
        end
    end
    begin
        abstract type GSubprocessLauncher <: GObject end
        mutable struct GSubprocessLauncherLeaf <: GSubprocessLauncher
            handle::Ptr{GObject}
            function GSubprocessLauncherLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSubprocessLauncherLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GSubprocessLauncher] = GSubprocessLauncherLeaf
        (GLib.g_type(::Type{T}) where T <: GSubprocessLauncher) = begin
                ccall(("g_subprocess_launcher_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GSubprocessLauncher})
            signalnames(supertype(GSubprocessLauncher))
        end
    end
    begin
        abstract type GTask <: GObject end
        mutable struct GTaskLeaf <: GTask
            handle::Ptr{GObject}
            function GTaskLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTaskLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTask] = GTaskLeaf
        (GLib.g_type(::Type{T}) where T <: GTask) = begin
                ccall(("g_task_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GTask})
            signalnames(supertype(GTask))
        end
    end
    begin
        abstract type GTcpConnection <: GSocketConnection end
        mutable struct GTcpConnectionLeaf <: GTcpConnection
            handle::Ptr{GObject}
            function GTcpConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTcpConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTcpConnection] = GTcpConnectionLeaf
        (GLib.g_type(::Type{T}) where T <: GTcpConnection) = begin
                ccall(("g_tcp_connection_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GTcpConnection})
            signalnames(supertype(GTcpConnection))
        end
    end
    begin
        abstract type GTcpWrapperConnection <: GTcpConnection end
        mutable struct GTcpWrapperConnectionLeaf <: GTcpWrapperConnection
            handle::Ptr{GObject}
            function GTcpWrapperConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTcpWrapperConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTcpWrapperConnection] = GTcpWrapperConnectionLeaf
        (GLib.g_type(::Type{T}) where T <: GTcpWrapperConnection) = begin
                ccall(("g_tcp_wrapper_connection_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GTcpWrapperConnection})
            signalnames(supertype(GTcpWrapperConnection))
        end
    end
    begin
        abstract type GTestDBus <: GObject end
        mutable struct GTestDBusLeaf <: GTestDBus
            handle::Ptr{GObject}
            function GTestDBusLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTestDBusLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTestDBus] = GTestDBusLeaf
        (GLib.g_type(::Type{T}) where T <: GTestDBus) = begin
                ccall(("g_test_dbus_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GTestDBus})
            signalnames(supertype(GTestDBus))
        end
    end
    begin
        abstract type GThemedIcon <: GObject end
        mutable struct GThemedIconLeaf <: GThemedIcon
            handle::Ptr{GObject}
            function GThemedIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GThemedIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GThemedIcon] = GThemedIconLeaf
        (GLib.g_type(::Type{T}) where T <: GThemedIcon) = begin
                ccall(("g_themed_icon_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GThemedIcon})
            signalnames(supertype(GThemedIcon))
        end
    end
    begin
        abstract type GThreadedResolver <: GResolver end
        mutable struct GThreadedResolverLeaf <: GThreadedResolver
            handle::Ptr{GObject}
            function GThreadedResolverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GThreadedResolverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GThreadedResolver] = GThreadedResolverLeaf
        (GLib.g_type(::Type{T}) where T <: GThreadedResolver) = begin
                ccall(("g_threaded_resolver_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GThreadedResolver})
            signalnames(supertype(GThreadedResolver))
        end
    end
    begin
        abstract type GThreadedSocketService <: GSocketService end
        mutable struct GThreadedSocketServiceLeaf <: GThreadedSocketService
            handle::Ptr{GObject}
            function GThreadedSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GThreadedSocketServiceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GThreadedSocketService] = GThreadedSocketServiceLeaf
        (GLib.g_type(::Type{T}) where T <: GThreadedSocketService) = begin
                ccall(("g_threaded_socket_service_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GThreadedSocketService})
            vcat([:run], signalnames(supertype(GThreadedSocketService)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Nothing, Any[:UInt32, :(Ptr{GObject})]), :run => (:Cint, Expr[:(Ptr{GObject}), :(Ptr{GObject})]), :incoming => (:Cint, Expr[:(Ptr{GObject}), :(Ptr{GObject})]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GThreadedSocketService
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GThreadedSocketService
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GTlsCertificate <: GObject end
        mutable struct GTlsCertificateLeaf <: GTlsCertificate
            handle::Ptr{GObject}
            function GTlsCertificateLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsCertificateLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTlsCertificate] = GTlsCertificateLeaf
        (GLib.g_type(::Type{T}) where T <: GTlsCertificate) = begin
                ccall(("g_tls_certificate_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GTlsCertificate})
            signalnames(supertype(GTlsCertificate))
        end
    end
    begin
        abstract type GTlsConnection <: GIOStream end
        mutable struct GTlsConnectionLeaf <: GTlsConnection
            handle::Ptr{GObject}
            function GTlsConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTlsConnection] = GTlsConnectionLeaf
        (GLib.g_type(::Type{T}) where T <: GTlsConnection) = begin
                ccall(("g_tls_connection_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GTlsConnection})
            vcat([:accept_certificate], signalnames(supertype(GTlsConnection)))
        end
        let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :accept_certificate => (:Cint, Any[:(Ptr{GObject}), :UInt32]))
            function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GTlsConnection
                eval((d[name])[1])
            end
            function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GTlsConnection
                Tuple(eval.((d[name])[2]))
            end
        end
    end
    begin
        abstract type GTlsDatabase <: GObject end
        mutable struct GTlsDatabaseLeaf <: GTlsDatabase
            handle::Ptr{GObject}
            function GTlsDatabaseLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsDatabaseLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTlsDatabase] = GTlsDatabaseLeaf
        (GLib.g_type(::Type{T}) where T <: GTlsDatabase) = begin
                ccall(("g_tls_database_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GTlsDatabase})
            signalnames(supertype(GTlsDatabase))
        end
    end
    begin
        abstract type GTlsInteraction <: GObject end
        mutable struct GTlsInteractionLeaf <: GTlsInteraction
            handle::Ptr{GObject}
            function GTlsInteractionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsInteractionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTlsInteraction] = GTlsInteractionLeaf
        (GLib.g_type(::Type{T}) where T <: GTlsInteraction) = begin
                ccall(("g_tls_interaction_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GTlsInteraction})
            signalnames(supertype(GTlsInteraction))
        end
    end
    begin
        abstract type GTlsPassword <: GObject end
        mutable struct GTlsPasswordLeaf <: GTlsPassword
            handle::Ptr{GObject}
            function GTlsPasswordLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsPasswordLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTlsPassword] = GTlsPasswordLeaf
        (GLib.g_type(::Type{T}) where T <: GTlsPassword) = begin
                ccall(("g_tls_password_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GTlsPassword})
            signalnames(supertype(GTlsPassword))
        end
    end
    begin
        abstract type GUnixConnection <: GSocketConnection end
        mutable struct GUnixConnectionLeaf <: GUnixConnection
            handle::Ptr{GObject}
            function GUnixConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GUnixConnection] = GUnixConnectionLeaf
        (GLib.g_type(::Type{T}) where T <: GUnixConnection) = begin
                ccall(("g_unix_connection_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GUnixConnection})
            signalnames(supertype(GUnixConnection))
        end
    end
    begin
        abstract type GUnixCredentialsMessage <: GSocketControlMessage end
        mutable struct GUnixCredentialsMessageLeaf <: GUnixCredentialsMessage
            handle::Ptr{GObject}
            function GUnixCredentialsMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixCredentialsMessageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GUnixCredentialsMessage] = GUnixCredentialsMessageLeaf
        (GLib.g_type(::Type{T}) where T <: GUnixCredentialsMessage) = begin
                ccall(("g_unix_credentials_message_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GUnixCredentialsMessage})
            signalnames(supertype(GUnixCredentialsMessage))
        end
    end
    begin
        abstract type GVfs <: GObject end
        mutable struct GVfsLeaf <: GVfs
            handle::Ptr{GObject}
            function GVfsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GVfsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GVfs] = GVfsLeaf
        (GLib.g_type(::Type{T}) where T <: GVfs) = begin
                ccall(("g_vfs_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GVfs})
            signalnames(supertype(GVfs))
        end
    end
    begin
        abstract type GZlibCompressor <: GObject end
        mutable struct GZlibCompressorLeaf <: GZlibCompressor
            handle::Ptr{GObject}
            function GZlibCompressorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GZlibCompressorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GZlibCompressor] = GZlibCompressorLeaf
        (GLib.g_type(::Type{T}) where T <: GZlibCompressor) = begin
                ccall(("g_zlib_compressor_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GZlibCompressor})
            signalnames(supertype(GZlibCompressor))
        end
    end
    begin
        abstract type GZlibDecompressor <: GObject end
        mutable struct GZlibDecompressorLeaf <: GZlibDecompressor
            handle::Ptr{GObject}
            function GZlibDecompressorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GZlibDecompressorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GZlibDecompressor] = GZlibDecompressorLeaf
        (GLib.g_type(::Type{T}) where T <: GZlibDecompressor) = begin
                ccall(("g_zlib_decompressor_get_type", libgio), GType, ())
            end
    end
    begin
        function GLib.signalnames(::Type{GZlibDecompressor})
            signalnames(supertype(GZlibDecompressor))
        end
    end
    function GAppLaunchContext()
        G_.AppLaunchContext_new()
    end
    function GApplication(_application_id::Maybe(Union{AbstractString, Symbol}), _flags; kwargs...)
        obj = G_.Application_new(_application_id, _flags)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBufferedInputStream(_base_stream::GInputStream; kwargs...)
        obj = G_.BufferedInputStream_new(_base_stream)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBufferedInputStream(_base_stream::GInputStream, _size::Integer; kwargs...)
        obj = G_.BufferedInputStream_new_sized(_base_stream, _size)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBufferedOutputStream(_base_stream::GOutputStream; kwargs...)
        obj = G_.BufferedOutputStream_new(_base_stream)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBufferedOutputStream(_base_stream::GOutputStream, _size::Integer; kwargs...)
        obj = G_.BufferedOutputStream_new_sized(_base_stream, _size)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBytesIcon(_bytes::GBytes; kwargs...)
        obj = G_.BytesIcon_new(_bytes)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GCancellable()
        G_.Cancellable_new()
    end
    function GCharsetConverter(_to_charset::Union{AbstractString, Symbol}, _from_charset::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.CharsetConverter_new(_to_charset, _from_charset)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GConverterInputStream(_base_stream::GInputStream, _converter::GConverter; kwargs...)
        obj = G_.ConverterInputStream_new(_base_stream, _converter)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GConverterOutputStream(_base_stream::GOutputStream, _converter::GConverter; kwargs...)
        obj = G_.ConverterOutputStream_new(_base_stream, _converter)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GCredentials()
        G_.Credentials_new()
    end
    function GDBusAuthObserver()
        G_.DBusAuthObserver_new()
    end
    function GDBusConnection(_res::GAsyncResult; kwargs...)
        obj = G_.DBusConnection_new_finish(_res)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusConnection(_address::Union{AbstractString, Symbol}, _flags, _observer::Maybe(GDBusAuthObserver), _cancellable::Maybe(GCancellable); kwargs...)
        obj = G_.DBusConnection_new_for_address_sync(_address, _flags, _observer, _cancellable)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusMessage(; kwargs...)
        obj = G_.DBusMessage_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusMessage(_blob, _capabilities; kwargs...)
        obj = G_.DBusMessage_new_from_blob(_blob, _capabilities)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusMessage(_name::Maybe(Union{AbstractString, Symbol}), _path::Union{AbstractString, Symbol}, _interface_::Maybe(Union{AbstractString, Symbol}), _method::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DBusMessage_new_method_call(_name, _path, _interface_, _method)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusMessage(_path::Union{AbstractString, Symbol}, _interface_::Union{AbstractString, Symbol}, _signal::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DBusMessage_new_signal(_path, _interface_, _signal)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusObjectManagerClient(_res::GAsyncResult; kwargs...)
        obj = G_.DBusObjectManagerClient_new_finish(_res)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusObjectManagerServer(_object_path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DBusObjectManagerServer_new(_object_path)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusObjectProxy(_connection::GDBusConnection, _object_path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DBusObjectProxy_new(_connection, _object_path)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusObjectSkeleton(_object_path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DBusObjectSkeleton_new(_object_path)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusProxy(_res::GAsyncResult; kwargs...)
        obj = G_.DBusProxy_new_finish(_res)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDataInputStream(_base_stream::GInputStream; kwargs...)
        obj = G_.DataInputStream_new(_base_stream)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDataOutputStream(_base_stream::GOutputStream; kwargs...)
        obj = G_.DataOutputStream_new(_base_stream)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDesktopAppInfo(_desktop_id::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DesktopAppInfo_new(_desktop_id)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDesktopAppInfo(_key_file::GKeyFile; kwargs...)
        obj = G_.DesktopAppInfo_new_from_keyfile(_key_file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GEmblem(_icon::GIcon; kwargs...)
        obj = G_.Emblem_new(_icon)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GEmblem(_icon::GIcon, _origin; kwargs...)
        obj = G_.Emblem_new_with_origin(_icon, _origin)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GEmblemedIcon(_icon::GIcon, _emblem::Maybe(GEmblem); kwargs...)
        obj = G_.EmblemedIcon_new(_icon, _emblem)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GFileIcon(_file::GFile; kwargs...)
        obj = G_.FileIcon_new(_file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GFileInfo()
        G_.FileInfo_new()
    end
    function GFilenameCompleter()
        G_.FilenameCompleter_new()
    end
    function GIOModule(_filename::Union{AbstractString, Symbol})
        G_.IOModule_new(_filename)
    end
    function GInetAddress(_family; kwargs...)
        obj = G_.InetAddress_new_any(_family)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetAddress(_bytes, _family; kwargs...)
        obj = G_.InetAddress_new_from_bytes(_bytes, _family)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetAddress(_string::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.InetAddress_new_from_string(_string)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetAddressMask(_addr::GInetAddress, _length::Integer; kwargs...)
        obj = G_.InetAddressMask_new(_addr, _length)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetAddressMask(_mask_string::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.InetAddressMask_new_from_string(_mask_string)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetSocketAddress(_address::GInetAddress, _port::Integer; kwargs...)
        obj = G_.InetSocketAddress_new(_address, _port)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetSocketAddress(_address::Union{AbstractString, Symbol}, _port::Integer; kwargs...)
        obj = G_.InetSocketAddress_new_from_string(_address, _port)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GListStore(_item_type::Integer; kwargs...)
        obj = G_.ListStore_new(_item_type)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GMemoryInputStream()
        G_.MemoryInputStream_new()
    end
    function GMemoryInputStream(_bytes::GBytes)
        G_.MemoryInputStream_new_from_bytes(_bytes)
    end
    function GMemoryInputStream(_data, _destroy::Maybe(Function))
        G_.MemoryInputStream_new_from_data(_data, _destroy)
    end
    function GMemoryOutputStream(; kwargs...)
        obj = G_.MemoryOutputStream_new_resizable()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GMenu()
        G_.Menu_new()
    end
    function GMenuItem(_label::Maybe(Union{AbstractString, Symbol}), _detailed_action::Maybe(Union{AbstractString, Symbol}))
        G_.MenuItem_new(_label, _detailed_action)
    end
    function GMenuItem(_model::GMenuModel, _item_index::Integer)
        G_.MenuItem_new_from_model(_model, _item_index)
    end
    function GMenuItem(_label::Maybe(Union{AbstractString, Symbol}), _submenu::GMenuModel)
        G_.MenuItem_new_submenu(_label, _submenu)
    end
    function GMountOperation(; kwargs...)
        obj = G_.MountOperation_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GNativeSocketAddress(_native::Maybe(Nothing), _len::Integer)
        G_.NativeSocketAddress_new(_native, _len)
    end
    function GNetworkAddress(_hostname::Union{AbstractString, Symbol}, _port::Integer; kwargs...)
        obj = G_.NetworkAddress_new(_hostname, _port)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GNetworkService(_service::Union{AbstractString, Symbol}, _protocol::Union{AbstractString, Symbol}, _domain::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.NetworkService_new(_service, _protocol, _domain)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GNotification(_title::Union{AbstractString, Symbol})
        G_.Notification_new(_title)
    end
    function GPropertyAction(_name::Union{AbstractString, Symbol}, _object::GObject, _property_name::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.PropertyAction_new(_name, _object, _property_name)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GProxyAddress(_inetaddr::GInetAddress, _port::Integer, _protocol::Union{AbstractString, Symbol}, _dest_hostname::Union{AbstractString, Symbol}, _dest_port::Integer, _username::Maybe(Union{AbstractString, Symbol}), _password::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.ProxyAddress_new(_inetaddr, _port, _protocol, _dest_hostname, _dest_port, _username, _password)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema_id::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Settings_new(_schema_id)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema::GSettingsSchema, _backend::Maybe(GSettingsBackend), _path::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.Settings_new_full(_schema, _backend, _path)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema_id::Union{AbstractString, Symbol}, _backend::GSettingsBackend; kwargs...)
        obj = G_.Settings_new_with_backend(_schema_id, _backend)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema_id::Union{AbstractString, Symbol}, _backend::GSettingsBackend, _path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Settings_new_with_backend_and_path(_schema_id, _backend, _path)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema_id::Union{AbstractString, Symbol}, _path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Settings_new_with_path(_schema_id, _path)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSimpleAction(_name::Union{AbstractString, Symbol}, _parameter_type::Maybe(GVariantType); kwargs...)
        obj = G_.SimpleAction_new(_name, _parameter_type)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSimpleAction(_name::Union{AbstractString, Symbol}, _parameter_type::Maybe(GVariantType), _state::GVariant; kwargs...)
        obj = G_.SimpleAction_new_stateful(_name, _parameter_type, _state)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSimpleActionGroup()
        G_.SimpleActionGroup_new()
    end
    function GSimpleIOStream(_input_stream::GInputStream, _output_stream::GOutputStream; kwargs...)
        obj = G_.SimpleIOStream_new(_input_stream, _output_stream)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSimplePermission(_allowed::Bool)
        G_.SimplePermission_new(_allowed)
    end
    function GSocket(_family, _type, _protocol; kwargs...)
        obj = G_.Socket_new(_family, _type, _protocol)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocket(_fd::Integer; kwargs...)
        obj = G_.Socket_new_from_fd(_fd)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocketAddress(_native::Nothing, _len::Integer; kwargs...)
        obj = G_.SocketAddress_new_from_native(_native, _len)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocketClient(; kwargs...)
        obj = G_.SocketClient_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocketListener(; kwargs...)
        obj = G_.SocketListener_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocketService(; kwargs...)
        obj = G_.SocketService_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSubprocess(_argv, _flags; kwargs...)
        obj = G_.Subprocess_new(_argv, _flags)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSubprocessLauncher(_flags; kwargs...)
        obj = G_.SubprocessLauncher_new(_flags)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTask(_source_object::Maybe(GObject), _cancellable::Maybe(GCancellable), _callback::Maybe(Function); kwargs...)
        obj = G_.Task_new(_source_object, _cancellable, _callback)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTcpWrapperConnection(_base_io_stream::GIOStream, _socket::GSocket; kwargs...)
        obj = G_.TcpWrapperConnection_new(_base_io_stream, _socket)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTestDBus(_flags; kwargs...)
        obj = G_.TestDBus_new(_flags)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GThemedIcon(_iconname::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.ThemedIcon_new(_iconname)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GThemedIcon(_iconnames; kwargs...)
        obj = G_.ThemedIcon_new_from_names(_iconnames)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GThreadedSocketService(_max_threads::Integer; kwargs...)
        obj = G_.ThreadedSocketService_new(_max_threads)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_file::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.TlsCertificate_new_from_file(_file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_cert_file::Union{AbstractString, Symbol}, _key_file::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.TlsCertificate_new_from_files(_cert_file, _key_file)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_data::Union{AbstractString, Symbol}, _length::Integer; kwargs...)
        obj = G_.TlsCertificate_new_from_pem(_data, _length)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_pkcs11_uri::Union{AbstractString, Symbol}, _private_key_pkcs11_uri::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.TlsCertificate_new_from_pkcs11_uris(_pkcs11_uri, _private_key_pkcs11_uri)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_data, _password::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.TlsCertificate_new_from_pkcs12(_data, _password)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsPassword(_flags, _description::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.TlsPassword_new(_flags, _description)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GUnixCredentialsMessage(; kwargs...)
        obj = G_.UnixCredentialsMessage_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GUnixCredentialsMessage(_credentials::GCredentials; kwargs...)
        obj = G_.UnixCredentialsMessage_new_with_credentials(_credentials)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GZlibCompressor(_format, _level::Integer; kwargs...)
        obj = G_.ZlibCompressor_new(_format, _level)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GZlibDecompressor(_format; kwargs...)
        obj = G_.ZlibDecompressor_new(_format)
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.AppInfoMonitor.html)." GAppInfoMonitor
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.AppLaunchContext.html)." GAppLaunchContext
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Application.html)." GApplication
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ApplicationCommandLine.html)." GApplicationCommandLine
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.BufferedInputStream.html)." GBufferedInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.BufferedOutputStream.html)." GBufferedOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.BytesIcon.html)." GBytesIcon
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Cancellable.html)." GCancellable
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.CharsetConverter.html)." GCharsetConverter
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ConverterInputStream.html)." GConverterInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ConverterOutputStream.html)." GConverterOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Credentials.html)." GCredentials
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusActionGroup.html)." GDBusActionGroup
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusAuthObserver.html)." GDBusAuthObserver
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusConnection.html)." GDBusConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusInterfaceSkeleton.html)." GDBusInterfaceSkeleton
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusMenuModel.html)." GDBusMenuModel
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusMessage.html)." GDBusMessage
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusMethodInvocation.html)." GDBusMethodInvocation
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectManagerClient.html)." GDBusObjectManagerClient
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectManagerServer.html)." GDBusObjectManagerServer
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectProxy.html)." GDBusObjectProxy
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectSkeleton.html)." GDBusObjectSkeleton
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusProxy.html)." GDBusProxy
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusServer.html)." GDBusServer
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DataInputStream.html)." GDataInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DataOutputStream.html)." GDataOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DesktopAppInfo.html)." GDesktopAppInfo
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Emblem.html)." GEmblem
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.EmblemedIcon.html)." GEmblemedIcon
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileEnumerator.html)." GFileEnumerator
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileIOStream.html)." GFileIOStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileIcon.html)." GFileIcon
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileInfo.html)." GFileInfo
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileInputStream.html)." GFileInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileMonitor.html)." GFileMonitor
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileOutputStream.html)." GFileOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FilenameCompleter.html)." GFilenameCompleter
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FilterInputStream.html)." GFilterInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FilterOutputStream.html)." GFilterOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.IOModule.html)." GIOModule
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.IOStream.html)." GIOStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.InetAddress.html)." GInetAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.InetAddressMask.html)." GInetAddressMask
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.InetSocketAddress.html)." GInetSocketAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.InputStream.html)." GInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ListStore.html)." GListStore
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MemoryInputStream.html)." GMemoryInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MemoryOutputStream.html)." GMemoryOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Menu.html)." GMenu
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MenuAttributeIter.html)." GMenuAttributeIter
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MenuItem.html)." GMenuItem
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MenuLinkIter.html)." GMenuLinkIter
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MenuModel.html)." GMenuModel
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MountOperation.html)." GMountOperation
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.NativeSocketAddress.html)." GNativeSocketAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.NetworkAddress.html)." GNetworkAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.NetworkService.html)." GNetworkService
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Notification.html)." GNotification
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.OutputStream.html)." GOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Permission.html)." GPermission
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.PropertyAction.html)." GPropertyAction
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ProxyAddress.html)." GProxyAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ProxyAddressEnumerator.html)." GProxyAddressEnumerator
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Resolver.html)." GResolver
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Settings.html)." GSettings
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SettingsBackend.html)." GSettingsBackend
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleAction.html)." GSimpleAction
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleActionGroup.html)." GSimpleActionGroup
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleAsyncResult.html)." GSimpleAsyncResult
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleIOStream.html)." GSimpleIOStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimplePermission.html)." GSimplePermission
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleProxyResolver.html)." GSimpleProxyResolver
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Socket.html)." GSocket
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketAddress.html)." GSocketAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketAddressEnumerator.html)." GSocketAddressEnumerator
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketClient.html)." GSocketClient
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketConnection.html)." GSocketConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketControlMessage.html)." GSocketControlMessage
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketListener.html)." GSocketListener
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketService.html)." GSocketService
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Subprocess.html)." GSubprocess
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SubprocessLauncher.html)." GSubprocessLauncher
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Task.html)." GTask
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TcpConnection.html)." GTcpConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TcpWrapperConnection.html)." GTcpWrapperConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TestDBus.html)." GTestDBus
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ThemedIcon.html)." GThemedIcon
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ThreadedResolver.html)." GThreadedResolver
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ThreadedSocketService.html)." GThreadedSocketService
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsCertificate.html)." GTlsCertificate
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsConnection.html)." GTlsConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsDatabase.html)." GTlsDatabase
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsInteraction.html)." GTlsInteraction
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsPassword.html)." GTlsPassword
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.UnixConnection.html)." GUnixConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.UnixCredentialsMessage.html)." GUnixCredentialsMessage
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Vfs.html)." GVfs
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.VolumeMonitor.html)." GVolumeMonitor
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ZlibCompressor.html)." GZlibCompressor
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ZlibDecompressor.html)." GZlibDecompressor
    function GAsyncReadyCallback(source_object, res, data)
        source_object = convert_if_not_null(GObject, source_object, false)
        res = begin
                leaftype = GLib.find_leaf_type(res)
                convert(leaftype, res, false)
            end
        f = data
        ret = f(source_object, res)
        nothing
    end
    function GBusAcquiredCallback(connection, name, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        f = user_data
        ret = f(connection, name)
        nothing
    end
    function GBusNameAcquiredCallback(connection, name, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        f = user_data
        ret = f(connection, name)
        nothing
    end
    function GBusNameAppearedCallback(connection, name, name_owner, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        name_owner = string_or_nothing(name_owner, false)
        f = user_data
        ret = f(connection, name, name_owner)
        nothing
    end
    function GBusNameLostCallback(connection, name, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        f = user_data
        ret = f(connection, name)
        nothing
    end
    function GBusNameVanishedCallback(connection, name, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        f = user_data
        ret = f(connection, name)
        nothing
    end
    function GCancellableSourceFunc(cancellable, data)
        cancellable = convert_if_not_null(GCancellable, cancellable, false)
        f = data
        ret = f(cancellable)
        convert(Cint, ret)
    end
    function GDBusInterfaceGetPropertyFunc(connection, sender, object_path, interface_name, property_name, error, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        property_name = string_or_nothing(property_name, false)
        f = user_data
        ret = f(connection, sender, object_path, interface_name, property_name, error)
        begin
            ret != C_NULL && GLib.glib_ref(ret)
            convert(Ptr{GVariant}, GLib.get_pointer(ret))
        end
    end
    function GDBusInterfaceMethodCallFunc(connection, sender, object_path, interface_name, method_name, parameters, invocation, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        method_name = string_or_nothing(method_name, false)
        parameters = convert(GVariant, parameters)
        invocation = convert(GDBusMethodInvocation, invocation, true)
        f = user_data
        ret = f(connection, sender, object_path, interface_name, method_name, parameters, invocation)
        nothing
    end
    function GDBusInterfaceSetPropertyFunc(connection, sender, object_path, interface_name, property_name, value, error, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        property_name = string_or_nothing(property_name, false)
        value = convert(GVariant, value)
        f = user_data
        ret = f(connection, sender, object_path, interface_name, property_name, value, error)
        convert(Cint, ret)
    end
    function GDBusMessageFilterFunction(connection, message, incoming, user_data)
        connection = convert(GDBusConnection, connection, false)
        message = convert(GDBusMessage, message, true)
        incoming = convert(Bool, incoming)
        f = user_data
        ret = f(connection, message, incoming)
        begin
            ret != C_NULL && GLib.glib_ref(ret)
            convert(Ptr{GObject}, GLib.get_pointer(ret))
        end
    end
    function GDBusProxyTypeFunc(manager, object_path, interface_name, data)
        manager = convert(GDBusObjectManagerClient, manager, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        f = data
        ret = f(manager, object_path, interface_name)
        convert(UInt64, ret)
    end
    function GDBusSignalCallback(connection, sender_name, object_path, interface_name, signal_name, parameters, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender_name = string_or_nothing(sender_name, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        signal_name = string_or_nothing(signal_name, false)
        parameters = convert(GVariant, parameters)
        f = user_data
        ret = f(connection, sender_name, object_path, interface_name, signal_name, parameters)
        nothing
    end
    function GDBusSubtreeDispatchFunc(connection, sender, object_path, interface_name, node, out_user_data, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        node = string_or_nothing(node, false)
        out_user_data = convert(Nothing, out_user_data)
        f = user_data
        ret = f(connection, sender, object_path, interface_name, node, out_user_data)
        convert(Ptr{_GDBusInterfaceVTable}, ret)
    end
    function GDBusSubtreeEnumerateFunc(connection, sender, object_path, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        f = user_data
        ret = f(connection, sender, object_path)
        convert(Ptr{Cstring}, ret)
    end
    function GDBusSubtreeIntrospectFunc(connection, sender, object_path, node, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        node = string_or_nothing(node, false)
        f = user_data
        ret = f(connection, sender, object_path, node)
        convert(Ptr{Ptr{_GDBusInterfaceInfo}}, ret)
    end
    function GDatagramBasedSourceFunc(datagram_based, condition, data)
        datagram_based = begin
                leaftype = GLib.find_leaf_type(datagram_based)
                convert(leaftype, datagram_based, false)
            end
        condition = IOCondition(condition)
        f = data
        ret = f(datagram_based, condition)
        convert(Cint, ret)
    end
    function GDesktopAppLaunchCallback(appinfo, pid, user_data)
        appinfo = convert(GDesktopAppInfo, appinfo, false)
        f = user_data
        ret = f(appinfo, pid)
        nothing
    end
    function GFileMeasureProgressCallback(reporting, current_size, num_dirs, num_files, data)
        reporting = convert(Bool, reporting)
        f = data
        ret = f(reporting, current_size, num_dirs, num_files)
        nothing
    end
    function GFileProgressCallback(current_num_bytes, total_num_bytes, data)
        f = data
        ret = f(current_num_bytes, total_num_bytes)
        nothing
    end
    function GFileReadMoreCallback(file_contents, file_size, callback_data)
        file_contents = string_or_nothing(file_contents, false)
        f = callback_data
        ret = f(file_contents, file_size)
        convert(Cint, ret)
    end
    function GIOSchedulerJobFunc(job, cancellable, data)
        job = convert(GIOSchedulerJob, job)
        cancellable = convert_if_not_null(GCancellable, cancellable, false)
        f = data
        ret = f(job, cancellable)
        convert(Cint, ret)
    end
    function GPollableSourceFunc(pollable_stream, data)
        pollable_stream = convert(GObject, pollable_stream, false)
        f = data
        ret = f(pollable_stream)
        convert(Cint, ret)
    end
    function GSettingsBindGetMapping(value, variant, user_data)
        value = convert(Union{GValue, Ref{_GValue}}, value, false)
        variant = convert(GVariant, variant)
        f = user_data
        ret = f(value, variant)
        convert(Cint, ret)
    end
    function GSettingsBindSetMapping(value, expected_type, user_data)
        value = convert(Union{GValue, Ref{_GValue}}, value, false)
        expected_type = convert(GVariantType, expected_type, false)
        f = user_data
        ret = f(value, expected_type)
        begin
            ret != C_NULL && GLib.glib_ref(ret)
            convert(Ptr{GVariant}, GLib.get_pointer(ret))
        end
    end
    function GSettingsGetMapping(value, result, user_data)
        value = convert(GVariant, value)
        result = convert(Maybe(Nothing), result)
        f = user_data
        ret = f(value, result)
        convert(Cint, ret)
    end
    function GSocketSourceFunc(socket, condition, data)
        socket = convert(GSocket, socket, false)
        condition = IOCondition(condition)
        f = data
        ret = f(socket, condition)
        convert(Cint, ret)
    end
    function GVfsFileLookupFunc(vfs, identifier, user_data)
        vfs = convert(GVfs, vfs, false)
        identifier = string_or_nothing(identifier, false)
        f = user_data
        ret = f(vfs, identifier)
        begin
            ret != C_NULL && GLib.glib_ref(ret)
            convert(Ptr{GObject}, GLib.get_pointer(ret))
        end
    end
    function on_launch_failed(f, object::GAppLaunchContext, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "launch-failed", Nothing, (Cstring,), after, user_data)
    end
    function on_launch_started(f, object::GAppLaunchContext, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "launch-started", Nothing, (Ptr{GObject}, GVariant), after, user_data)
    end
    function on_launched(f, object::GAppLaunchContext, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "launched", Nothing, (Ptr{GObject}, GVariant), after, user_data)
    end
    function on_activate(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "activate", Nothing, (), after, user_data)
    end
    function on_command_line(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "command-line", Int32, (Ptr{GObject},), after, user_data)
    end
    function on_handle_local_options(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "handle-local-options", Int32, (GVariantDict,), after, user_data)
    end
    function on_name_lost(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "name-lost", Cint, (), after, user_data)
    end
    function on_open(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "open", Nothing, (Ptr{Ptr{GObject}}, Int32, Cstring), after, user_data)
    end
    function on_shutdown(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "shutdown", Nothing, (), after, user_data)
    end
    function on_startup(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "startup", Nothing, (), after, user_data)
    end
    function on_action_added(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-added", Nothing, (Cstring,), after, user_data)
    end
    function on_action_enabled_changed(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-enabled-changed", Nothing, (Cstring, Cint), after, user_data)
    end
    function on_action_removed(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-removed", Nothing, (Cstring,), after, user_data)
    end
    function on_action_state_changed(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-state-changed", Nothing, (Cstring, GVariant), after, user_data)
    end
    function on_cancelled(f, object::GCancellable, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "cancelled", Nothing, (), after, user_data)
    end
    function on_action_added(f, object::GDBusActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-added", Nothing, (Cstring,), after, user_data)
    end
    function on_action_enabled_changed(f, object::GDBusActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-enabled-changed", Nothing, (Cstring, Cint), after, user_data)
    end
    function on_action_removed(f, object::GDBusActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-removed", Nothing, (Cstring,), after, user_data)
    end
    function on_action_state_changed(f, object::GDBusActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-state-changed", Nothing, (Cstring, GVariant), after, user_data)
    end
    function on_allow_mechanism(f, object::GDBusAuthObserver, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "allow-mechanism", Cint, (Cstring,), after, user_data)
    end
    function on_authorize_authenticated_peer(f, object::GDBusAuthObserver, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "authorize-authenticated-peer", Cint, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_g_authorize_method(f, object::GDBusInterfaceSkeleton, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "g-authorize-method", Cint, (Ptr{GObject},), after, user_data)
    end
    function on_interface_proxy_properties_changed(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-proxy-properties-changed", Nothing, (Ptr{GObject}, Ptr{GObject}, GVariant, Ptr{Cstring}), after, user_data)
    end
    function on_interface_proxy_signal(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-proxy-signal", Nothing, (Ptr{GObject}, Ptr{GObject}, Cstring, Cstring, GVariant), after, user_data)
    end
    function on_interface_added(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-added", Nothing, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_interface_removed(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-removed", Nothing, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_object_added(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "object-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_object_removed(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "object-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_interface_added(f, object::GDBusObjectManagerServer, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-added", Nothing, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_interface_removed(f, object::GDBusObjectManagerServer, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-removed", Nothing, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_object_added(f, object::GDBusObjectManagerServer, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "object-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_object_removed(f, object::GDBusObjectManagerServer, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "object-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_interface_added(f, object::GDBusObjectProxy, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_interface_removed(f, object::GDBusObjectProxy, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_authorize_method(f, object::GDBusObjectSkeleton, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "authorize-method", Cint, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_interface_added(f, object::GDBusObjectSkeleton, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_interface_removed(f, object::GDBusObjectSkeleton, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_new_connection(f, object::GDBusServer, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "new-connection", Cint, (Ptr{GObject},), after, user_data)
    end
    function on_changed(f, object::GFileMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "changed", Nothing, (Ptr{GObject}, Ptr{GObject}, UInt32), after, user_data)
    end
    function on_got_completion_data(f, object::GFilenameCompleter, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "got-completion-data", Nothing, (), after, user_data)
    end
    function on_items_changed(f, object::GListStore, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "items-changed", Nothing, (UInt32, UInt32, UInt32), after, user_data)
    end
    function on_items_changed(f, object::GMenuModel, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "items-changed", Nothing, (Int32, Int32, Int32), after, user_data)
    end
    function on_aborted(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "aborted", Nothing, (), after, user_data)
    end
    function on_ask_password(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "ask-password", Nothing, (Cstring, Cstring, Cstring, UInt32), after, user_data)
    end
    function on_ask_question(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "ask-question", Nothing, (Cstring, Ptr{Cstring}), after, user_data)
    end
    function on_reply(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "reply", Nothing, (UInt32,), after, user_data)
    end
    function on_show_processes(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "show-processes", Nothing, (Cstring, Ptr{GArray}, Ptr{Cstring}), after, user_data)
    end
    function on_show_unmount_progress(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "show-unmount-progress", Nothing, (Cstring, Int64, Int64), after, user_data)
    end
    function on_reload(f, object::GResolver, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "reload", Nothing, (), after, user_data)
    end
    function on_change_event(f, object::GSettings, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "change-event", Cint, (Ptr{UInt32}, Int32), after, user_data)
    end
    function on_changed(f, object::GSettings, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "changed", Nothing, (Cstring,), after, user_data)
    end
    function on_writable_change_event(f, object::GSettings, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "writable-change-event", Cint, (UInt32,), after, user_data)
    end
    function on_writable_changed(f, object::GSettings, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "writable-changed", Nothing, (Cstring,), after, user_data)
    end
    function on_activate(f, object::GSimpleAction, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "activate", Nothing, (GVariant,), after, user_data)
    end
    function on_change_state(f, object::GSimpleAction, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "change-state", Nothing, (GVariant,), after, user_data)
    end
    function on_action_added(f, object::GSimpleActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-added", Nothing, (Cstring,), after, user_data)
    end
    function on_action_enabled_changed(f, object::GSimpleActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-enabled-changed", Nothing, (Cstring, Cint), after, user_data)
    end
    function on_action_removed(f, object::GSimpleActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-removed", Nothing, (Cstring,), after, user_data)
    end
    function on_action_state_changed(f, object::GSimpleActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-state-changed", Nothing, (Cstring, GVariant), after, user_data)
    end
    function on_event(f, object::GSocketClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "event", Nothing, (UInt32, Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_event(f, object::GSocketListener, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "event", Nothing, (UInt32, Ptr{GObject}), after, user_data)
    end
    function on_incoming(f, object::GSocketService, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "incoming", Cint, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_run(f, object::GThreadedSocketService, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "run", Cint, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_accept_certificate(f, object::GTlsConnection, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "accept-certificate", Cint, (Ptr{GObject}, UInt32), after, user_data)
    end
    function on_drive_changed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-changed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_drive_connected(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-connected", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_drive_disconnected(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-disconnected", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_drive_eject_button(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-eject-button", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_drive_stop_button(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-stop-button", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_mount_added(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "mount-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_mount_changed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "mount-changed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_mount_pre_unmount(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "mount-pre-unmount", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_mount_removed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "mount-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_volume_added(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "volume-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_volume_changed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "volume-changed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_volume_removed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "volume-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    export GDBusErrorEntry, _GDBusErrorEntry, GFileAttributeInfo, _GFileAttributeInfo, GFileAttributeInfoList, _GFileAttributeInfoList, GFileAttributeMatcher, GInputVector, _GInputVector, GOutputVector, _GOutputVector, GResource, GSettingsSchema, GSettingsSchemaKey, GSettingsSchemaSource, GSrvTarget, GXdpDocumentsIface, _GXdpDocumentsIface, GXdpOpenURIIface, _GXdpOpenURIIface, GXdpProxyResolverIface, _GXdpProxyResolverIface, GXdpTrashIface, _GXdpTrashIface, G_FreedesktopDBusIface, _G_FreedesktopDBusIface, G_FreedesktopDBusProxy, _G_FreedesktopDBusProxy, G_FreedesktopDBusSkeleton, _G_FreedesktopDBusSkeleton, GAction, GActionGroup, GActionMap, GAppInfo, GAsyncInitable, GAsyncResult, GConverter, GDBusInterface, GDBusObject, GDBusObjectManager, GDatagramBased, GDebugController, GDrive, GDtlsClientConnection, GDtlsConnection, GDtlsServerConnection, GFile, GFileDescriptorBased, GIcon, GInitable, GListModel, GLoadableIcon, GMemoryMonitor, GMount, GNetworkMonitor, GPollableInputStream, GPollableOutputStream, GPowerProfileMonitor, GProxy, GProxyResolver, GRemoteActionGroup, GSeekable, GSocketConnectable, GTlsBackend, GTlsClientConnection, GTlsFileDatabase, GTlsServerConnection, GVolume, GAppInfoMonitor, GAppInfoMonitorLeaf, GAppLaunchContext, GAppLaunchContextLeaf, GApplication, GApplicationLeaf, GApplicationCommandLine, GApplicationCommandLineLeaf, GBufferedInputStream, GBufferedInputStreamLeaf, GBufferedOutputStream, GBufferedOutputStreamLeaf, GBytesIcon, GBytesIconLeaf, GCancellable, GCancellableLeaf, GCharsetConverter, GCharsetConverterLeaf, GConverterInputStream, GConverterInputStreamLeaf, GConverterOutputStream, GConverterOutputStreamLeaf, GCredentials, GCredentialsLeaf, GDBusActionGroup, GDBusActionGroupLeaf, GDBusAuthObserver, GDBusAuthObserverLeaf, GDBusConnection, GDBusConnectionLeaf, GDBusInterfaceSkeleton, GDBusMenuModel, GDBusMenuModelLeaf, GDBusMessage, GDBusMessageLeaf, GDBusMethodInvocation, GDBusMethodInvocationLeaf, GDBusObjectManagerClient, GDBusObjectManagerClientLeaf, GDBusObjectManagerServer, GDBusObjectManagerServerLeaf, GDBusObjectProxy, GDBusObjectProxyLeaf, GDBusObjectSkeleton, GDBusObjectSkeletonLeaf, GDBusProxy, GDBusProxyLeaf, GDBusServer, GDBusServerLeaf, GDataInputStream, GDataInputStreamLeaf, GDataOutputStream, GDataOutputStreamLeaf, GDesktopAppInfo, GDesktopAppInfoLeaf, GEmblem, GEmblemLeaf, GEmblemedIcon, GEmblemedIconLeaf, GFileEnumerator, GFileEnumeratorLeaf, GFileIOStream, GFileIOStreamLeaf, GFileIcon, GFileIconLeaf, GFileInfo, GFileInfoLeaf, GFileInputStream, GFileInputStreamLeaf, GFileMonitor, GFileOutputStream, GFileOutputStreamLeaf, GFilenameCompleter, GFilenameCompleterLeaf, GFilterInputStream, GFilterOutputStream, GIOModule, GIOModuleLeaf, GIOStream, GInetAddress, GInetAddressLeaf, GInetAddressMask, GInetAddressMaskLeaf, GInetSocketAddress, GInetSocketAddressLeaf, GInputStream, GListStore, GListStoreLeaf, GMemoryInputStream, GMemoryInputStreamLeaf, GMemoryOutputStream, GMemoryOutputStreamLeaf, GMenu, GMenuLeaf, GMenuAttributeIter, GMenuItem, GMenuItemLeaf, GMenuLinkIter, GMenuModel, GMountOperation, GMountOperationLeaf, GNativeSocketAddress, GNativeSocketAddressLeaf, GNativeVolumeMonitor, GNetworkAddress, GNetworkAddressLeaf, GNetworkService, GNetworkServiceLeaf, GNotification, GNotificationLeaf, GOutputStream, GPermission, GPropertyAction, GPropertyActionLeaf, GProxyAddress, GProxyAddressLeaf, GProxyAddressEnumerator, GProxyAddressEnumeratorLeaf, GResolver, GSettings, GSettingsLeaf, GSettingsBackend, GSimpleAction, GSimpleActionLeaf, GSimpleActionGroup, GSimpleActionGroupLeaf, GSimpleAsyncResult, GSimpleAsyncResultLeaf, GSimpleIOStream, GSimpleIOStreamLeaf, GSimplePermission, GSimplePermissionLeaf, GSimpleProxyResolver, GSimpleProxyResolverLeaf, GSocket, GSocketLeaf, GSocketAddress, GSocketAddressEnumerator, GSocketClient, GSocketClientLeaf, GSocketConnection, GSocketConnectionLeaf, GSocketControlMessage, GSocketListener, GSocketListenerLeaf, GSocketService, GSocketServiceLeaf, GSubprocess, GSubprocessLeaf, GSubprocessLauncher, GSubprocessLauncherLeaf, GTask, GTaskLeaf, GTcpConnection, GTcpConnectionLeaf, GTcpWrapperConnection, GTcpWrapperConnectionLeaf, GTestDBus, GTestDBusLeaf, GThemedIcon, GThemedIconLeaf, GThreadedResolver, GThreadedResolverLeaf, GThreadedSocketService, GThreadedSocketServiceLeaf, GTlsCertificate, GTlsConnection, GTlsDatabase, GTlsInteraction, GTlsInteractionLeaf, GTlsPassword, GTlsPasswordLeaf, GUnixConnection, GUnixConnectionLeaf, GUnixCredentialsMessage, GUnixCredentialsMessageLeaf, GVfs, GVfsLeaf, GVolumeMonitor, GVolumeMonitorLeaf, GZlibCompressor, GZlibCompressorLeaf, GZlibDecompressor, GZlibDecompressorLeaf, GAsyncReadyCallback, GBusAcquiredCallback, GBusNameAcquiredCallback, GBusNameAppearedCallback, GBusNameLostCallback, GBusNameVanishedCallback, GCancellableSourceFunc, GDBusInterfaceGetPropertyFunc, GDBusInterfaceMethodCallFunc, GDBusInterfaceSetPropertyFunc, GDBusMessageFilterFunction, GDBusProxyTypeFunc, GDBusSignalCallback, GDBusSubtreeDispatchFunc, GDBusSubtreeEnumerateFunc, GDBusSubtreeIntrospectFunc, GDatagramBasedSourceFunc, GDesktopAppLaunchCallback, GFileMeasureProgressCallback, GFileProgressCallback, GFileReadMoreCallback, GIOSchedulerJobFunc, GPollableSourceFunc, GSettingsBindGetMapping, GSettingsBindSetMapping, GSettingsGetMapping, GSocketSourceFunc, GVfsFileLookupFunc
end))
end
