quote
$(Expr(:toplevel, quote
    begin
        struct _GDBusErrorEntry
            error_code::Int32
            dbus_error_name::Cstring
        end
        mutable struct GDBusErrorEntry
            handle::Ptr{_GDBusErrorEntry}
        end
        unsafe_convert(::Type{Ptr{_GDBusErrorEntry}}, box::GDBusErrorEntry) = begin
                convert(Ptr{_GDBusErrorEntry}, box.handle)
            end
    end
    begin
        struct _GFileAttributeInfo
            name::Cstring
            type::UInt32
            flags::UInt32
        end
        mutable struct GFileAttributeInfo
            handle::Ptr{_GFileAttributeInfo}
        end
        unsafe_convert(::Type{Ptr{_GFileAttributeInfo}}, box::GFileAttributeInfo) = begin
                convert(Ptr{_GFileAttributeInfo}, box.handle)
            end
    end
    begin
        struct _GFileAttributeInfoList
            infos::Ptr{_GFileAttributeInfo}
            n_infos::Int32
        end
        mutable struct GFileAttributeInfoList <: GBoxed
            handle::Ptr{_GFileAttributeInfoList}
            begin
                (GLib.g_type(::Type{T}) where T <: GFileAttributeInfoList) = begin
                        ccall(("g_file_attribute_info_list_get_type", libgio), GType, ())
                    end
                function GFileAttributeInfoList(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GFileAttributeInfoList)
            end
        end
        unsafe_convert(::Type{Ptr{_GFileAttributeInfoList}}, box::GFileAttributeInfoList) = begin
                convert(Ptr{_GFileAttributeInfoList}, box.handle)
            end
    end
    mutable struct GFileAttributeMatcher <: GBoxed
        handle::Ptr{GFileAttributeMatcher}
        begin
            (GLib.g_type(::Type{T}) where T <: GFileAttributeMatcher) = begin
                    ccall(("g_file_attribute_matcher_get_type", libgio), GType, ())
                end
            function GFileAttributeMatcher(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GFileAttributeMatcher)
        end
    end
    begin
        struct _GInputVector
            buffer::Ptr{Nothing}
            size::UInt64
        end
        mutable struct GInputVector
            handle::Ptr{_GInputVector}
        end
        unsafe_convert(::Type{Ptr{_GInputVector}}, box::GInputVector) = begin
                convert(Ptr{_GInputVector}, box.handle)
            end
    end
    begin
        struct _GOutputVector
            buffer::Ptr{Nothing}
            size::UInt64
        end
        mutable struct GOutputVector
            handle::Ptr{_GOutputVector}
        end
        unsafe_convert(::Type{Ptr{_GOutputVector}}, box::GOutputVector) = begin
                convert(Ptr{_GOutputVector}, box.handle)
            end
    end
    mutable struct GResource <: GBoxed
        handle::Ptr{GResource}
        begin
            (GLib.g_type(::Type{T}) where T <: GResource) = begin
                    ccall(("g_resource_get_type", libgio), GType, ())
                end
            function GResource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GResource)
        end
    end
    mutable struct GSettingsSchema <: GBoxed
        handle::Ptr{GSettingsSchema}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchema) = begin
                    ccall(("g_settings_schema_get_type", libgio), GType, ())
                end
            function GSettingsSchema(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchema)
        end
    end
    mutable struct GSettingsSchemaKey <: GBoxed
        handle::Ptr{GSettingsSchemaKey}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchemaKey) = begin
                    ccall(("g_settings_schema_key_get_type", libgio), GType, ())
                end
            function GSettingsSchemaKey(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchemaKey)
        end
    end
    mutable struct GSettingsSchemaSource <: GBoxed
        handle::Ptr{GSettingsSchemaSource}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchemaSource) = begin
                    ccall(("g_settings_schema_source_get_type", libgio), GType, ())
                end
            function GSettingsSchemaSource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchemaSource)
        end
    end
    mutable struct GSrvTarget <: GBoxed
        handle::Ptr{GSrvTarget}
        begin
            (GLib.g_type(::Type{T}) where T <: GSrvTarget) = begin
                    ccall(("g_srv_target_get_type", libgio), GType, ())
                end
            function GSrvTarget(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSrvTarget)
        end
    end
    begin
        abstract type GAppInfoMonitor <: GObject end
        mutable struct GAppInfoMonitorLeaf <: GAppInfoMonitor
            handle::Ptr{GObject}
            function GAppInfoMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GAppInfoMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GAppInfoMonitorLeaf(args...; kwargs...)
            w = GAppInfoMonitor(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GAppInfoMonitor] = GAppInfoMonitorLeaf
        function GAppInfoMonitor(args...; kwargs...)
            GAppInfoMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GAppLaunchContext <: GObject end
        mutable struct GAppLaunchContextLeaf <: GAppLaunchContext
            handle::Ptr{GObject}
            function GAppLaunchContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GAppLaunchContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GAppLaunchContextLeaf(args...; kwargs...)
            w = GAppLaunchContext(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GAppLaunchContext] = GAppLaunchContextLeaf
        function GAppLaunchContext(args...; kwargs...)
            GAppLaunchContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GApplication <: GObject end
        mutable struct GApplicationLeaf <: GApplication
            handle::Ptr{GObject}
            function GApplicationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GApplicationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GApplicationLeaf(args...; kwargs...)
            w = GApplication(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GApplication] = GApplicationLeaf
        function GApplication(args...; kwargs...)
            GApplicationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GApplicationCommandLine <: GObject end
        mutable struct GApplicationCommandLineLeaf <: GApplicationCommandLine
            handle::Ptr{GObject}
            function GApplicationCommandLineLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GApplicationCommandLineLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GApplicationCommandLineLeaf(args...; kwargs...)
            w = GApplicationCommandLine(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GApplicationCommandLine] = GApplicationCommandLineLeaf
        function GApplicationCommandLine(args...; kwargs...)
            GApplicationCommandLineLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GInputStream <: GObject end
        mutable struct GInputStreamLeaf <: GInputStream
            handle::Ptr{GObject}
            function GInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInputStreamLeaf(args...; kwargs...)
            w = GInputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GInputStream] = GInputStreamLeaf
        function GInputStream(args...; kwargs...)
            GInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFilterInputStream <: GInputStream end
        mutable struct GFilterInputStreamLeaf <: GFilterInputStream
            handle::Ptr{GObject}
            function GFilterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilterInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFilterInputStreamLeaf(args...; kwargs...)
            w = GFilterInputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFilterInputStream] = GFilterInputStreamLeaf
        function GFilterInputStream(args...; kwargs...)
            GFilterInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GBufferedInputStream <: GFilterInputStream end
        mutable struct GBufferedInputStreamLeaf <: GBufferedInputStream
            handle::Ptr{GObject}
            function GBufferedInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBufferedInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GBufferedInputStreamLeaf(args...; kwargs...)
            w = GBufferedInputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GBufferedInputStream] = GBufferedInputStreamLeaf
        function GBufferedInputStream(args...; kwargs...)
            GBufferedInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GOutputStream <: GObject end
        mutable struct GOutputStreamLeaf <: GOutputStream
            handle::Ptr{GObject}
            function GOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GOutputStreamLeaf(args...; kwargs...)
            w = GOutputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GOutputStream] = GOutputStreamLeaf
        function GOutputStream(args...; kwargs...)
            GOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFilterOutputStream <: GOutputStream end
        mutable struct GFilterOutputStreamLeaf <: GFilterOutputStream
            handle::Ptr{GObject}
            function GFilterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilterOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFilterOutputStreamLeaf(args...; kwargs...)
            w = GFilterOutputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFilterOutputStream] = GFilterOutputStreamLeaf
        function GFilterOutputStream(args...; kwargs...)
            GFilterOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GBufferedOutputStream <: GFilterOutputStream end
        mutable struct GBufferedOutputStreamLeaf <: GBufferedOutputStream
            handle::Ptr{GObject}
            function GBufferedOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBufferedOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GBufferedOutputStreamLeaf(args...; kwargs...)
            w = GBufferedOutputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GBufferedOutputStream] = GBufferedOutputStreamLeaf
        function GBufferedOutputStream(args...; kwargs...)
            GBufferedOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GBytesIcon <: GObject end
        mutable struct GBytesIconLeaf <: GBytesIcon
            handle::Ptr{GObject}
            function GBytesIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBytesIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GBytesIconLeaf(args...; kwargs...)
            w = GBytesIcon(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GBytesIcon] = GBytesIconLeaf
        function GBytesIcon(args...; kwargs...)
            GBytesIconLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GCancellable <: GObject end
        mutable struct GCancellableLeaf <: GCancellable
            handle::Ptr{GObject}
            function GCancellableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCancellableLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GCancellableLeaf(args...; kwargs...)
            w = GCancellable(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GCancellable] = GCancellableLeaf
        function GCancellable(args...; kwargs...)
            GCancellableLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GCharsetConverter <: GObject end
        mutable struct GCharsetConverterLeaf <: GCharsetConverter
            handle::Ptr{GObject}
            function GCharsetConverterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCharsetConverterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GCharsetConverterLeaf(args...; kwargs...)
            w = GCharsetConverter(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GCharsetConverter] = GCharsetConverterLeaf
        function GCharsetConverter(args...; kwargs...)
            GCharsetConverterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GConverterInputStream <: GFilterInputStream end
        mutable struct GConverterInputStreamLeaf <: GConverterInputStream
            handle::Ptr{GObject}
            function GConverterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GConverterInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GConverterInputStreamLeaf(args...; kwargs...)
            w = GConverterInputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GConverterInputStream] = GConverterInputStreamLeaf
        function GConverterInputStream(args...; kwargs...)
            GConverterInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GConverterOutputStream <: GFilterOutputStream end
        mutable struct GConverterOutputStreamLeaf <: GConverterOutputStream
            handle::Ptr{GObject}
            function GConverterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GConverterOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GConverterOutputStreamLeaf(args...; kwargs...)
            w = GConverterOutputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GConverterOutputStream] = GConverterOutputStreamLeaf
        function GConverterOutputStream(args...; kwargs...)
            GConverterOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GCredentials <: GObject end
        mutable struct GCredentialsLeaf <: GCredentials
            handle::Ptr{GObject}
            function GCredentialsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCredentialsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GCredentialsLeaf(args...; kwargs...)
            w = GCredentials(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GCredentials] = GCredentialsLeaf
        function GCredentials(args...; kwargs...)
            GCredentialsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusActionGroup <: GObject end
        mutable struct GDBusActionGroupLeaf <: GDBusActionGroup
            handle::Ptr{GObject}
            function GDBusActionGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusActionGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusActionGroupLeaf(args...; kwargs...)
            w = GDBusActionGroup(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusActionGroup] = GDBusActionGroupLeaf
        function GDBusActionGroup(args...; kwargs...)
            GDBusActionGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusAuthObserver <: GObject end
        mutable struct GDBusAuthObserverLeaf <: GDBusAuthObserver
            handle::Ptr{GObject}
            function GDBusAuthObserverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusAuthObserverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusAuthObserverLeaf(args...; kwargs...)
            w = GDBusAuthObserver(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusAuthObserver] = GDBusAuthObserverLeaf
        function GDBusAuthObserver(args...; kwargs...)
            GDBusAuthObserverLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusConnection <: GObject end
        mutable struct GDBusConnectionLeaf <: GDBusConnection
            handle::Ptr{GObject}
            function GDBusConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusConnectionLeaf(args...; kwargs...)
            w = GDBusConnection(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusConnection] = GDBusConnectionLeaf
        function GDBusConnection(args...; kwargs...)
            GDBusConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusInterfaceSkeleton <: GObject end
        mutable struct GDBusInterfaceSkeletonLeaf <: GDBusInterfaceSkeleton
            handle::Ptr{GObject}
            function GDBusInterfaceSkeletonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusInterfaceSkeletonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusInterfaceSkeletonLeaf(args...; kwargs...)
            w = GDBusInterfaceSkeleton(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusInterfaceSkeleton] = GDBusInterfaceSkeletonLeaf
        function GDBusInterfaceSkeleton(args...; kwargs...)
            GDBusInterfaceSkeletonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuModel <: GObject end
        mutable struct GMenuModelLeaf <: GMenuModel
            handle::Ptr{GObject}
            function GMenuModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuModelLeaf(args...; kwargs...)
            w = GMenuModel(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenuModel] = GMenuModelLeaf
        function GMenuModel(args...; kwargs...)
            GMenuModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusMenuModel <: GMenuModel end
        mutable struct GDBusMenuModelLeaf <: GDBusMenuModel
            handle::Ptr{GObject}
            function GDBusMenuModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMenuModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusMenuModelLeaf(args...; kwargs...)
            w = GDBusMenuModel(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusMenuModel] = GDBusMenuModelLeaf
        function GDBusMenuModel(args...; kwargs...)
            GDBusMenuModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusMessage <: GObject end
        mutable struct GDBusMessageLeaf <: GDBusMessage
            handle::Ptr{GObject}
            function GDBusMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMessageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusMessageLeaf(args...; kwargs...)
            w = GDBusMessage(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusMessage] = GDBusMessageLeaf
        function GDBusMessage(args...; kwargs...)
            GDBusMessageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusMethodInvocation <: GObject end
        mutable struct GDBusMethodInvocationLeaf <: GDBusMethodInvocation
            handle::Ptr{GObject}
            function GDBusMethodInvocationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMethodInvocationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusMethodInvocationLeaf(args...; kwargs...)
            w = GDBusMethodInvocation(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusMethodInvocation] = GDBusMethodInvocationLeaf
        function GDBusMethodInvocation(args...; kwargs...)
            GDBusMethodInvocationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusObjectManagerClient <: GObject end
        mutable struct GDBusObjectManagerClientLeaf <: GDBusObjectManagerClient
            handle::Ptr{GObject}
            function GDBusObjectManagerClientLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectManagerClientLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectManagerClientLeaf(args...; kwargs...)
            w = GDBusObjectManagerClient(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusObjectManagerClient] = GDBusObjectManagerClientLeaf
        function GDBusObjectManagerClient(args...; kwargs...)
            GDBusObjectManagerClientLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusObjectManagerServer <: GObject end
        mutable struct GDBusObjectManagerServerLeaf <: GDBusObjectManagerServer
            handle::Ptr{GObject}
            function GDBusObjectManagerServerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectManagerServerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectManagerServerLeaf(args...; kwargs...)
            w = GDBusObjectManagerServer(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusObjectManagerServer] = GDBusObjectManagerServerLeaf
        function GDBusObjectManagerServer(args...; kwargs...)
            GDBusObjectManagerServerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusObjectProxy <: GObject end
        mutable struct GDBusObjectProxyLeaf <: GDBusObjectProxy
            handle::Ptr{GObject}
            function GDBusObjectProxyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectProxyLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectProxyLeaf(args...; kwargs...)
            w = GDBusObjectProxy(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusObjectProxy] = GDBusObjectProxyLeaf
        function GDBusObjectProxy(args...; kwargs...)
            GDBusObjectProxyLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusObjectSkeleton <: GObject end
        mutable struct GDBusObjectSkeletonLeaf <: GDBusObjectSkeleton
            handle::Ptr{GObject}
            function GDBusObjectSkeletonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectSkeletonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectSkeletonLeaf(args...; kwargs...)
            w = GDBusObjectSkeleton(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusObjectSkeleton] = GDBusObjectSkeletonLeaf
        function GDBusObjectSkeleton(args...; kwargs...)
            GDBusObjectSkeletonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusProxy <: GObject end
        mutable struct GDBusProxyLeaf <: GDBusProxy
            handle::Ptr{GObject}
            function GDBusProxyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusProxyLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusProxyLeaf(args...; kwargs...)
            w = GDBusProxy(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusProxy] = GDBusProxyLeaf
        function GDBusProxy(args...; kwargs...)
            GDBusProxyLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusServer <: GObject end
        mutable struct GDBusServerLeaf <: GDBusServer
            handle::Ptr{GObject}
            function GDBusServerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusServerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusServerLeaf(args...; kwargs...)
            w = GDBusServer(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusServer] = GDBusServerLeaf
        function GDBusServer(args...; kwargs...)
            GDBusServerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDataInputStream <: GBufferedInputStream end
        mutable struct GDataInputStreamLeaf <: GDataInputStream
            handle::Ptr{GObject}
            function GDataInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDataInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDataInputStreamLeaf(args...; kwargs...)
            w = GDataInputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDataInputStream] = GDataInputStreamLeaf
        function GDataInputStream(args...; kwargs...)
            GDataInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDataOutputStream <: GFilterOutputStream end
        mutable struct GDataOutputStreamLeaf <: GDataOutputStream
            handle::Ptr{GObject}
            function GDataOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDataOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDataOutputStreamLeaf(args...; kwargs...)
            w = GDataOutputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDataOutputStream] = GDataOutputStreamLeaf
        function GDataOutputStream(args...; kwargs...)
            GDataOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDesktopAppInfo <: GObject end
        mutable struct GDesktopAppInfoLeaf <: GDesktopAppInfo
            handle::Ptr{GObject}
            function GDesktopAppInfoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDesktopAppInfoLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDesktopAppInfoLeaf(args...; kwargs...)
            w = GDesktopAppInfo(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDesktopAppInfo] = GDesktopAppInfoLeaf
        function GDesktopAppInfo(args...; kwargs...)
            GDesktopAppInfoLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GEmblem <: GObject end
        mutable struct GEmblemLeaf <: GEmblem
            handle::Ptr{GObject}
            function GEmblemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GEmblemLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GEmblemLeaf(args...; kwargs...)
            w = GEmblem(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GEmblem] = GEmblemLeaf
        function GEmblem(args...; kwargs...)
            GEmblemLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GEmblemedIcon <: GObject end
        mutable struct GEmblemedIconLeaf <: GEmblemedIcon
            handle::Ptr{GObject}
            function GEmblemedIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GEmblemedIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GEmblemedIconLeaf(args...; kwargs...)
            w = GEmblemedIcon(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GEmblemedIcon] = GEmblemedIconLeaf
        function GEmblemedIcon(args...; kwargs...)
            GEmblemedIconLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileEnumerator <: GObject end
        mutable struct GFileEnumeratorLeaf <: GFileEnumerator
            handle::Ptr{GObject}
            function GFileEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileEnumeratorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileEnumeratorLeaf(args...; kwargs...)
            w = GFileEnumerator(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileEnumerator] = GFileEnumeratorLeaf
        function GFileEnumerator(args...; kwargs...)
            GFileEnumeratorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GIOStream <: GObject end
        mutable struct GIOStreamLeaf <: GIOStream
            handle::Ptr{GObject}
            function GIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GIOStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GIOStreamLeaf(args...; kwargs...)
            w = GIOStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GIOStream] = GIOStreamLeaf
        function GIOStream(args...; kwargs...)
            GIOStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileIOStream <: GIOStream end
        mutable struct GFileIOStreamLeaf <: GFileIOStream
            handle::Ptr{GObject}
            function GFileIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileIOStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileIOStreamLeaf(args...; kwargs...)
            w = GFileIOStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileIOStream] = GFileIOStreamLeaf
        function GFileIOStream(args...; kwargs...)
            GFileIOStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileIcon <: GObject end
        mutable struct GFileIconLeaf <: GFileIcon
            handle::Ptr{GObject}
            function GFileIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileIconLeaf(args...; kwargs...)
            w = GFileIcon(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileIcon] = GFileIconLeaf
        function GFileIcon(args...; kwargs...)
            GFileIconLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileInfo <: GObject end
        mutable struct GFileInfoLeaf <: GFileInfo
            handle::Ptr{GObject}
            function GFileInfoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileInfoLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileInfoLeaf(args...; kwargs...)
            w = GFileInfo(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileInfo] = GFileInfoLeaf
        function GFileInfo(args...; kwargs...)
            GFileInfoLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileInputStream <: GInputStream end
        mutable struct GFileInputStreamLeaf <: GFileInputStream
            handle::Ptr{GObject}
            function GFileInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileInputStreamLeaf(args...; kwargs...)
            w = GFileInputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileInputStream] = GFileInputStreamLeaf
        function GFileInputStream(args...; kwargs...)
            GFileInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileMonitor <: GObject end
        mutable struct GFileMonitorLeaf <: GFileMonitor
            handle::Ptr{GObject}
            function GFileMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileMonitorLeaf(args...; kwargs...)
            w = GFileMonitor(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileMonitor] = GFileMonitorLeaf
        function GFileMonitor(args...; kwargs...)
            GFileMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileOutputStream <: GOutputStream end
        mutable struct GFileOutputStreamLeaf <: GFileOutputStream
            handle::Ptr{GObject}
            function GFileOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileOutputStreamLeaf(args...; kwargs...)
            w = GFileOutputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileOutputStream] = GFileOutputStreamLeaf
        function GFileOutputStream(args...; kwargs...)
            GFileOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFilenameCompleter <: GObject end
        mutable struct GFilenameCompleterLeaf <: GFilenameCompleter
            handle::Ptr{GObject}
            function GFilenameCompleterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilenameCompleterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFilenameCompleterLeaf(args...; kwargs...)
            w = GFilenameCompleter(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFilenameCompleter] = GFilenameCompleterLeaf
        function GFilenameCompleter(args...; kwargs...)
            GFilenameCompleterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GIOModule <: GTypeModule end
        mutable struct GIOModuleLeaf <: GIOModule
            handle::Ptr{GObject}
            function GIOModuleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GIOModuleLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GIOModuleLeaf(args...; kwargs...)
            w = GIOModule(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GIOModule] = GIOModuleLeaf
        function GIOModule(args...; kwargs...)
            GIOModuleLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GInetAddress <: GObject end
        mutable struct GInetAddressLeaf <: GInetAddress
            handle::Ptr{GObject}
            function GInetAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInetAddressLeaf(args...; kwargs...)
            w = GInetAddress(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GInetAddress] = GInetAddressLeaf
        function GInetAddress(args...; kwargs...)
            GInetAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GInetAddressMask <: GObject end
        mutable struct GInetAddressMaskLeaf <: GInetAddressMask
            handle::Ptr{GObject}
            function GInetAddressMaskLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetAddressMaskLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInetAddressMaskLeaf(args...; kwargs...)
            w = GInetAddressMask(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GInetAddressMask] = GInetAddressMaskLeaf
        function GInetAddressMask(args...; kwargs...)
            GInetAddressMaskLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketAddress <: GObject end
        mutable struct GSocketAddressLeaf <: GSocketAddress
            handle::Ptr{GObject}
            function GSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketAddressLeaf(args...; kwargs...)
            w = GSocketAddress(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketAddress] = GSocketAddressLeaf
        function GSocketAddress(args...; kwargs...)
            GSocketAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GInetSocketAddress <: GSocketAddress end
        mutable struct GInetSocketAddressLeaf <: GInetSocketAddress
            handle::Ptr{GObject}
            function GInetSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetSocketAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInetSocketAddressLeaf(args...; kwargs...)
            w = GInetSocketAddress(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GInetSocketAddress] = GInetSocketAddressLeaf
        function GInetSocketAddress(args...; kwargs...)
            GInetSocketAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GListStore <: GObject end
        mutable struct GListStoreLeaf <: GListStore
            handle::Ptr{GObject}
            function GListStoreLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GListStoreLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GListStoreLeaf(args...; kwargs...)
            w = GListStore(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GListStore] = GListStoreLeaf
        function GListStore(args...; kwargs...)
            GListStoreLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMemoryInputStream <: GInputStream end
        mutable struct GMemoryInputStreamLeaf <: GMemoryInputStream
            handle::Ptr{GObject}
            function GMemoryInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMemoryInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMemoryInputStreamLeaf(args...; kwargs...)
            w = GMemoryInputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMemoryInputStream] = GMemoryInputStreamLeaf
        function GMemoryInputStream(args...; kwargs...)
            GMemoryInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMemoryOutputStream <: GOutputStream end
        mutable struct GMemoryOutputStreamLeaf <: GMemoryOutputStream
            handle::Ptr{GObject}
            function GMemoryOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMemoryOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMemoryOutputStreamLeaf(args...; kwargs...)
            w = GMemoryOutputStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMemoryOutputStream] = GMemoryOutputStreamLeaf
        function GMemoryOutputStream(args...; kwargs...)
            GMemoryOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenu <: GMenuModel end
        mutable struct GMenuLeaf <: GMenu
            handle::Ptr{GObject}
            function GMenuLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuLeaf(args...; kwargs...)
            w = GMenu(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenu] = GMenuLeaf
        function GMenu(args...; kwargs...)
            GMenuLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuAttributeIter <: GObject end
        mutable struct GMenuAttributeIterLeaf <: GMenuAttributeIter
            handle::Ptr{GObject}
            function GMenuAttributeIterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuAttributeIterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuAttributeIterLeaf(args...; kwargs...)
            w = GMenuAttributeIter(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenuAttributeIter] = GMenuAttributeIterLeaf
        function GMenuAttributeIter(args...; kwargs...)
            GMenuAttributeIterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuItem <: GObject end
        mutable struct GMenuItemLeaf <: GMenuItem
            handle::Ptr{GObject}
            function GMenuItemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuItemLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuItemLeaf(args...; kwargs...)
            w = GMenuItem(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenuItem] = GMenuItemLeaf
        function GMenuItem(args...; kwargs...)
            GMenuItemLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuLinkIter <: GObject end
        mutable struct GMenuLinkIterLeaf <: GMenuLinkIter
            handle::Ptr{GObject}
            function GMenuLinkIterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuLinkIterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuLinkIterLeaf(args...; kwargs...)
            w = GMenuLinkIter(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenuLinkIter] = GMenuLinkIterLeaf
        function GMenuLinkIter(args...; kwargs...)
            GMenuLinkIterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMountOperation <: GObject end
        mutable struct GMountOperationLeaf <: GMountOperation
            handle::Ptr{GObject}
            function GMountOperationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMountOperationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMountOperationLeaf(args...; kwargs...)
            w = GMountOperation(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMountOperation] = GMountOperationLeaf
        function GMountOperation(args...; kwargs...)
            GMountOperationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNativeSocketAddress <: GSocketAddress end
        mutable struct GNativeSocketAddressLeaf <: GNativeSocketAddress
            handle::Ptr{GObject}
            function GNativeSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNativeSocketAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNativeSocketAddressLeaf(args...; kwargs...)
            w = GNativeSocketAddress(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNativeSocketAddress] = GNativeSocketAddressLeaf
        function GNativeSocketAddress(args...; kwargs...)
            GNativeSocketAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GVolumeMonitor <: GObject end
        mutable struct GVolumeMonitorLeaf <: GVolumeMonitor
            handle::Ptr{GObject}
            function GVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GVolumeMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GVolumeMonitorLeaf(args...; kwargs...)
            w = GVolumeMonitor(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GVolumeMonitor] = GVolumeMonitorLeaf
        function GVolumeMonitor(args...; kwargs...)
            GVolumeMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNativeVolumeMonitor <: GVolumeMonitor end
        mutable struct GNativeVolumeMonitorLeaf <: GNativeVolumeMonitor
            handle::Ptr{GObject}
            function GNativeVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNativeVolumeMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNativeVolumeMonitorLeaf(args...; kwargs...)
            w = GNativeVolumeMonitor(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNativeVolumeMonitor] = GNativeVolumeMonitorLeaf
        function GNativeVolumeMonitor(args...; kwargs...)
            GNativeVolumeMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNetworkAddress <: GObject end
        mutable struct GNetworkAddressLeaf <: GNetworkAddress
            handle::Ptr{GObject}
            function GNetworkAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNetworkAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNetworkAddressLeaf(args...; kwargs...)
            w = GNetworkAddress(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNetworkAddress] = GNetworkAddressLeaf
        function GNetworkAddress(args...; kwargs...)
            GNetworkAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNetworkService <: GObject end
        mutable struct GNetworkServiceLeaf <: GNetworkService
            handle::Ptr{GObject}
            function GNetworkServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNetworkServiceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNetworkServiceLeaf(args...; kwargs...)
            w = GNetworkService(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNetworkService] = GNetworkServiceLeaf
        function GNetworkService(args...; kwargs...)
            GNetworkServiceLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNotification <: GObject end
        mutable struct GNotificationLeaf <: GNotification
            handle::Ptr{GObject}
            function GNotificationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNotificationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNotificationLeaf(args...; kwargs...)
            w = GNotification(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNotification] = GNotificationLeaf
        function GNotification(args...; kwargs...)
            GNotificationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GPermission <: GObject end
        mutable struct GPermissionLeaf <: GPermission
            handle::Ptr{GObject}
            function GPermissionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GPermissionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GPermissionLeaf(args...; kwargs...)
            w = GPermission(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GPermission] = GPermissionLeaf
        function GPermission(args...; kwargs...)
            GPermissionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GPropertyAction <: GObject end
        mutable struct GPropertyActionLeaf <: GPropertyAction
            handle::Ptr{GObject}
            function GPropertyActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GPropertyActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GPropertyActionLeaf(args...; kwargs...)
            w = GPropertyAction(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GPropertyAction] = GPropertyActionLeaf
        function GPropertyAction(args...; kwargs...)
            GPropertyActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GProxyAddress <: GInetSocketAddress end
        mutable struct GProxyAddressLeaf <: GProxyAddress
            handle::Ptr{GObject}
            function GProxyAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GProxyAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GProxyAddressLeaf(args...; kwargs...)
            w = GProxyAddress(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GProxyAddress] = GProxyAddressLeaf
        function GProxyAddress(args...; kwargs...)
            GProxyAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketAddressEnumerator <: GObject end
        mutable struct GSocketAddressEnumeratorLeaf <: GSocketAddressEnumerator
            handle::Ptr{GObject}
            function GSocketAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketAddressEnumeratorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketAddressEnumeratorLeaf(args...; kwargs...)
            w = GSocketAddressEnumerator(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketAddressEnumerator] = GSocketAddressEnumeratorLeaf
        function GSocketAddressEnumerator(args...; kwargs...)
            GSocketAddressEnumeratorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GProxyAddressEnumerator <: GSocketAddressEnumerator end
        mutable struct GProxyAddressEnumeratorLeaf <: GProxyAddressEnumerator
            handle::Ptr{GObject}
            function GProxyAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GProxyAddressEnumeratorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GProxyAddressEnumeratorLeaf(args...; kwargs...)
            w = GProxyAddressEnumerator(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GProxyAddressEnumerator] = GProxyAddressEnumeratorLeaf
        function GProxyAddressEnumerator(args...; kwargs...)
            GProxyAddressEnumeratorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GResolver <: GObject end
        mutable struct GResolverLeaf <: GResolver
            handle::Ptr{GObject}
            function GResolverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GResolverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GResolverLeaf(args...; kwargs...)
            w = GResolver(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GResolver] = GResolverLeaf
        function GResolver(args...; kwargs...)
            GResolverLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSettings <: GObject end
        mutable struct GSettingsLeaf <: GSettings
            handle::Ptr{GObject}
            function GSettingsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSettingsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSettingsLeaf(args...; kwargs...)
            w = GSettings(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSettings] = GSettingsLeaf
        function GSettings(args...; kwargs...)
            GSettingsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSettingsBackend <: GObject end
        mutable struct GSettingsBackendLeaf <: GSettingsBackend
            handle::Ptr{GObject}
            function GSettingsBackendLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSettingsBackendLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSettingsBackendLeaf(args...; kwargs...)
            w = GSettingsBackend(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSettingsBackend] = GSettingsBackendLeaf
        function GSettingsBackend(args...; kwargs...)
            GSettingsBackendLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleAction <: GObject end
        mutable struct GSimpleActionLeaf <: GSimpleAction
            handle::Ptr{GObject}
            function GSimpleActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleActionLeaf(args...; kwargs...)
            w = GSimpleAction(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleAction] = GSimpleActionLeaf
        function GSimpleAction(args...; kwargs...)
            GSimpleActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleActionGroup <: GObject end
        mutable struct GSimpleActionGroupLeaf <: GSimpleActionGroup
            handle::Ptr{GObject}
            function GSimpleActionGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleActionGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleActionGroupLeaf(args...; kwargs...)
            w = GSimpleActionGroup(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleActionGroup] = GSimpleActionGroupLeaf
        function GSimpleActionGroup(args...; kwargs...)
            GSimpleActionGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleAsyncResult <: GObject end
        mutable struct GSimpleAsyncResultLeaf <: GSimpleAsyncResult
            handle::Ptr{GObject}
            function GSimpleAsyncResultLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleAsyncResultLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleAsyncResultLeaf(args...; kwargs...)
            w = GSimpleAsyncResult(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleAsyncResult] = GSimpleAsyncResultLeaf
        function GSimpleAsyncResult(args...; kwargs...)
            GSimpleAsyncResultLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleIOStream <: GIOStream end
        mutable struct GSimpleIOStreamLeaf <: GSimpleIOStream
            handle::Ptr{GObject}
            function GSimpleIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleIOStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleIOStreamLeaf(args...; kwargs...)
            w = GSimpleIOStream(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleIOStream] = GSimpleIOStreamLeaf
        function GSimpleIOStream(args...; kwargs...)
            GSimpleIOStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimplePermission <: GPermission end
        mutable struct GSimplePermissionLeaf <: GSimplePermission
            handle::Ptr{GObject}
            function GSimplePermissionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimplePermissionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimplePermissionLeaf(args...; kwargs...)
            w = GSimplePermission(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimplePermission] = GSimplePermissionLeaf
        function GSimplePermission(args...; kwargs...)
            GSimplePermissionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleProxyResolver <: GObject end
        mutable struct GSimpleProxyResolverLeaf <: GSimpleProxyResolver
            handle::Ptr{GObject}
            function GSimpleProxyResolverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleProxyResolverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleProxyResolverLeaf(args...; kwargs...)
            w = GSimpleProxyResolver(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleProxyResolver] = GSimpleProxyResolverLeaf
        function GSimpleProxyResolver(args...; kwargs...)
            GSimpleProxyResolverLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocket <: GObject end
        mutable struct GSocketLeaf <: GSocket
            handle::Ptr{GObject}
            function GSocketLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketLeaf(args...; kwargs...)
            w = GSocket(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocket] = GSocketLeaf
        function GSocket(args...; kwargs...)
            GSocketLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketClient <: GObject end
        mutable struct GSocketClientLeaf <: GSocketClient
            handle::Ptr{GObject}
            function GSocketClientLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketClientLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketClientLeaf(args...; kwargs...)
            w = GSocketClient(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketClient] = GSocketClientLeaf
        function GSocketClient(args...; kwargs...)
            GSocketClientLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketConnection <: GIOStream end
        mutable struct GSocketConnectionLeaf <: GSocketConnection
            handle::Ptr{GObject}
            function GSocketConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketConnectionLeaf(args...; kwargs...)
            w = GSocketConnection(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketConnection] = GSocketConnectionLeaf
        function GSocketConnection(args...; kwargs...)
            GSocketConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketControlMessage <: GObject end
        mutable struct GSocketControlMessageLeaf <: GSocketControlMessage
            handle::Ptr{GObject}
            function GSocketControlMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketControlMessageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketControlMessageLeaf(args...; kwargs...)
            w = GSocketControlMessage(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketControlMessage] = GSocketControlMessageLeaf
        function GSocketControlMessage(args...; kwargs...)
            GSocketControlMessageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketListener <: GObject end
        mutable struct GSocketListenerLeaf <: GSocketListener
            handle::Ptr{GObject}
            function GSocketListenerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketListenerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketListenerLeaf(args...; kwargs...)
            w = GSocketListener(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketListener] = GSocketListenerLeaf
        function GSocketListener(args...; kwargs...)
            GSocketListenerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketService <: GSocketListener end
        mutable struct GSocketServiceLeaf <: GSocketService
            handle::Ptr{GObject}
            function GSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketServiceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketServiceLeaf(args...; kwargs...)
            w = GSocketService(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketService] = GSocketServiceLeaf
        function GSocketService(args...; kwargs...)
            GSocketServiceLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSubprocess <: GObject end
        mutable struct GSubprocessLeaf <: GSubprocess
            handle::Ptr{GObject}
            function GSubprocessLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSubprocessLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSubprocessLeaf(args...; kwargs...)
            w = GSubprocess(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSubprocess] = GSubprocessLeaf
        function GSubprocess(args...; kwargs...)
            GSubprocessLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSubprocessLauncher <: GObject end
        mutable struct GSubprocessLauncherLeaf <: GSubprocessLauncher
            handle::Ptr{GObject}
            function GSubprocessLauncherLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSubprocessLauncherLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSubprocessLauncherLeaf(args...; kwargs...)
            w = GSubprocessLauncher(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSubprocessLauncher] = GSubprocessLauncherLeaf
        function GSubprocessLauncher(args...; kwargs...)
            GSubprocessLauncherLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTask <: GObject end
        mutable struct GTaskLeaf <: GTask
            handle::Ptr{GObject}
            function GTaskLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTaskLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTaskLeaf(args...; kwargs...)
            w = GTask(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTask] = GTaskLeaf
        function GTask(args...; kwargs...)
            GTaskLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTcpConnection <: GSocketConnection end
        mutable struct GTcpConnectionLeaf <: GTcpConnection
            handle::Ptr{GObject}
            function GTcpConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTcpConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTcpConnectionLeaf(args...; kwargs...)
            w = GTcpConnection(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTcpConnection] = GTcpConnectionLeaf
        function GTcpConnection(args...; kwargs...)
            GTcpConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTcpWrapperConnection <: GTcpConnection end
        mutable struct GTcpWrapperConnectionLeaf <: GTcpWrapperConnection
            handle::Ptr{GObject}
            function GTcpWrapperConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTcpWrapperConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTcpWrapperConnectionLeaf(args...; kwargs...)
            w = GTcpWrapperConnection(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTcpWrapperConnection] = GTcpWrapperConnectionLeaf
        function GTcpWrapperConnection(args...; kwargs...)
            GTcpWrapperConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTestDBus <: GObject end
        mutable struct GTestDBusLeaf <: GTestDBus
            handle::Ptr{GObject}
            function GTestDBusLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTestDBusLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTestDBusLeaf(args...; kwargs...)
            w = GTestDBus(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTestDBus] = GTestDBusLeaf
        function GTestDBus(args...; kwargs...)
            GTestDBusLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GThemedIcon <: GObject end
        mutable struct GThemedIconLeaf <: GThemedIcon
            handle::Ptr{GObject}
            function GThemedIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GThemedIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GThemedIconLeaf(args...; kwargs...)
            w = GThemedIcon(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GThemedIcon] = GThemedIconLeaf
        function GThemedIcon(args...; kwargs...)
            GThemedIconLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GThreadedSocketService <: GSocketService end
        mutable struct GThreadedSocketServiceLeaf <: GThreadedSocketService
            handle::Ptr{GObject}
            function GThreadedSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GThreadedSocketServiceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GThreadedSocketServiceLeaf(args...; kwargs...)
            w = GThreadedSocketService(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GThreadedSocketService] = GThreadedSocketServiceLeaf
        function GThreadedSocketService(args...; kwargs...)
            GThreadedSocketServiceLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsCertificate <: GObject end
        mutable struct GTlsCertificateLeaf <: GTlsCertificate
            handle::Ptr{GObject}
            function GTlsCertificateLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsCertificateLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsCertificateLeaf(args...; kwargs...)
            w = GTlsCertificate(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsCertificate] = GTlsCertificateLeaf
        function GTlsCertificate(args...; kwargs...)
            GTlsCertificateLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsConnection <: GIOStream end
        mutable struct GTlsConnectionLeaf <: GTlsConnection
            handle::Ptr{GObject}
            function GTlsConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsConnectionLeaf(args...; kwargs...)
            w = GTlsConnection(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsConnection] = GTlsConnectionLeaf
        function GTlsConnection(args...; kwargs...)
            GTlsConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsDatabase <: GObject end
        mutable struct GTlsDatabaseLeaf <: GTlsDatabase
            handle::Ptr{GObject}
            function GTlsDatabaseLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsDatabaseLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsDatabaseLeaf(args...; kwargs...)
            w = GTlsDatabase(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsDatabase] = GTlsDatabaseLeaf
        function GTlsDatabase(args...; kwargs...)
            GTlsDatabaseLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsInteraction <: GObject end
        mutable struct GTlsInteractionLeaf <: GTlsInteraction
            handle::Ptr{GObject}
            function GTlsInteractionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsInteractionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsInteractionLeaf(args...; kwargs...)
            w = GTlsInteraction(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsInteraction] = GTlsInteractionLeaf
        function GTlsInteraction(args...; kwargs...)
            GTlsInteractionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsPassword <: GObject end
        mutable struct GTlsPasswordLeaf <: GTlsPassword
            handle::Ptr{GObject}
            function GTlsPasswordLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsPasswordLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsPasswordLeaf(args...; kwargs...)
            w = GTlsPassword(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsPassword] = GTlsPasswordLeaf
        function GTlsPassword(args...; kwargs...)
            GTlsPasswordLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GUnixConnection <: GSocketConnection end
        mutable struct GUnixConnectionLeaf <: GUnixConnection
            handle::Ptr{GObject}
            function GUnixConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixConnectionLeaf(args...; kwargs...)
            w = GUnixConnection(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixConnection] = GUnixConnectionLeaf
        function GUnixConnection(args...; kwargs...)
            GUnixConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GUnixCredentialsMessage <: GSocketControlMessage end
        mutable struct GUnixCredentialsMessageLeaf <: GUnixCredentialsMessage
            handle::Ptr{GObject}
            function GUnixCredentialsMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixCredentialsMessageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixCredentialsMessageLeaf(args...; kwargs...)
            w = GUnixCredentialsMessage(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixCredentialsMessage] = GUnixCredentialsMessageLeaf
        function GUnixCredentialsMessage(args...; kwargs...)
            GUnixCredentialsMessageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GVfs <: GObject end
        mutable struct GVfsLeaf <: GVfs
            handle::Ptr{GObject}
            function GVfsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GVfsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GVfsLeaf(args...; kwargs...)
            w = GVfs(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GVfs] = GVfsLeaf
        function GVfs(args...; kwargs...)
            GVfsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GZlibCompressor <: GObject end
        mutable struct GZlibCompressorLeaf <: GZlibCompressor
            handle::Ptr{GObject}
            function GZlibCompressorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GZlibCompressorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GZlibCompressorLeaf(args...; kwargs...)
            w = GZlibCompressor(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GZlibCompressor] = GZlibCompressorLeaf
        function GZlibCompressor(args...; kwargs...)
            GZlibCompressorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GZlibDecompressor <: GObject end
        mutable struct GZlibDecompressorLeaf <: GZlibDecompressor
            handle::Ptr{GObject}
            function GZlibDecompressorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GZlibDecompressorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GZlibDecompressorLeaf(args...; kwargs...)
            w = GZlibDecompressor(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GZlibDecompressor] = GZlibDecompressorLeaf
        function GZlibDecompressor(args...; kwargs...)
            GZlibDecompressorLeaf(args...; kwargs...)
        end
    end
    begin
        struct GAction <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GAction(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GActionGroup <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GActionGroup(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GActionMap <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GActionMap(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GAppInfo <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GAppInfo(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GAsyncInitable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GAsyncInitable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GAsyncResult <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GAsyncResult(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GConverter <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GConverter(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDBusInterface <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDBusInterface(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDBusObject <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDBusObject(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDBusObjectManager <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDBusObjectManager(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDatagramBased <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDatagramBased(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDrive <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDrive(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDtlsClientConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDtlsClientConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDtlsConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDtlsConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDtlsServerConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDtlsServerConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GFile <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GFile(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GFileDescriptorBased <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GFileDescriptorBased(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GIcon <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GIcon(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GInitable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GInitable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GListModel <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GListModel(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GLoadableIcon <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GLoadableIcon(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GMemoryMonitor <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GMemoryMonitor(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GMount <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GMount(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GNetworkMonitor <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GNetworkMonitor(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GPollableInputStream <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GPollableInputStream(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GPollableOutputStream <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GPollableOutputStream(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GProxy <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GProxy(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GProxyResolver <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GProxyResolver(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GRemoteActionGroup <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GRemoteActionGroup(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GSeekable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GSeekable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GSocketConnectable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GSocketConnectable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GTlsBackend <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GTlsBackend(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GTlsClientConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GTlsClientConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GTlsFileDatabase <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GTlsFileDatabase(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GTlsServerConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GTlsServerConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GVolume <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GVolume(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    export GDBusErrorEntry, _GDBusErrorEntry, GFileAttributeInfo, _GFileAttributeInfo, GFileAttributeInfoList, _GFileAttributeInfoList, GFileAttributeMatcher, GInputVector, _GInputVector, GOutputVector, _GOutputVector, GResource, GSettingsSchema, GSettingsSchemaKey, GSettingsSchemaSource, GSrvTarget, GAppInfoMonitor, GAppLaunchContext, GApplication, GApplicationCommandLine, GBufferedInputStream, GBufferedOutputStream, GBytesIcon, GCancellable, GCharsetConverter, GConverterInputStream, GConverterOutputStream, GCredentials, GDBusActionGroup, GDBusAuthObserver, GDBusConnection, GDBusInterfaceSkeleton, GDBusMenuModel, GDBusMessage, GDBusMethodInvocation, GDBusObjectManagerClient, GDBusObjectManagerServer, GDBusObjectProxy, GDBusObjectSkeleton, GDBusProxy, GDBusServer, GDataInputStream, GDataOutputStream, GDesktopAppInfo, GEmblem, GEmblemedIcon, GFileEnumerator, GFileIOStream, GFileIcon, GFileInfo, GFileInputStream, GFileMonitor, GFileOutputStream, GFilenameCompleter, GFilterInputStream, GFilterOutputStream, GIOModule, GIOStream, GInetAddress, GInetAddressMask, GInetSocketAddress, GInputStream, GListStore, GMemoryInputStream, GMemoryOutputStream, GMenu, GMenuAttributeIter, GMenuItem, GMenuLinkIter, GMenuModel, GMountOperation, GNativeSocketAddress, GNativeVolumeMonitor, GNetworkAddress, GNetworkService, GNotification, GOutputStream, GPermission, GPropertyAction, GProxyAddress, GProxyAddressEnumerator, GResolver, GSettings, GSettingsBackend, GSimpleAction, GSimpleActionGroup, GSimpleAsyncResult, GSimpleIOStream, GSimplePermission, GSimpleProxyResolver, GSocket, GSocketAddress, GSocketAddressEnumerator, GSocketClient, GSocketConnection, GSocketControlMessage, GSocketListener, GSocketService, GSubprocess, GSubprocessLauncher, GTask, GTcpConnection, GTcpWrapperConnection, GTestDBus, GThemedIcon, GThreadedSocketService, GTlsCertificate, GTlsConnection, GTlsDatabase, GTlsInteraction, GTlsPassword, GUnixConnection, GUnixCredentialsMessage, GVfs, GVolumeMonitor, GZlibCompressor, GZlibDecompressor, GAction, GActionGroup, GActionMap, GAppInfo, GAsyncInitable, GAsyncResult, GConverter, GDBusInterface, GDBusObject, GDBusObjectManager, GDatagramBased, GDrive, GDtlsClientConnection, GDtlsConnection, GDtlsServerConnection, GFile, GFileDescriptorBased, GIcon, GInitable, GListModel, GLoadableIcon, GMemoryMonitor, GMount, GNetworkMonitor, GPollableInputStream, GPollableOutputStream, GProxy, GProxyResolver, GRemoteActionGroup, GSeekable, GSocketConnectable, GTlsBackend, GTlsClientConnection, GTlsFileDatabase, GTlsServerConnection, GVolume
end))
end
