quote
$(Expr(:toplevel, quote
    begin
        struct _GDBusErrorEntry
            error_code::Int32
            dbus_error_name::Cstring
        end
        begin
            mutable struct GDBusErrorEntry
                handle::Ptr{_GDBusErrorEntry}
            end
        end
    end
    begin
        struct _GFileAttributeInfo
            name::Cstring
            type::Int32
            flags::Int32
        end
        begin
            mutable struct GFileAttributeInfo
                handle::Ptr{_GFileAttributeInfo}
            end
        end
    end
    begin
        struct _GFileAttributeInfoList
            infos::Ptr{GFileAttributeInfo}
            n_infos::Int32
        end
        begin
            mutable struct GFileAttributeInfoList <: GBoxed
                handle::Ptr{_GFileAttributeInfoList}
                begin
                    (GLib.g_type(::Type{T}) where T <: GFileAttributeInfoList) = begin
                            ccall(("g_file_attribute_info_list_get_type", libgio), GType, ())
                        end
                    function GFileAttributeInfoList(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                        x = new(ref)
                        if own
                            finalizer(x) do x
                                GLib.delboxed(x)
                            end
                        end
                        x
                    end
                    push!(gboxed_types, GFileAttributeInfoList)
                end
            end
        end
    end
    mutable struct GFileAttributeMatcher <: GBoxed
        handle::Ptr{GFileAttributeMatcher}
        begin
            (GLib.g_type(::Type{T}) where T <: GFileAttributeMatcher) = begin
                    ccall(("g_file_attribute_matcher_get_type", libgio), GType, ())
                end
            function GFileAttributeMatcher(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GFileAttributeMatcher)
        end
    end
    begin
        struct _GInputVector
            buffer::Ptr{Nothing}
            size::UInt64
        end
        begin
            mutable struct GInputVector
                handle::Ptr{_GInputVector}
            end
        end
    end
    begin
        struct _GOutputVector
            buffer::Ptr{Nothing}
            size::UInt64
        end
        begin
            mutable struct GOutputVector
                handle::Ptr{_GOutputVector}
            end
        end
    end
    mutable struct GResource <: GBoxed
        handle::Ptr{GResource}
        begin
            (GLib.g_type(::Type{T}) where T <: GResource) = begin
                    ccall(("g_resource_get_type", libgio), GType, ())
                end
            function GResource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GResource)
        end
    end
    mutable struct GSettingsSchema <: GBoxed
        handle::Ptr{GSettingsSchema}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchema) = begin
                    ccall(("g_settings_schema_get_type", libgio), GType, ())
                end
            function GSettingsSchema(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchema)
        end
    end
    mutable struct GSettingsSchemaKey <: GBoxed
        handle::Ptr{GSettingsSchemaKey}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchemaKey) = begin
                    ccall(("g_settings_schema_key_get_type", libgio), GType, ())
                end
            function GSettingsSchemaKey(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchemaKey)
        end
    end
    mutable struct GSettingsSchemaSource <: GBoxed
        handle::Ptr{GSettingsSchemaSource}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchemaSource) = begin
                    ccall(("g_settings_schema_source_get_type", libgio), GType, ())
                end
            function GSettingsSchemaSource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchemaSource)
        end
    end
    mutable struct GSrvTarget <: GBoxed
        handle::Ptr{GSrvTarget}
        begin
            (GLib.g_type(::Type{T}) where T <: GSrvTarget) = begin
                    ccall(("g_srv_target_get_type", libgio), GType, ())
                end
            function GSrvTarget(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSrvTarget)
        end
    end
    mutable struct GUnixMountEntry <: GBoxed
        handle::Ptr{GUnixMountEntry}
        begin
            (GLib.g_type(::Type{T}) where T <: GUnixMountEntry) = begin
                    ccall(("g_unix_mount_entry_get_type", libgio), GType, ())
                end
            function GUnixMountEntry(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GUnixMountEntry)
        end
    end
    mutable struct GUnixMountPoint <: GBoxed
        handle::Ptr{GUnixMountPoint}
        begin
            (GLib.g_type(::Type{T}) where T <: GUnixMountPoint) = begin
                    ccall(("g_unix_mount_point_get_type", libgio), GType, ())
                end
            function GUnixMountPoint(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GUnixMountPoint)
        end
    end
    begin
        gtype_wrapper_cache = Dict{Symbol, Type}()
    end
    begin
        abstract type GAppInfoMonitor <: GObject end
    end
    begin
        mutable struct GAppInfoMonitorLeaf <: GAppInfoMonitor
            handle::Ptr{GObject}
            function GAppInfoMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GAppInfoMonitorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GAppInfoMonitorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GAppInfoMonitorLeaf, args))
            end
            w = GAppInfoMonitorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GAppInfoMonitor] = GAppInfoMonitorLeaf
        function GAppInfoMonitor(args...; kwargs...)
            GAppInfoMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GAppLaunchContext <: GObject end
    end
    begin
        mutable struct GAppLaunchContextLeaf <: GAppLaunchContext
            handle::Ptr{GObject}
            function GAppLaunchContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GAppLaunchContextLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GAppLaunchContextLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GAppLaunchContextLeaf, args))
            end
            w = GAppLaunchContextLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GAppLaunchContext] = GAppLaunchContextLeaf
        function GAppLaunchContext(args...; kwargs...)
            GAppLaunchContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GApplication <: GObject end
    end
    begin
        mutable struct GApplicationLeaf <: GApplication
            handle::Ptr{GObject}
            function GApplicationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GApplicationLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GApplicationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GApplicationLeaf, args))
            end
            w = GApplicationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GApplication] = GApplicationLeaf
        function GApplication(args...; kwargs...)
            GApplicationLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GApplicationLeaf) = begin
                    [:handle, :resource_base_path, :is_remote, :is_busy, :application_id, :flags, :is_registered, :action_group, :inactivity_timeout]
                end
            function Base.getproperty(o::GApplicationLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:resource_base_path => (:String, 0, 3), :is_remote => (:Bool, 0, 1), :is_busy => (:Bool, 0, 1), :application_id => (:String, 0, 7), :flags => (:Int32, 0, 3), :is_registered => (:Bool, 0, 1), :inactivity_timeout => (:UInt32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GApplicationLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:resource_base_path => (:String, 0, 3), :application_id => (:String, 0, 7), :flags => (:Int32, 0, 3), :action_group => (:GActionGroup, 0, 2), :inactivity_timeout => (:UInt32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GApplicationCommandLine <: GObject end
    end
    begin
        mutable struct GApplicationCommandLineLeaf <: GApplicationCommandLine
            handle::Ptr{GObject}
            function GApplicationCommandLineLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GApplicationCommandLineLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GApplicationCommandLineLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GApplicationCommandLineLeaf, args))
            end
            w = GApplicationCommandLineLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GApplicationCommandLine] = GApplicationCommandLineLeaf
        function GApplicationCommandLine(args...; kwargs...)
            GApplicationCommandLineLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GApplicationCommandLineLeaf) = begin
                    [:handle, :is_remote, :options, :platform_data, :arguments]
                end
            function Base.getproperty(o::GApplicationCommandLineLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:is_remote => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GApplicationCommandLineLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:options => (:GVariant, 0, 10), :platform_data => (:GVariant, 0, 10), :arguments => (:GVariant, 0, 10))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GInputStream <: GObject end
    end
    begin
        mutable struct GInputStreamLeaf <: GInputStream
            handle::Ptr{GObject}
            function GInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GInputStreamLeaf, args))
            end
            w = GInputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GInputStream] = GInputStreamLeaf
        function GInputStream(args...; kwargs...)
            GInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFilterInputStream <: GInputStream end
    end
    begin
        mutable struct GFilterInputStreamLeaf <: GFilterInputStream
            handle::Ptr{GObject}
            function GFilterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilterInputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFilterInputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFilterInputStreamLeaf, args))
            end
            w = GFilterInputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFilterInputStream] = GFilterInputStreamLeaf
        function GFilterInputStream(args...; kwargs...)
            GFilterInputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GFilterInputStreamLeaf) = begin
                    [:handle, :close_base_stream, :base_stream]
                end
            function Base.getproperty(o::GFilterInputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 7), :base_stream => (:GInputStream, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GFilterInputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 7), :base_stream => (:GInputStream, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GBufferedInputStream <: GFilterInputStream end
    end
    begin
        mutable struct GBufferedInputStreamLeaf <: GBufferedInputStream
            handle::Ptr{GObject}
            function GBufferedInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBufferedInputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GBufferedInputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GBufferedInputStreamLeaf, args))
            end
            w = GBufferedInputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GBufferedInputStream] = GBufferedInputStreamLeaf
        function GBufferedInputStream(args...; kwargs...)
            GBufferedInputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GBufferedInputStreamLeaf) = begin
                    [:handle, :close_base_stream, :buffer_size, :base_stream]
                end
            function Base.getproperty(o::GBufferedInputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 7), :buffer_size => (:UInt32, 0, 7), :base_stream => (:GInputStream, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GBufferedInputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 7), :buffer_size => (:UInt32, 0, 7), :base_stream => (:GInputStream, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GOutputStream <: GObject end
    end
    begin
        mutable struct GOutputStreamLeaf <: GOutputStream
            handle::Ptr{GObject}
            function GOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GOutputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GOutputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GOutputStreamLeaf, args))
            end
            w = GOutputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GOutputStream] = GOutputStreamLeaf
        function GOutputStream(args...; kwargs...)
            GOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFilterOutputStream <: GOutputStream end
    end
    begin
        mutable struct GFilterOutputStreamLeaf <: GFilterOutputStream
            handle::Ptr{GObject}
            function GFilterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilterOutputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFilterOutputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFilterOutputStreamLeaf, args))
            end
            w = GFilterOutputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFilterOutputStream] = GFilterOutputStreamLeaf
        function GFilterOutputStream(args...; kwargs...)
            GFilterOutputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GFilterOutputStreamLeaf) = begin
                    [:handle, :close_base_stream, :base_stream]
                end
            function Base.getproperty(o::GFilterOutputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 11), :base_stream => (:GOutputStream, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GFilterOutputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 11), :base_stream => (:GOutputStream, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GBufferedOutputStream <: GFilterOutputStream end
    end
    begin
        mutable struct GBufferedOutputStreamLeaf <: GBufferedOutputStream
            handle::Ptr{GObject}
            function GBufferedOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBufferedOutputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GBufferedOutputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GBufferedOutputStreamLeaf, args))
            end
            w = GBufferedOutputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GBufferedOutputStream] = GBufferedOutputStreamLeaf
        function GBufferedOutputStream(args...; kwargs...)
            GBufferedOutputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GBufferedOutputStreamLeaf) = begin
                    [:handle, :close_base_stream, :buffer_size, :auto_grow, :base_stream]
                end
            function Base.getproperty(o::GBufferedOutputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 11), :buffer_size => (:UInt32, 0, 7), :auto_grow => (:Bool, 0, 3), :base_stream => (:GOutputStream, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GBufferedOutputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 11), :buffer_size => (:UInt32, 0, 7), :auto_grow => (:Bool, 0, 3), :base_stream => (:GOutputStream, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GBytesIcon <: GObject end
    end
    begin
        mutable struct GBytesIconLeaf <: GBytesIcon
            handle::Ptr{GObject}
            function GBytesIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBytesIconLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GBytesIconLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GBytesIconLeaf, args))
            end
            w = GBytesIconLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GBytesIcon] = GBytesIconLeaf
        function GBytesIcon(args...; kwargs...)
            GBytesIconLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GBytesIconLeaf) = begin
                    [:handle, :bytes]
                end
            function Base.getproperty(o::GBytesIconLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:bytes => (:GBytes, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GBytesIconLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:bytes => (:GBytes, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GCancellable <: GObject end
    end
    begin
        mutable struct GCancellableLeaf <: GCancellable
            handle::Ptr{GObject}
            function GCancellableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCancellableLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GCancellableLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GCancellableLeaf, args))
            end
            w = GCancellableLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GCancellable] = GCancellableLeaf
        function GCancellable(args...; kwargs...)
            GCancellableLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GCharsetConverter <: GObject end
    end
    begin
        mutable struct GCharsetConverterLeaf <: GCharsetConverter
            handle::Ptr{GObject}
            function GCharsetConverterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCharsetConverterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GCharsetConverterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GCharsetConverterLeaf, args))
            end
            w = GCharsetConverterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GCharsetConverter] = GCharsetConverterLeaf
        function GCharsetConverter(args...; kwargs...)
            GCharsetConverterLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GCharsetConverterLeaf) = begin
                    [:handle, :to_charset, :use_fallback, :from_charset]
                end
            function Base.getproperty(o::GCharsetConverterLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:to_charset => (:String, 0, 11), :use_fallback => (:Bool, 0, 7), :from_charset => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GCharsetConverterLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:to_charset => (:String, 0, 11), :use_fallback => (:Bool, 0, 7), :from_charset => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GConverterInputStream <: GFilterInputStream end
    end
    begin
        mutable struct GConverterInputStreamLeaf <: GConverterInputStream
            handle::Ptr{GObject}
            function GConverterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GConverterInputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GConverterInputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GConverterInputStreamLeaf, args))
            end
            w = GConverterInputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GConverterInputStream] = GConverterInputStreamLeaf
        function GConverterInputStream(args...; kwargs...)
            GConverterInputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GConverterInputStreamLeaf) = begin
                    [:handle, :close_base_stream, :converter, :base_stream]
                end
            function Base.getproperty(o::GConverterInputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 7), :converter => (:GConverter, 0, 11), :base_stream => (:GInputStream, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GConverterInputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 7), :converter => (:GConverter, 0, 11), :base_stream => (:GInputStream, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GConverterOutputStream <: GFilterOutputStream end
    end
    begin
        mutable struct GConverterOutputStreamLeaf <: GConverterOutputStream
            handle::Ptr{GObject}
            function GConverterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GConverterOutputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GConverterOutputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GConverterOutputStreamLeaf, args))
            end
            w = GConverterOutputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GConverterOutputStream] = GConverterOutputStreamLeaf
        function GConverterOutputStream(args...; kwargs...)
            GConverterOutputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GConverterOutputStreamLeaf) = begin
                    [:handle, :close_base_stream, :converter, :base_stream]
                end
            function Base.getproperty(o::GConverterOutputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 11), :converter => (:GConverter, 0, 11), :base_stream => (:GOutputStream, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GConverterOutputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 11), :converter => (:GConverter, 0, 11), :base_stream => (:GOutputStream, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GCredentials <: GObject end
    end
    begin
        mutable struct GCredentialsLeaf <: GCredentials
            handle::Ptr{GObject}
            function GCredentialsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCredentialsLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GCredentialsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GCredentialsLeaf, args))
            end
            w = GCredentialsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GCredentials] = GCredentialsLeaf
        function GCredentials(args...; kwargs...)
            GCredentialsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusActionGroup <: GObject end
    end
    begin
        mutable struct GDBusActionGroupLeaf <: GDBusActionGroup
            handle::Ptr{GObject}
            function GDBusActionGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusActionGroupLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusActionGroupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusActionGroupLeaf, args))
            end
            w = GDBusActionGroupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusActionGroup] = GDBusActionGroupLeaf
        function GDBusActionGroup(args...; kwargs...)
            GDBusActionGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusAuthObserver <: GObject end
    end
    begin
        mutable struct GDBusAuthObserverLeaf <: GDBusAuthObserver
            handle::Ptr{GObject}
            function GDBusAuthObserverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusAuthObserverLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusAuthObserverLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusAuthObserverLeaf, args))
            end
            w = GDBusAuthObserverLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusAuthObserver] = GDBusAuthObserverLeaf
        function GDBusAuthObserver(args...; kwargs...)
            GDBusAuthObserverLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusConnection <: GObject end
    end
    begin
        mutable struct GDBusConnectionLeaf <: GDBusConnection
            handle::Ptr{GObject}
            function GDBusConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusConnectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusConnectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusConnectionLeaf, args))
            end
            w = GDBusConnectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusConnection] = GDBusConnectionLeaf
        function GDBusConnection(args...; kwargs...)
            GDBusConnectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDBusConnectionLeaf) = begin
                    [:handle, :address, :authentication_observer, :capabilities, :exit_on_close, :flags, :guid, :stream, :unique_name, :closed]
                end
            function Base.getproperty(o::GDBusConnectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:exit_on_close => (:Bool, 0, 3), :capabilities => (:Int32, 0, 1), :guid => (:String, 0, 11), :flags => (:Int32, 0, 11), :stream => (:GIOStream, 0, 11), :unique_name => (:String, 0, 1), :closed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDBusConnectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:address => (:String, 0, 10), :authentication_observer => (:GDBusAuthObserver, 0, 10), :exit_on_close => (:Bool, 0, 3), :guid => (:String, 0, 11), :flags => (:Int32, 0, 11), :stream => (:GIOStream, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDBusInterfaceSkeleton <: GObject end
    end
    begin
        mutable struct GDBusInterfaceSkeletonLeaf <: GDBusInterfaceSkeleton
            handle::Ptr{GObject}
            function GDBusInterfaceSkeletonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusInterfaceSkeletonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusInterfaceSkeletonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusInterfaceSkeletonLeaf, args))
            end
            w = GDBusInterfaceSkeletonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusInterfaceSkeleton] = GDBusInterfaceSkeletonLeaf
        function GDBusInterfaceSkeleton(args...; kwargs...)
            GDBusInterfaceSkeletonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDBusInterfaceSkeletonLeaf) = begin
                    [:handle, :g_flags]
                end
            function Base.getproperty(o::GDBusInterfaceSkeletonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:g_flags => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDBusInterfaceSkeletonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:g_flags => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GMenuModel <: GObject end
    end
    begin
        mutable struct GMenuModelLeaf <: GMenuModel
            handle::Ptr{GObject}
            function GMenuModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuModelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GMenuModelLeaf, args))
            end
            w = GMenuModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenuModel] = GMenuModelLeaf
        function GMenuModel(args...; kwargs...)
            GMenuModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusMenuModel <: GMenuModel end
    end
    begin
        mutable struct GDBusMenuModelLeaf <: GDBusMenuModel
            handle::Ptr{GObject}
            function GDBusMenuModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMenuModelLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusMenuModelLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusMenuModelLeaf, args))
            end
            w = GDBusMenuModelLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusMenuModel] = GDBusMenuModelLeaf
        function GDBusMenuModel(args...; kwargs...)
            GDBusMenuModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusMessage <: GObject end
    end
    begin
        mutable struct GDBusMessageLeaf <: GDBusMessage
            handle::Ptr{GObject}
            function GDBusMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMessageLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusMessageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusMessageLeaf, args))
            end
            w = GDBusMessageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusMessage] = GDBusMessageLeaf
        function GDBusMessage(args...; kwargs...)
            GDBusMessageLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDBusMessageLeaf) = begin
                    [:handle, :locked]
                end
            function Base.getproperty(o::GDBusMessageLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:locked => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDBusMessageLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDBusMethodInvocation <: GObject end
    end
    begin
        mutable struct GDBusMethodInvocationLeaf <: GDBusMethodInvocation
            handle::Ptr{GObject}
            function GDBusMethodInvocationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMethodInvocationLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusMethodInvocationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusMethodInvocationLeaf, args))
            end
            w = GDBusMethodInvocationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusMethodInvocation] = GDBusMethodInvocationLeaf
        function GDBusMethodInvocation(args...; kwargs...)
            GDBusMethodInvocationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusObjectManagerClient <: GObject end
    end
    begin
        mutable struct GDBusObjectManagerClientLeaf <: GDBusObjectManagerClient
            handle::Ptr{GObject}
            function GDBusObjectManagerClientLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectManagerClientLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectManagerClientLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusObjectManagerClientLeaf, args))
            end
            w = GDBusObjectManagerClientLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusObjectManagerClient] = GDBusObjectManagerClientLeaf
        function GDBusObjectManagerClient(args...; kwargs...)
            GDBusObjectManagerClientLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDBusObjectManagerClientLeaf) = begin
                    [:handle, :bus_type, :flags, :name, :name_owner, :object_path, :get_proxy_type_func, :connection, :get_proxy_type_user_data, :get_proxy_type_destroy_notify]
                end
            function Base.getproperty(o::GDBusObjectManagerClientLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:flags => (:Int32, 0, 11), :name => (:String, 0, 11), :name_owner => (:String, 0, 1), :object_path => (:String, 0, 11), :get_proxy_type_func => (:Nothing, 0, 11), :connection => (:GDBusConnection, 0, 11), :get_proxy_type_user_data => (:Nothing, 0, 11), :get_proxy_type_destroy_notify => (:Nothing, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDBusObjectManagerClientLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:get_proxy_type_destroy_notify => (:Nothing, 0, 11), :flags => (:Int32, 0, 11), :name => (:String, 0, 11), :object_path => (:String, 0, 11), :get_proxy_type_func => (:Nothing, 0, 11), :bus_type => (:BusType, 0, 10), :connection => (:GDBusConnection, 0, 11), :get_proxy_type_user_data => (:Nothing, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDBusObjectManagerServer <: GObject end
    end
    begin
        mutable struct GDBusObjectManagerServerLeaf <: GDBusObjectManagerServer
            handle::Ptr{GObject}
            function GDBusObjectManagerServerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectManagerServerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectManagerServerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusObjectManagerServerLeaf, args))
            end
            w = GDBusObjectManagerServerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusObjectManagerServer] = GDBusObjectManagerServerLeaf
        function GDBusObjectManagerServer(args...; kwargs...)
            GDBusObjectManagerServerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDBusObjectManagerServerLeaf) = begin
                    [:handle, :object_path, :connection]
                end
            function Base.getproperty(o::GDBusObjectManagerServerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:object_path => (:String, 0, 11), :connection => (:GDBusConnection, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDBusObjectManagerServerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:object_path => (:String, 0, 11), :connection => (:GDBusConnection, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDBusObjectProxy <: GObject end
    end
    begin
        mutable struct GDBusObjectProxyLeaf <: GDBusObjectProxy
            handle::Ptr{GObject}
            function GDBusObjectProxyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectProxyLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectProxyLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusObjectProxyLeaf, args))
            end
            w = GDBusObjectProxyLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusObjectProxy] = GDBusObjectProxyLeaf
        function GDBusObjectProxy(args...; kwargs...)
            GDBusObjectProxyLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDBusObjectProxyLeaf) = begin
                    [:handle, :g_object_path, :g_connection]
                end
            function Base.getproperty(o::GDBusObjectProxyLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:g_object_path => (:String, 0, 11), :g_connection => (:GDBusConnection, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDBusObjectProxyLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:g_object_path => (:String, 0, 11), :g_connection => (:GDBusConnection, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDBusObjectSkeleton <: GObject end
    end
    begin
        mutable struct GDBusObjectSkeletonLeaf <: GDBusObjectSkeleton
            handle::Ptr{GObject}
            function GDBusObjectSkeletonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectSkeletonLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectSkeletonLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusObjectSkeletonLeaf, args))
            end
            w = GDBusObjectSkeletonLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusObjectSkeleton] = GDBusObjectSkeletonLeaf
        function GDBusObjectSkeleton(args...; kwargs...)
            GDBusObjectSkeletonLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDBusObjectSkeletonLeaf) = begin
                    [:handle, :g_object_path]
                end
            function Base.getproperty(o::GDBusObjectSkeletonLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:g_object_path => (:String, 0, 7))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDBusObjectSkeletonLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:g_object_path => (:String, 0, 7))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDBusProxy <: GObject end
    end
    begin
        mutable struct GDBusProxyLeaf <: GDBusProxy
            handle::Ptr{GObject}
            function GDBusProxyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusProxyLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusProxyLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusProxyLeaf, args))
            end
            w = GDBusProxyLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusProxy] = GDBusProxyLeaf
        function GDBusProxy(args...; kwargs...)
            GDBusProxyLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDBusProxyLeaf) = begin
                    [:handle, :g_name_owner, :g_bus_type, :g_default_timeout, :g_interface_name, :g_interface_info, :g_object_path, :g_flags, :g_connection, :g_name]
                end
            function Base.getproperty(o::GDBusProxyLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:g_name_owner => (:String, 0, 1), :g_interface_name => (:String, 0, 11), :g_default_timeout => (:Int32, 0, 7), :g_interface_info => (:GDBusInterfaceInfo, 0, 3), :g_object_path => (:String, 0, 11), :g_flags => (:Int32, 0, 11), :g_connection => (:GDBusConnection, 0, 11), :g_name => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDBusProxyLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:g_bus_type => (:BusType, 0, 10), :g_default_timeout => (:Int32, 0, 7), :g_interface_name => (:String, 0, 11), :g_interface_info => (:GDBusInterfaceInfo, 0, 3), :g_object_path => (:String, 0, 11), :g_flags => (:Int32, 0, 11), :g_connection => (:GDBusConnection, 0, 11), :g_name => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDBusServer <: GObject end
    end
    begin
        mutable struct GDBusServerLeaf <: GDBusServer
            handle::Ptr{GObject}
            function GDBusServerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusServerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusServerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDBusServerLeaf, args))
            end
            w = GDBusServerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDBusServer] = GDBusServerLeaf
        function GDBusServer(args...; kwargs...)
            GDBusServerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDBusServerLeaf) = begin
                    [:handle, :client_address, :address, :authentication_observer, :guid, :active, :flags]
                end
            function Base.getproperty(o::GDBusServerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:client_address => (:String, 0, 1), :address => (:String, 0, 11), :authentication_observer => (:GDBusAuthObserver, 0, 11), :guid => (:String, 0, 11), :active => (:Bool, 0, 1), :flags => (:Int32, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDBusServerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:address => (:String, 0, 11), :authentication_observer => (:GDBusAuthObserver, 0, 11), :guid => (:String, 0, 11), :flags => (:Int32, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDataInputStream <: GBufferedInputStream end
    end
    begin
        mutable struct GDataInputStreamLeaf <: GDataInputStream
            handle::Ptr{GObject}
            function GDataInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDataInputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDataInputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDataInputStreamLeaf, args))
            end
            w = GDataInputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDataInputStream] = GDataInputStreamLeaf
        function GDataInputStream(args...; kwargs...)
            GDataInputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDataInputStreamLeaf) = begin
                    [:handle, :close_base_stream, :newline_type, :buffer_size, :base_stream, :byte_order]
                end
            function Base.getproperty(o::GDataInputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 7), :newline_type => (:DataStreamNewlineType, 0, 3), :buffer_size => (:UInt32, 0, 7), :base_stream => (:GInputStream, 0, 11), :byte_order => (:DataStreamByteOrder, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDataInputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 7), :newline_type => (:DataStreamNewlineType, 0, 3), :buffer_size => (:UInt32, 0, 7), :base_stream => (:GInputStream, 0, 11), :byte_order => (:DataStreamByteOrder, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDataOutputStream <: GFilterOutputStream end
    end
    begin
        mutable struct GDataOutputStreamLeaf <: GDataOutputStream
            handle::Ptr{GObject}
            function GDataOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDataOutputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDataOutputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDataOutputStreamLeaf, args))
            end
            w = GDataOutputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDataOutputStream] = GDataOutputStreamLeaf
        function GDataOutputStream(args...; kwargs...)
            GDataOutputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDataOutputStreamLeaf) = begin
                    [:handle, :close_base_stream, :base_stream, :byte_order]
                end
            function Base.getproperty(o::GDataOutputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 11), :base_stream => (:GOutputStream, 0, 11), :byte_order => (:DataStreamByteOrder, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDataOutputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_base_stream => (:Bool, 0, 11), :base_stream => (:GOutputStream, 0, 11), :byte_order => (:DataStreamByteOrder, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GDesktopAppInfo <: GObject end
    end
    begin
        mutable struct GDesktopAppInfoLeaf <: GDesktopAppInfo
            handle::Ptr{GObject}
            function GDesktopAppInfoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDesktopAppInfoLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDesktopAppInfoLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GDesktopAppInfoLeaf, args))
            end
            w = GDesktopAppInfoLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GDesktopAppInfo] = GDesktopAppInfoLeaf
        function GDesktopAppInfo(args...; kwargs...)
            GDesktopAppInfoLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GDesktopAppInfoLeaf) = begin
                    [:handle, :filename]
                end
            function Base.getproperty(o::GDesktopAppInfoLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:filename => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GDesktopAppInfoLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:filename => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GEmblem <: GObject end
    end
    begin
        mutable struct GEmblemLeaf <: GEmblem
            handle::Ptr{GObject}
            function GEmblemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GEmblemLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GEmblemLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GEmblemLeaf, args))
            end
            w = GEmblemLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GEmblem] = GEmblemLeaf
        function GEmblem(args...; kwargs...)
            GEmblemLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GEmblemLeaf) = begin
                    [:handle, :origin, :icon]
                end
            function Base.getproperty(o::GEmblemLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:origin => (:EmblemOrigin, 0, 11), :icon => (:GObject, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GEmblemLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:origin => (:EmblemOrigin, 0, 11), :icon => (:GObject, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GEmblemedIcon <: GObject end
    end
    begin
        mutable struct GEmblemedIconLeaf <: GEmblemedIcon
            handle::Ptr{GObject}
            function GEmblemedIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GEmblemedIconLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GEmblemedIconLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GEmblemedIconLeaf, args))
            end
            w = GEmblemedIconLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GEmblemedIcon] = GEmblemedIconLeaf
        function GEmblemedIcon(args...; kwargs...)
            GEmblemedIconLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GEmblemedIconLeaf) = begin
                    [:handle, :gicon]
                end
            function Base.getproperty(o::GEmblemedIconLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:gicon => (:GIcon, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GEmblemedIconLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:gicon => (:GIcon, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GFileEnumerator <: GObject end
    end
    begin
        mutable struct GFileEnumeratorLeaf <: GFileEnumerator
            handle::Ptr{GObject}
            function GFileEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileEnumeratorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileEnumeratorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFileEnumeratorLeaf, args))
            end
            w = GFileEnumeratorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileEnumerator] = GFileEnumeratorLeaf
        function GFileEnumerator(args...; kwargs...)
            GFileEnumeratorLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GFileEnumeratorLeaf) = begin
                    [:handle, :container]
                end
            function Base.getproperty(o::GFileEnumeratorLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GFileEnumeratorLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:container => (:GFile, 0, 10))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GIOStream <: GObject end
    end
    begin
        mutable struct GIOStreamLeaf <: GIOStream
            handle::Ptr{GObject}
            function GIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GIOStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GIOStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GIOStreamLeaf, args))
            end
            w = GIOStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GIOStream] = GIOStreamLeaf
        function GIOStream(args...; kwargs...)
            GIOStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GIOStreamLeaf) = begin
                    [:handle, :output_stream, :input_stream, :closed]
                end
            function Base.getproperty(o::GIOStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:output_stream => (:GOutputStream, 0, 1), :input_stream => (:GInputStream, 0, 1), :closed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GIOStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GFileIOStream <: GIOStream end
    end
    begin
        mutable struct GFileIOStreamLeaf <: GFileIOStream
            handle::Ptr{GObject}
            function GFileIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileIOStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileIOStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFileIOStreamLeaf, args))
            end
            w = GFileIOStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileIOStream] = GFileIOStreamLeaf
        function GFileIOStream(args...; kwargs...)
            GFileIOStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GFileIOStreamLeaf) = begin
                    [:handle, :output_stream, :input_stream, :closed]
                end
            function Base.getproperty(o::GFileIOStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:output_stream => (:GOutputStream, 0, 1), :input_stream => (:GInputStream, 0, 1), :closed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GFileIOStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GFileIcon <: GObject end
    end
    begin
        mutable struct GFileIconLeaf <: GFileIcon
            handle::Ptr{GObject}
            function GFileIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileIconLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileIconLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFileIconLeaf, args))
            end
            w = GFileIconLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileIcon] = GFileIconLeaf
        function GFileIcon(args...; kwargs...)
            GFileIconLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GFileIconLeaf) = begin
                    [:handle, :file]
                end
            function Base.getproperty(o::GFileIconLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:file => (:GFile, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GFileIconLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:file => (:GFile, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GFileInfo <: GObject end
    end
    begin
        mutable struct GFileInfoLeaf <: GFileInfo
            handle::Ptr{GObject}
            function GFileInfoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileInfoLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileInfoLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFileInfoLeaf, args))
            end
            w = GFileInfoLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileInfo] = GFileInfoLeaf
        function GFileInfo(args...; kwargs...)
            GFileInfoLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileInputStream <: GInputStream end
    end
    begin
        mutable struct GFileInputStreamLeaf <: GFileInputStream
            handle::Ptr{GObject}
            function GFileInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileInputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileInputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFileInputStreamLeaf, args))
            end
            w = GFileInputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileInputStream] = GFileInputStreamLeaf
        function GFileInputStream(args...; kwargs...)
            GFileInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileMonitor <: GObject end
    end
    begin
        mutable struct GFileMonitorLeaf <: GFileMonitor
            handle::Ptr{GObject}
            function GFileMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileMonitorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileMonitorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFileMonitorLeaf, args))
            end
            w = GFileMonitorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileMonitor] = GFileMonitorLeaf
        function GFileMonitor(args...; kwargs...)
            GFileMonitorLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GFileMonitorLeaf) = begin
                    [:handle, :cancelled, :rate_limit]
                end
            function Base.getproperty(o::GFileMonitorLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:cancelled => (:Bool, 0, 1), :rate_limit => (:Int32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GFileMonitorLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:rate_limit => (:Int32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GFileOutputStream <: GOutputStream end
    end
    begin
        mutable struct GFileOutputStreamLeaf <: GFileOutputStream
            handle::Ptr{GObject}
            function GFileOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileOutputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileOutputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFileOutputStreamLeaf, args))
            end
            w = GFileOutputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFileOutputStream] = GFileOutputStreamLeaf
        function GFileOutputStream(args...; kwargs...)
            GFileOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFilenameCompleter <: GObject end
    end
    begin
        mutable struct GFilenameCompleterLeaf <: GFilenameCompleter
            handle::Ptr{GObject}
            function GFilenameCompleterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilenameCompleterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFilenameCompleterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GFilenameCompleterLeaf, args))
            end
            w = GFilenameCompleterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GFilenameCompleter] = GFilenameCompleterLeaf
        function GFilenameCompleter(args...; kwargs...)
            GFilenameCompleterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GIOModule <: GTypeModule end
    end
    begin
        mutable struct GIOModuleLeaf <: GIOModule
            handle::Ptr{GObject}
            function GIOModuleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GIOModuleLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GIOModuleLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GIOModuleLeaf, args))
            end
            w = GIOModuleLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GIOModule] = GIOModuleLeaf
        function GIOModule(args...; kwargs...)
            GIOModuleLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GInetAddress <: GObject end
    end
    begin
        mutable struct GInetAddressLeaf <: GInetAddress
            handle::Ptr{GObject}
            function GInetAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetAddressLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInetAddressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GInetAddressLeaf, args))
            end
            w = GInetAddressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GInetAddress] = GInetAddressLeaf
        function GInetAddress(args...; kwargs...)
            GInetAddressLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GInetAddressLeaf) = begin
                    [:handle, :is_loopback, :is_any, :is_mc_global, :is_multicast, :is_site_local, :is_mc_org_local, :is_mc_link_local, :is_mc_node_local, :bytes, :is_mc_site_local, :is_link_local, :family]
                end
            function Base.getproperty(o::GInetAddressLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:is_loopback => (:Bool, 0, 1), :is_any => (:Bool, 0, 1), :is_mc_global => (:Bool, 0, 1), :is_multicast => (:Bool, 0, 1), :is_site_local => (:Bool, 0, 1), :is_mc_org_local => (:Bool, 0, 1), :is_mc_link_local => (:Bool, 0, 1), :is_mc_node_local => (:Bool, 0, 1), :bytes => (:Nothing, 0, 11), :is_mc_site_local => (:Bool, 0, 1), :is_link_local => (:Bool, 0, 1), :family => (:SocketFamily, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GInetAddressLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:family => (:SocketFamily, 0, 11), :bytes => (:Nothing, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GInetAddressMask <: GObject end
    end
    begin
        mutable struct GInetAddressMaskLeaf <: GInetAddressMask
            handle::Ptr{GObject}
            function GInetAddressMaskLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetAddressMaskLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInetAddressMaskLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GInetAddressMaskLeaf, args))
            end
            w = GInetAddressMaskLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GInetAddressMask] = GInetAddressMaskLeaf
        function GInetAddressMask(args...; kwargs...)
            GInetAddressMaskLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GInetAddressMaskLeaf) = begin
                    [:handle, :address, :family, :length]
                end
            function Base.getproperty(o::GInetAddressMaskLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:address => (:GInetAddress, 0, 3), :family => (:SocketFamily, 0, 1), :length => (:UInt32, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GInetAddressMaskLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:address => (:GInetAddress, 0, 3), :length => (:UInt32, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSocketAddress <: GObject end
    end
    begin
        mutable struct GSocketAddressLeaf <: GSocketAddress
            handle::Ptr{GObject}
            function GSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketAddressLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketAddressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSocketAddressLeaf, args))
            end
            w = GSocketAddressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketAddress] = GSocketAddressLeaf
        function GSocketAddress(args...; kwargs...)
            GSocketAddressLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSocketAddressLeaf) = begin
                    [:handle, :family]
                end
            function Base.getproperty(o::GSocketAddressLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:family => (:SocketFamily, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSocketAddressLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GInetSocketAddress <: GSocketAddress end
    end
    begin
        mutable struct GInetSocketAddressLeaf <: GInetSocketAddress
            handle::Ptr{GObject}
            function GInetSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetSocketAddressLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInetSocketAddressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GInetSocketAddressLeaf, args))
            end
            w = GInetSocketAddressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GInetSocketAddress] = GInetSocketAddressLeaf
        function GInetSocketAddress(args...; kwargs...)
            GInetSocketAddressLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GInetSocketAddressLeaf) = begin
                    [:handle, :scope_id, :address, :family, :port, :flowinfo]
                end
            function Base.getproperty(o::GInetSocketAddressLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scope_id => (:UInt32, 0, 11), :address => (:GInetAddress, 0, 11), :family => (:SocketFamily, 0, 1), :port => (:UInt32, 0, 11), :flowinfo => (:UInt32, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GInetSocketAddressLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scope_id => (:UInt32, 0, 11), :address => (:GInetAddress, 0, 11), :port => (:UInt32, 0, 11), :flowinfo => (:UInt32, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GListStore <: GObject end
    end
    begin
        mutable struct GListStoreLeaf <: GListStore
            handle::Ptr{GObject}
            function GListStoreLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GListStoreLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GListStoreLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GListStoreLeaf, args))
            end
            w = GListStoreLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GListStore] = GListStoreLeaf
        function GListStore(args...; kwargs...)
            GListStoreLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GListStoreLeaf) = begin
                    [:handle, :item_type]
                end
            function Base.getproperty(o::GListStoreLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:item_type => (:UInt64, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GListStoreLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:item_type => (:UInt64, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GMemoryInputStream <: GInputStream end
    end
    begin
        mutable struct GMemoryInputStreamLeaf <: GMemoryInputStream
            handle::Ptr{GObject}
            function GMemoryInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMemoryInputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMemoryInputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GMemoryInputStreamLeaf, args))
            end
            w = GMemoryInputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMemoryInputStream] = GMemoryInputStreamLeaf
        function GMemoryInputStream(args...; kwargs...)
            GMemoryInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMemoryOutputStream <: GOutputStream end
    end
    begin
        mutable struct GMemoryOutputStreamLeaf <: GMemoryOutputStream
            handle::Ptr{GObject}
            function GMemoryOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMemoryOutputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMemoryOutputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GMemoryOutputStreamLeaf, args))
            end
            w = GMemoryOutputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMemoryOutputStream] = GMemoryOutputStreamLeaf
        function GMemoryOutputStream(args...; kwargs...)
            GMemoryOutputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GMemoryOutputStreamLeaf) = begin
                    [:handle, :data_size, :size, :data]
                end
            function Base.getproperty(o::GMemoryOutputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:data_size => (:UInt64, 0, 1), :size => (:UInt64, 0, 11), :data => (:Nothing, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GMemoryOutputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:size => (:UInt64, 0, 11), :data => (:Nothing, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GMenu <: GMenuModel end
    end
    begin
        mutable struct GMenuLeaf <: GMenu
            handle::Ptr{GObject}
            function GMenuLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GMenuLeaf, args))
            end
            w = GMenuLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenu] = GMenuLeaf
        function GMenu(args...; kwargs...)
            GMenuLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuAttributeIter <: GObject end
    end
    begin
        mutable struct GMenuAttributeIterLeaf <: GMenuAttributeIter
            handle::Ptr{GObject}
            function GMenuAttributeIterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuAttributeIterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuAttributeIterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GMenuAttributeIterLeaf, args))
            end
            w = GMenuAttributeIterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenuAttributeIter] = GMenuAttributeIterLeaf
        function GMenuAttributeIter(args...; kwargs...)
            GMenuAttributeIterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuItem <: GObject end
    end
    begin
        mutable struct GMenuItemLeaf <: GMenuItem
            handle::Ptr{GObject}
            function GMenuItemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuItemLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuItemLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GMenuItemLeaf, args))
            end
            w = GMenuItemLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenuItem] = GMenuItemLeaf
        function GMenuItem(args...; kwargs...)
            GMenuItemLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuLinkIter <: GObject end
    end
    begin
        mutable struct GMenuLinkIterLeaf <: GMenuLinkIter
            handle::Ptr{GObject}
            function GMenuLinkIterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuLinkIterLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuLinkIterLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GMenuLinkIterLeaf, args))
            end
            w = GMenuLinkIterLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMenuLinkIter] = GMenuLinkIterLeaf
        function GMenuLinkIter(args...; kwargs...)
            GMenuLinkIterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMountOperation <: GObject end
    end
    begin
        mutable struct GMountOperationLeaf <: GMountOperation
            handle::Ptr{GObject}
            function GMountOperationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMountOperationLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMountOperationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GMountOperationLeaf, args))
            end
            w = GMountOperationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GMountOperation] = GMountOperationLeaf
        function GMountOperation(args...; kwargs...)
            GMountOperationLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GMountOperationLeaf) = begin
                    [:handle, :anonymous, :choice, :password_save, :pim, :is_tcrypt_system_volume, :password, :domain, :is_tcrypt_hidden_volume, :username]
                end
            function Base.getproperty(o::GMountOperationLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:anonymous => (:Bool, 0, 3), :choice => (:Int32, 0, 3), :password_save => (:PasswordSave, 0, 3), :pim => (:UInt32, 0, 3), :is_tcrypt_system_volume => (:Bool, 0, 3), :password => (:String, 0, 3), :domain => (:String, 0, 3), :is_tcrypt_hidden_volume => (:Bool, 0, 3), :username => (:String, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GMountOperationLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:anonymous => (:Bool, 0, 3), :choice => (:Int32, 0, 3), :password_save => (:PasswordSave, 0, 3), :pim => (:UInt32, 0, 3), :is_tcrypt_system_volume => (:Bool, 0, 3), :password => (:String, 0, 3), :domain => (:String, 0, 3), :is_tcrypt_hidden_volume => (:Bool, 0, 3), :username => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GNativeSocketAddress <: GSocketAddress end
    end
    begin
        mutable struct GNativeSocketAddressLeaf <: GNativeSocketAddress
            handle::Ptr{GObject}
            function GNativeSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNativeSocketAddressLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNativeSocketAddressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GNativeSocketAddressLeaf, args))
            end
            w = GNativeSocketAddressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNativeSocketAddress] = GNativeSocketAddressLeaf
        function GNativeSocketAddress(args...; kwargs...)
            GNativeSocketAddressLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GNativeSocketAddressLeaf) = begin
                    [:handle, :family]
                end
            function Base.getproperty(o::GNativeSocketAddressLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:family => (:SocketFamily, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GNativeSocketAddressLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GVolumeMonitor <: GObject end
    end
    begin
        mutable struct GVolumeMonitorLeaf <: GVolumeMonitor
            handle::Ptr{GObject}
            function GVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GVolumeMonitorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GVolumeMonitorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GVolumeMonitorLeaf, args))
            end
            w = GVolumeMonitorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GVolumeMonitor] = GVolumeMonitorLeaf
        function GVolumeMonitor(args...; kwargs...)
            GVolumeMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNativeVolumeMonitor <: GVolumeMonitor end
    end
    begin
        mutable struct GNativeVolumeMonitorLeaf <: GNativeVolumeMonitor
            handle::Ptr{GObject}
            function GNativeVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNativeVolumeMonitorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNativeVolumeMonitorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GNativeVolumeMonitorLeaf, args))
            end
            w = GNativeVolumeMonitorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNativeVolumeMonitor] = GNativeVolumeMonitorLeaf
        function GNativeVolumeMonitor(args...; kwargs...)
            GNativeVolumeMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNetworkAddress <: GObject end
    end
    begin
        mutable struct GNetworkAddressLeaf <: GNetworkAddress
            handle::Ptr{GObject}
            function GNetworkAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNetworkAddressLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNetworkAddressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GNetworkAddressLeaf, args))
            end
            w = GNetworkAddressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNetworkAddress] = GNetworkAddressLeaf
        function GNetworkAddress(args...; kwargs...)
            GNetworkAddressLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GNetworkAddressLeaf) = begin
                    [:handle, :scheme, :hostname, :port]
                end
            function Base.getproperty(o::GNetworkAddressLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scheme => (:String, 0, 11), :hostname => (:String, 0, 11), :port => (:UInt32, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GNetworkAddressLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scheme => (:String, 0, 11), :hostname => (:String, 0, 11), :port => (:UInt32, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GNetworkService <: GObject end
    end
    begin
        mutable struct GNetworkServiceLeaf <: GNetworkService
            handle::Ptr{GObject}
            function GNetworkServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNetworkServiceLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNetworkServiceLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GNetworkServiceLeaf, args))
            end
            w = GNetworkServiceLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNetworkService] = GNetworkServiceLeaf
        function GNetworkService(args...; kwargs...)
            GNetworkServiceLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GNetworkServiceLeaf) = begin
                    [:handle, :scheme, :service, :protocol, :domain]
                end
            function Base.getproperty(o::GNetworkServiceLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scheme => (:String, 0, 3), :service => (:String, 0, 11), :protocol => (:String, 0, 11), :domain => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GNetworkServiceLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scheme => (:String, 0, 3), :service => (:String, 0, 11), :protocol => (:String, 0, 11), :domain => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GNotification <: GObject end
    end
    begin
        mutable struct GNotificationLeaf <: GNotification
            handle::Ptr{GObject}
            function GNotificationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNotificationLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNotificationLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GNotificationLeaf, args))
            end
            w = GNotificationLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GNotification] = GNotificationLeaf
        function GNotification(args...; kwargs...)
            GNotificationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GPermission <: GObject end
    end
    begin
        mutable struct GPermissionLeaf <: GPermission
            handle::Ptr{GObject}
            function GPermissionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GPermissionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GPermissionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GPermissionLeaf, args))
            end
            w = GPermissionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GPermission] = GPermissionLeaf
        function GPermission(args...; kwargs...)
            GPermissionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GPermissionLeaf) = begin
                    [:handle, :can_release, :can_acquire, :allowed]
                end
            function Base.getproperty(o::GPermissionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:can_release => (:Bool, 0, 1), :can_acquire => (:Bool, 0, 1), :allowed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GPermissionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GPropertyAction <: GObject end
    end
    begin
        mutable struct GPropertyActionLeaf <: GPropertyAction
            handle::Ptr{GObject}
            function GPropertyActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GPropertyActionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GPropertyActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GPropertyActionLeaf, args))
            end
            w = GPropertyActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GPropertyAction] = GPropertyActionLeaf
        function GPropertyAction(args...; kwargs...)
            GPropertyActionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GPropertyActionLeaf) = begin
                    [:handle, :parameter_type, :enabled, :name, :state, :property_name, :invert_boolean, :state_type, :object]
                end
            function Base.getproperty(o::GPropertyActionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:parameter_type => (:GVariantType, 0, 1), :enabled => (:Bool, 0, 1), :name => (:String, 0, 11), :state => (:GVariant, 0, 1), :invert_boolean => (:Bool, 0, 11), :state_type => (:GVariantType, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GPropertyActionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:name => (:String, 0, 11), :property_name => (:String, 0, 10), :invert_boolean => (:Bool, 0, 11), :object => (:GObject, 0, 10))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GProxyAddress <: GInetSocketAddress end
    end
    begin
        mutable struct GProxyAddressLeaf <: GProxyAddress
            handle::Ptr{GObject}
            function GProxyAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GProxyAddressLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GProxyAddressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GProxyAddressLeaf, args))
            end
            w = GProxyAddressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GProxyAddress] = GProxyAddressLeaf
        function GProxyAddress(args...; kwargs...)
            GProxyAddressLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GProxyAddressLeaf) = begin
                    [:handle, :scope_id, :destination_port, :flowinfo, :protocol, :destination_protocol, :username, :address, :family, :port, :password, :destination_hostname, :uri]
                end
            function Base.getproperty(o::GProxyAddressLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scope_id => (:UInt32, 0, 11), :destination_port => (:UInt32, 0, 11), :flowinfo => (:UInt32, 0, 11), :protocol => (:String, 0, 11), :destination_protocol => (:String, 0, 11), :username => (:String, 0, 11), :address => (:GInetAddress, 0, 11), :family => (:SocketFamily, 0, 1), :port => (:UInt32, 0, 11), :password => (:String, 0, 11), :destination_hostname => (:String, 0, 11), :uri => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GProxyAddressLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:scope_id => (:UInt32, 0, 11), :destination_port => (:UInt32, 0, 11), :flowinfo => (:UInt32, 0, 11), :protocol => (:String, 0, 11), :destination_protocol => (:String, 0, 11), :username => (:String, 0, 11), :address => (:GInetAddress, 0, 11), :port => (:UInt32, 0, 11), :password => (:String, 0, 11), :destination_hostname => (:String, 0, 11), :uri => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSocketAddressEnumerator <: GObject end
    end
    begin
        mutable struct GSocketAddressEnumeratorLeaf <: GSocketAddressEnumerator
            handle::Ptr{GObject}
            function GSocketAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketAddressEnumeratorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketAddressEnumeratorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSocketAddressEnumeratorLeaf, args))
            end
            w = GSocketAddressEnumeratorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketAddressEnumerator] = GSocketAddressEnumeratorLeaf
        function GSocketAddressEnumerator(args...; kwargs...)
            GSocketAddressEnumeratorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GProxyAddressEnumerator <: GSocketAddressEnumerator end
    end
    begin
        mutable struct GProxyAddressEnumeratorLeaf <: GProxyAddressEnumerator
            handle::Ptr{GObject}
            function GProxyAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GProxyAddressEnumeratorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GProxyAddressEnumeratorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GProxyAddressEnumeratorLeaf, args))
            end
            w = GProxyAddressEnumeratorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GProxyAddressEnumerator] = GProxyAddressEnumeratorLeaf
        function GProxyAddressEnumerator(args...; kwargs...)
            GProxyAddressEnumeratorLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GProxyAddressEnumeratorLeaf) = begin
                    [:handle, :default_port, :proxy_resolver, :connectable, :uri]
                end
            function Base.getproperty(o::GProxyAddressEnumeratorLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:default_port => (:UInt32, 0, 11), :proxy_resolver => (:GProxyResolver, 0, 7), :connectable => (:GSocketConnectable, 0, 11), :uri => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GProxyAddressEnumeratorLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:default_port => (:UInt32, 0, 11), :proxy_resolver => (:GProxyResolver, 0, 7), :connectable => (:GSocketConnectable, 0, 11), :uri => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GResolver <: GObject end
    end
    begin
        mutable struct GResolverLeaf <: GResolver
            handle::Ptr{GObject}
            function GResolverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GResolverLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GResolverLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GResolverLeaf, args))
            end
            w = GResolverLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GResolver] = GResolverLeaf
        function GResolver(args...; kwargs...)
            GResolverLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSettings <: GObject end
    end
    begin
        mutable struct GSettingsLeaf <: GSettings
            handle::Ptr{GObject}
            function GSettingsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSettingsLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSettingsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSettingsLeaf, args))
            end
            w = GSettingsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSettings] = GSettingsLeaf
        function GSettings(args...; kwargs...)
            GSettingsLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSettingsLeaf) = begin
                    [:handle, :settings_schema, :path, :schema_id, :has_unapplied, :backend, :delay_apply, :schema]
                end
            function Base.getproperty(o::GSettingsLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:settings_schema => (:GSettingsSchema, 0, 11), :path => (:String, 0, 11), :schema_id => (:String, 0, 11), :has_unapplied => (:Bool, 0, 1), :backend => (:GSettingsBackend, 0, 11), :delay_apply => (:Bool, 0, 1), :schema => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSettingsLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:settings_schema => (:GSettingsSchema, 0, 11), :path => (:String, 0, 11), :schema_id => (:String, 0, 11), :backend => (:GSettingsBackend, 0, 11), :schema => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSettingsBackend <: GObject end
    end
    begin
        mutable struct GSettingsBackendLeaf <: GSettingsBackend
            handle::Ptr{GObject}
            function GSettingsBackendLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSettingsBackendLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSettingsBackendLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSettingsBackendLeaf, args))
            end
            w = GSettingsBackendLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSettingsBackend] = GSettingsBackendLeaf
        function GSettingsBackend(args...; kwargs...)
            GSettingsBackendLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleAction <: GObject end
    end
    begin
        mutable struct GSimpleActionLeaf <: GSimpleAction
            handle::Ptr{GObject}
            function GSimpleActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleActionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleActionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSimpleActionLeaf, args))
            end
            w = GSimpleActionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleAction] = GSimpleActionLeaf
        function GSimpleAction(args...; kwargs...)
            GSimpleActionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSimpleActionLeaf) = begin
                    [:handle, :parameter_type, :enabled, :name, :state, :state_type]
                end
            function Base.getproperty(o::GSimpleActionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:parameter_type => (:GVariantType, 0, 11), :enabled => (:Bool, 0, 3), :name => (:String, 0, 11), :state => (:GVariant, 0, 7), :state_type => (:GVariantType, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSimpleActionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:parameter_type => (:GVariantType, 0, 11), :enabled => (:Bool, 0, 3), :name => (:String, 0, 11), :state => (:GVariant, 0, 7))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSimpleActionGroup <: GObject end
    end
    begin
        mutable struct GSimpleActionGroupLeaf <: GSimpleActionGroup
            handle::Ptr{GObject}
            function GSimpleActionGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleActionGroupLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleActionGroupLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSimpleActionGroupLeaf, args))
            end
            w = GSimpleActionGroupLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleActionGroup] = GSimpleActionGroupLeaf
        function GSimpleActionGroup(args...; kwargs...)
            GSimpleActionGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleAsyncResult <: GObject end
    end
    begin
        mutable struct GSimpleAsyncResultLeaf <: GSimpleAsyncResult
            handle::Ptr{GObject}
            function GSimpleAsyncResultLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleAsyncResultLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleAsyncResultLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSimpleAsyncResultLeaf, args))
            end
            w = GSimpleAsyncResultLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleAsyncResult] = GSimpleAsyncResultLeaf
        function GSimpleAsyncResult(args...; kwargs...)
            GSimpleAsyncResultLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleIOStream <: GIOStream end
    end
    begin
        mutable struct GSimpleIOStreamLeaf <: GSimpleIOStream
            handle::Ptr{GObject}
            function GSimpleIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleIOStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleIOStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSimpleIOStreamLeaf, args))
            end
            w = GSimpleIOStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleIOStream] = GSimpleIOStreamLeaf
        function GSimpleIOStream(args...; kwargs...)
            GSimpleIOStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSimpleIOStreamLeaf) = begin
                    [:handle, :output_stream, :input_stream, :closed]
                end
            function Base.getproperty(o::GSimpleIOStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:output_stream => (:GOutputStream, 0, 11), :input_stream => (:GInputStream, 0, 11), :closed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSimpleIOStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:output_stream => (:GOutputStream, 0, 11), :input_stream => (:GInputStream, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSimplePermission <: GPermission end
    end
    begin
        mutable struct GSimplePermissionLeaf <: GSimplePermission
            handle::Ptr{GObject}
            function GSimplePermissionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimplePermissionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimplePermissionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSimplePermissionLeaf, args))
            end
            w = GSimplePermissionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimplePermission] = GSimplePermissionLeaf
        function GSimplePermission(args...; kwargs...)
            GSimplePermissionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSimplePermissionLeaf) = begin
                    [:handle, :can_release, :can_acquire, :allowed]
                end
            function Base.getproperty(o::GSimplePermissionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:can_release => (:Bool, 0, 1), :can_acquire => (:Bool, 0, 1), :allowed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSimplePermissionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSimpleProxyResolver <: GObject end
    end
    begin
        mutable struct GSimpleProxyResolverLeaf <: GSimpleProxyResolver
            handle::Ptr{GObject}
            function GSimpleProxyResolverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleProxyResolverLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleProxyResolverLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSimpleProxyResolverLeaf, args))
            end
            w = GSimpleProxyResolverLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSimpleProxyResolver] = GSimpleProxyResolverLeaf
        function GSimpleProxyResolver(args...; kwargs...)
            GSimpleProxyResolverLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSimpleProxyResolverLeaf) = begin
                    [:handle, :default_proxy, :ignore_hosts]
                end
            function Base.getproperty(o::GSimpleProxyResolverLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:default_proxy => (:String, 0, 3), :ignore_hosts => (:(Array{GI.TypeDesc{Type{String}}(String, :(Union{AbstractString, Symbol}), :String, :Cstring)}), 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSimpleProxyResolverLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:default_proxy => (:String, 0, 3), :ignore_hosts => (:(Array{GI.TypeDesc{Type{String}}(String, :(Union{AbstractString, Symbol}), :String, :Cstring)}), 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSocket <: GObject end
    end
    begin
        mutable struct GSocketLeaf <: GSocket
            handle::Ptr{GObject}
            function GSocketLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSocketLeaf, args))
            end
            w = GSocketLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocket] = GSocketLeaf
        function GSocket(args...; kwargs...)
            GSocketLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSocketLeaf) = begin
                    [:handle, :keepalive, :remote_address, :fd, :broadcast, :timeout, :protocol, :ttl, :multicast_ttl, :listen_backlog, :blocking, :family, :type, :local_address, :multicast_loopback]
                end
            function Base.getproperty(o::GSocketLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:keepalive => (:Bool, 0, 3), :remote_address => (:GSocketAddress, 0, 1), :fd => (:Int32, 0, 11), :broadcast => (:Bool, 0, 3), :timeout => (:UInt32, 0, 3), :protocol => (:SocketProtocol, 0, 11), :ttl => (:UInt32, 0, 3), :multicast_ttl => (:UInt32, 0, 3), :listen_backlog => (:Int32, 0, 3), :blocking => (:Bool, 0, 3), :family => (:SocketFamily, 0, 11), :type => (:SocketType, 0, 11), :local_address => (:GSocketAddress, 0, 1), :multicast_loopback => (:Bool, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSocketLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:keepalive => (:Bool, 0, 3), :fd => (:Int32, 0, 11), :broadcast => (:Bool, 0, 3), :timeout => (:UInt32, 0, 3), :protocol => (:SocketProtocol, 0, 11), :ttl => (:UInt32, 0, 3), :multicast_ttl => (:UInt32, 0, 3), :listen_backlog => (:Int32, 0, 3), :blocking => (:Bool, 0, 3), :family => (:SocketFamily, 0, 11), :type => (:SocketType, 0, 11), :multicast_loopback => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSocketClient <: GObject end
    end
    begin
        mutable struct GSocketClientLeaf <: GSocketClient
            handle::Ptr{GObject}
            function GSocketClientLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketClientLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketClientLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSocketClientLeaf, args))
            end
            w = GSocketClientLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketClient] = GSocketClientLeaf
        function GSocketClient(args...; kwargs...)
            GSocketClientLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSocketClientLeaf) = begin
                    [:handle, :tls_validation_flags, :tls, :family, :proxy_resolver, :type, :timeout, :enable_proxy, :protocol, :local_address]
                end
            function Base.getproperty(o::GSocketClientLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:tls_validation_flags => (:Int32, 0, 7), :tls => (:Bool, 0, 7), :family => (:SocketFamily, 0, 7), :proxy_resolver => (:GProxyResolver, 0, 7), :type => (:SocketType, 0, 7), :timeout => (:UInt32, 0, 7), :enable_proxy => (:Bool, 0, 7), :protocol => (:SocketProtocol, 0, 7), :local_address => (:GSocketAddress, 0, 7))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSocketClientLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:tls_validation_flags => (:Int32, 0, 7), :tls => (:Bool, 0, 7), :family => (:SocketFamily, 0, 7), :proxy_resolver => (:GProxyResolver, 0, 7), :type => (:SocketType, 0, 7), :timeout => (:UInt32, 0, 7), :enable_proxy => (:Bool, 0, 7), :protocol => (:SocketProtocol, 0, 7), :local_address => (:GSocketAddress, 0, 7))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSocketConnection <: GIOStream end
    end
    begin
        mutable struct GSocketConnectionLeaf <: GSocketConnection
            handle::Ptr{GObject}
            function GSocketConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketConnectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketConnectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSocketConnectionLeaf, args))
            end
            w = GSocketConnectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketConnection] = GSocketConnectionLeaf
        function GSocketConnection(args...; kwargs...)
            GSocketConnectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSocketConnectionLeaf) = begin
                    [:handle, :output_stream, :socket, :input_stream, :closed]
                end
            function Base.getproperty(o::GSocketConnectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:output_stream => (:GOutputStream, 0, 1), :socket => (:GSocket, 0, 11), :input_stream => (:GInputStream, 0, 1), :closed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSocketConnectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:socket => (:GSocket, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSocketControlMessage <: GObject end
    end
    begin
        mutable struct GSocketControlMessageLeaf <: GSocketControlMessage
            handle::Ptr{GObject}
            function GSocketControlMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketControlMessageLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketControlMessageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSocketControlMessageLeaf, args))
            end
            w = GSocketControlMessageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketControlMessage] = GSocketControlMessageLeaf
        function GSocketControlMessage(args...; kwargs...)
            GSocketControlMessageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketListener <: GObject end
    end
    begin
        mutable struct GSocketListenerLeaf <: GSocketListener
            handle::Ptr{GObject}
            function GSocketListenerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketListenerLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketListenerLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSocketListenerLeaf, args))
            end
            w = GSocketListenerLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketListener] = GSocketListenerLeaf
        function GSocketListener(args...; kwargs...)
            GSocketListenerLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSocketListenerLeaf) = begin
                    [:handle, :listen_backlog]
                end
            function Base.getproperty(o::GSocketListenerLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:listen_backlog => (:Int32, 0, 7))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSocketListenerLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:listen_backlog => (:Int32, 0, 7))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSocketService <: GSocketListener end
    end
    begin
        mutable struct GSocketServiceLeaf <: GSocketService
            handle::Ptr{GObject}
            function GSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketServiceLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketServiceLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSocketServiceLeaf, args))
            end
            w = GSocketServiceLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSocketService] = GSocketServiceLeaf
        function GSocketService(args...; kwargs...)
            GSocketServiceLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSocketServiceLeaf) = begin
                    [:handle, :listen_backlog, :active]
                end
            function Base.getproperty(o::GSocketServiceLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:listen_backlog => (:Int32, 0, 7), :active => (:Bool, 0, 7))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSocketServiceLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:listen_backlog => (:Int32, 0, 7), :active => (:Bool, 0, 7))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSubprocess <: GObject end
    end
    begin
        mutable struct GSubprocessLeaf <: GSubprocess
            handle::Ptr{GObject}
            function GSubprocessLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSubprocessLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSubprocessLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSubprocessLeaf, args))
            end
            w = GSubprocessLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSubprocess] = GSubprocessLeaf
        function GSubprocess(args...; kwargs...)
            GSubprocessLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSubprocessLeaf) = begin
                    [:handle, :flags, :argv]
                end
            function Base.getproperty(o::GSubprocessLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSubprocessLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:flags => (:Int32, 0, 10), :argv => (:(Array{GI.TypeDesc{Type{String}}(String, :(Union{AbstractString, Symbol}), :String, :Cstring)}), 0, 10))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GSubprocessLauncher <: GObject end
    end
    begin
        mutable struct GSubprocessLauncherLeaf <: GSubprocessLauncher
            handle::Ptr{GObject}
            function GSubprocessLauncherLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSubprocessLauncherLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSubprocessLauncherLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GSubprocessLauncherLeaf, args))
            end
            w = GSubprocessLauncherLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GSubprocessLauncher] = GSubprocessLauncherLeaf
        function GSubprocessLauncher(args...; kwargs...)
            GSubprocessLauncherLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GSubprocessLauncherLeaf) = begin
                    [:handle, :flags]
                end
            function Base.getproperty(o::GSubprocessLauncherLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GSubprocessLauncherLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:flags => (:Int32, 0, 10))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GTask <: GObject end
    end
    begin
        mutable struct GTaskLeaf <: GTask
            handle::Ptr{GObject}
            function GTaskLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTaskLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTaskLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GTaskLeaf, args))
            end
            w = GTaskLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTask] = GTaskLeaf
        function GTask(args...; kwargs...)
            GTaskLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GTaskLeaf) = begin
                    [:handle, :completed]
                end
            function Base.getproperty(o::GTaskLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:completed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GTaskLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}()
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GTcpConnection <: GSocketConnection end
    end
    begin
        mutable struct GTcpConnectionLeaf <: GTcpConnection
            handle::Ptr{GObject}
            function GTcpConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTcpConnectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTcpConnectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GTcpConnectionLeaf, args))
            end
            w = GTcpConnectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTcpConnection] = GTcpConnectionLeaf
        function GTcpConnection(args...; kwargs...)
            GTcpConnectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GTcpConnectionLeaf) = begin
                    [:handle, :output_stream, :socket, :input_stream, :graceful_disconnect, :closed]
                end
            function Base.getproperty(o::GTcpConnectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:output_stream => (:GOutputStream, 0, 1), :socket => (:GSocket, 0, 11), :input_stream => (:GInputStream, 0, 1), :graceful_disconnect => (:Bool, 0, 3), :closed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GTcpConnectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:socket => (:GSocket, 0, 11), :graceful_disconnect => (:Bool, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GTcpWrapperConnection <: GTcpConnection end
    end
    begin
        mutable struct GTcpWrapperConnectionLeaf <: GTcpWrapperConnection
            handle::Ptr{GObject}
            function GTcpWrapperConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTcpWrapperConnectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTcpWrapperConnectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GTcpWrapperConnectionLeaf, args))
            end
            w = GTcpWrapperConnectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTcpWrapperConnection] = GTcpWrapperConnectionLeaf
        function GTcpWrapperConnection(args...; kwargs...)
            GTcpWrapperConnectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GTcpWrapperConnectionLeaf) = begin
                    [:handle, :output_stream, :socket, :input_stream, :graceful_disconnect, :base_io_stream, :closed]
                end
            function Base.getproperty(o::GTcpWrapperConnectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:output_stream => (:GOutputStream, 0, 1), :socket => (:GSocket, 0, 11), :input_stream => (:GInputStream, 0, 1), :graceful_disconnect => (:Bool, 0, 3), :base_io_stream => (:GIOStream, 0, 11), :closed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GTcpWrapperConnectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:socket => (:GSocket, 0, 11), :graceful_disconnect => (:Bool, 0, 3), :base_io_stream => (:GIOStream, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GTestDBus <: GObject end
    end
    begin
        mutable struct GTestDBusLeaf <: GTestDBus
            handle::Ptr{GObject}
            function GTestDBusLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTestDBusLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTestDBusLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GTestDBusLeaf, args))
            end
            w = GTestDBusLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTestDBus] = GTestDBusLeaf
        function GTestDBus(args...; kwargs...)
            GTestDBusLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GTestDBusLeaf) = begin
                    [:handle, :flags]
                end
            function Base.getproperty(o::GTestDBusLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:flags => (:Int32, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GTestDBusLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:flags => (:Int32, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GThemedIcon <: GObject end
    end
    begin
        mutable struct GThemedIconLeaf <: GThemedIcon
            handle::Ptr{GObject}
            function GThemedIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GThemedIconLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GThemedIconLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GThemedIconLeaf, args))
            end
            w = GThemedIconLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GThemedIcon] = GThemedIconLeaf
        function GThemedIcon(args...; kwargs...)
            GThemedIconLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GThemedIconLeaf) = begin
                    [:handle, :use_default_fallbacks, :name, :names]
                end
            function Base.getproperty(o::GThemedIconLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_default_fallbacks => (:Bool, 0, 11), :names => (:(Array{GI.TypeDesc{Type{String}}(String, :(Union{AbstractString, Symbol}), :String, :Cstring)}), 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GThemedIconLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_default_fallbacks => (:Bool, 0, 11), :name => (:String, 0, 10), :names => (:(Array{GI.TypeDesc{Type{String}}(String, :(Union{AbstractString, Symbol}), :String, :Cstring)}), 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GThreadedSocketService <: GSocketService end
    end
    begin
        mutable struct GThreadedSocketServiceLeaf <: GThreadedSocketService
            handle::Ptr{GObject}
            function GThreadedSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GThreadedSocketServiceLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GThreadedSocketServiceLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GThreadedSocketServiceLeaf, args))
            end
            w = GThreadedSocketServiceLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GThreadedSocketService] = GThreadedSocketServiceLeaf
        function GThreadedSocketService(args...; kwargs...)
            GThreadedSocketServiceLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GThreadedSocketServiceLeaf) = begin
                    [:handle, :listen_backlog, :active, :max_threads]
                end
            function Base.getproperty(o::GThreadedSocketServiceLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:listen_backlog => (:Int32, 0, 7), :active => (:Bool, 0, 7), :max_threads => (:Int32, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GThreadedSocketServiceLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:listen_backlog => (:Int32, 0, 7), :active => (:Bool, 0, 7), :max_threads => (:Int32, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GTlsCertificate <: GObject end
    end
    begin
        mutable struct GTlsCertificateLeaf <: GTlsCertificate
            handle::Ptr{GObject}
            function GTlsCertificateLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsCertificateLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsCertificateLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GTlsCertificateLeaf, args))
            end
            w = GTlsCertificateLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsCertificate] = GTlsCertificateLeaf
        function GTlsCertificate(args...; kwargs...)
            GTlsCertificateLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GTlsCertificateLeaf) = begin
                    [:handle, :ip_addresses, :dns_names, :not_valid_before, :private_key_pem, :pkcs11_uri, :certificate_pem, :not_valid_after, :private_key, :subject_name, :issuer_name, :certificate, :private_key_pkcs11_uri, :issuer]
                end
            function Base.getproperty(o::GTlsCertificateLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:ip_addresses => (:GPtrArray, 1, 1), :dns_names => (:GPtrArray, 1, 1), :not_valid_before => (:GDateTime, 0, 1), :private_key_pem => (:String, 0, 11), :pkcs11_uri => (:String, 0, 11), :certificate_pem => (:String, 0, 11), :not_valid_after => (:GDateTime, 0, 1), :private_key => (:GByteArray, 0, 11), :subject_name => (:String, 0, 1), :issuer_name => (:String, 0, 1), :certificate => (:GByteArray, 0, 11), :private_key_pkcs11_uri => (:String, 0, 11), :issuer => (:GTlsCertificate, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GTlsCertificateLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:certificate_pem => (:String, 0, 11), :private_key => (:GByteArray, 0, 11), :certificate => (:GByteArray, 0, 11), :private_key_pem => (:String, 0, 11), :pkcs11_uri => (:String, 0, 11), :private_key_pkcs11_uri => (:String, 0, 11), :issuer => (:GTlsCertificate, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GTlsConnection <: GIOStream end
    end
    begin
        mutable struct GTlsConnectionLeaf <: GTlsConnection
            handle::Ptr{GObject}
            function GTlsConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsConnectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsConnectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GTlsConnectionLeaf, args))
            end
            w = GTlsConnectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsConnection] = GTlsConnectionLeaf
        function GTlsConnection(args...; kwargs...)
            GTlsConnectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GTlsConnectionLeaf) = begin
                    [:handle, :use_system_certdb, :input_stream, :peer_certificate_errors, :ciphersuite_name, :database, :output_stream, :require_close_notify, :protocol_version, :base_io_stream, :peer_certificate, :interaction, :rehandshake_mode, :closed, :certificate, :negotiated_protocol, :advertised_protocols]
                end
            function Base.getproperty(o::GTlsConnectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_system_certdb => (:Bool, 0, 7), :input_stream => (:GInputStream, 0, 1), :peer_certificate_errors => (:Int32, 0, 1), :ciphersuite_name => (:String, 0, 1), :database => (:GTlsDatabase, 0, 3), :output_stream => (:GOutputStream, 0, 1), :require_close_notify => (:Bool, 0, 7), :protocol_version => (:TlsProtocolVersion, 0, 1), :base_io_stream => (:GIOStream, 0, 11), :peer_certificate => (:GTlsCertificate, 0, 1), :interaction => (:GTlsInteraction, 0, 3), :rehandshake_mode => (:TlsRehandshakeMode, 0, 7), :closed => (:Bool, 0, 1), :certificate => (:GTlsCertificate, 0, 3), :negotiated_protocol => (:String, 0, 1), :advertised_protocols => (:(Array{GI.TypeDesc{Type{String}}(String, :(Union{AbstractString, Symbol}), :String, :Cstring)}), 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GTlsConnectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:use_system_certdb => (:Bool, 0, 7), :require_close_notify => (:Bool, 0, 7), :certificate => (:GTlsCertificate, 0, 3), :interaction => (:GTlsInteraction, 0, 3), :base_io_stream => (:GIOStream, 0, 11), :database => (:GTlsDatabase, 0, 3), :rehandshake_mode => (:TlsRehandshakeMode, 0, 7), :advertised_protocols => (:(Array{GI.TypeDesc{Type{String}}(String, :(Union{AbstractString, Symbol}), :String, :Cstring)}), 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GTlsDatabase <: GObject end
    end
    begin
        mutable struct GTlsDatabaseLeaf <: GTlsDatabase
            handle::Ptr{GObject}
            function GTlsDatabaseLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsDatabaseLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsDatabaseLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GTlsDatabaseLeaf, args))
            end
            w = GTlsDatabaseLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsDatabase] = GTlsDatabaseLeaf
        function GTlsDatabase(args...; kwargs...)
            GTlsDatabaseLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsInteraction <: GObject end
    end
    begin
        mutable struct GTlsInteractionLeaf <: GTlsInteraction
            handle::Ptr{GObject}
            function GTlsInteractionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsInteractionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsInteractionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GTlsInteractionLeaf, args))
            end
            w = GTlsInteractionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsInteraction] = GTlsInteractionLeaf
        function GTlsInteraction(args...; kwargs...)
            GTlsInteractionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsPassword <: GObject end
    end
    begin
        mutable struct GTlsPasswordLeaf <: GTlsPassword
            handle::Ptr{GObject}
            function GTlsPasswordLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsPasswordLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsPasswordLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GTlsPasswordLeaf, args))
            end
            w = GTlsPasswordLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GTlsPassword] = GTlsPasswordLeaf
        function GTlsPassword(args...; kwargs...)
            GTlsPasswordLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GTlsPasswordLeaf) = begin
                    [:handle, :warning, :flags, :description]
                end
            function Base.getproperty(o::GTlsPasswordLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:warning => (:String, 0, 3), :flags => (:Int32, 0, 3), :description => (:String, 0, 3))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GTlsPasswordLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:warning => (:String, 0, 3), :flags => (:Int32, 0, 3), :description => (:String, 0, 3))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GUnixConnection <: GSocketConnection end
    end
    begin
        mutable struct GUnixConnectionLeaf <: GUnixConnection
            handle::Ptr{GObject}
            function GUnixConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixConnectionLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixConnectionLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GUnixConnectionLeaf, args))
            end
            w = GUnixConnectionLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixConnection] = GUnixConnectionLeaf
        function GUnixConnection(args...; kwargs...)
            GUnixConnectionLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GUnixConnectionLeaf) = begin
                    [:handle, :output_stream, :socket, :input_stream, :closed]
                end
            function Base.getproperty(o::GUnixConnectionLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:output_stream => (:GOutputStream, 0, 1), :socket => (:GSocket, 0, 11), :input_stream => (:GInputStream, 0, 1), :closed => (:Bool, 0, 1))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GUnixConnectionLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:socket => (:GSocket, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GUnixCredentialsMessage <: GSocketControlMessage end
    end
    begin
        mutable struct GUnixCredentialsMessageLeaf <: GUnixCredentialsMessage
            handle::Ptr{GObject}
            function GUnixCredentialsMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixCredentialsMessageLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixCredentialsMessageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GUnixCredentialsMessageLeaf, args))
            end
            w = GUnixCredentialsMessageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixCredentialsMessage] = GUnixCredentialsMessageLeaf
        function GUnixCredentialsMessage(args...; kwargs...)
            GUnixCredentialsMessageLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GUnixCredentialsMessageLeaf) = begin
                    [:handle, :credentials]
                end
            function Base.getproperty(o::GUnixCredentialsMessageLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:credentials => (:GCredentials, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GUnixCredentialsMessageLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:credentials => (:GCredentials, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GUnixFDList <: GObject end
    end
    begin
        mutable struct GUnixFDListLeaf <: GUnixFDList
            handle::Ptr{GObject}
            function GUnixFDListLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixFDListLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixFDListLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GUnixFDListLeaf, args))
            end
            w = GUnixFDListLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixFDList] = GUnixFDListLeaf
        function GUnixFDList(args...; kwargs...)
            GUnixFDListLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GUnixFDMessage <: GSocketControlMessage end
    end
    begin
        mutable struct GUnixFDMessageLeaf <: GUnixFDMessage
            handle::Ptr{GObject}
            function GUnixFDMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixFDMessageLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixFDMessageLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GUnixFDMessageLeaf, args))
            end
            w = GUnixFDMessageLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixFDMessage] = GUnixFDMessageLeaf
        function GUnixFDMessage(args...; kwargs...)
            GUnixFDMessageLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GUnixFDMessageLeaf) = begin
                    [:handle, :fd_list]
                end
            function Base.getproperty(o::GUnixFDMessageLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:fd_list => (:GUnixFDList, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GUnixFDMessageLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:fd_list => (:GUnixFDList, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GUnixInputStream <: GInputStream end
    end
    begin
        mutable struct GUnixInputStreamLeaf <: GUnixInputStream
            handle::Ptr{GObject}
            function GUnixInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixInputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixInputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GUnixInputStreamLeaf, args))
            end
            w = GUnixInputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixInputStream] = GUnixInputStreamLeaf
        function GUnixInputStream(args...; kwargs...)
            GUnixInputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GUnixInputStreamLeaf) = begin
                    [:handle, :close_fd, :fd]
                end
            function Base.getproperty(o::GUnixInputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_fd => (:Bool, 0, 3), :fd => (:Int32, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GUnixInputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_fd => (:Bool, 0, 3), :fd => (:Int32, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GUnixMountMonitor <: GObject end
    end
    begin
        mutable struct GUnixMountMonitorLeaf <: GUnixMountMonitor
            handle::Ptr{GObject}
            function GUnixMountMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixMountMonitorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixMountMonitorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GUnixMountMonitorLeaf, args))
            end
            w = GUnixMountMonitorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixMountMonitor] = GUnixMountMonitorLeaf
        function GUnixMountMonitor(args...; kwargs...)
            GUnixMountMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GUnixOutputStream <: GOutputStream end
    end
    begin
        mutable struct GUnixOutputStreamLeaf <: GUnixOutputStream
            handle::Ptr{GObject}
            function GUnixOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixOutputStreamLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixOutputStreamLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GUnixOutputStreamLeaf, args))
            end
            w = GUnixOutputStreamLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixOutputStream] = GUnixOutputStreamLeaf
        function GUnixOutputStream(args...; kwargs...)
            GUnixOutputStreamLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GUnixOutputStreamLeaf) = begin
                    [:handle, :close_fd, :fd]
                end
            function Base.getproperty(o::GUnixOutputStreamLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_fd => (:Bool, 0, 3), :fd => (:Int32, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GUnixOutputStreamLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:close_fd => (:Bool, 0, 3), :fd => (:Int32, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GUnixSocketAddress <: GSocketAddress end
    end
    begin
        mutable struct GUnixSocketAddressLeaf <: GUnixSocketAddress
            handle::Ptr{GObject}
            function GUnixSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixSocketAddressLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixSocketAddressLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GUnixSocketAddressLeaf, args))
            end
            w = GUnixSocketAddressLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GUnixSocketAddress] = GUnixSocketAddressLeaf
        function GUnixSocketAddress(args...; kwargs...)
            GUnixSocketAddressLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GUnixSocketAddressLeaf) = begin
                    [:handle, :path_as_array, :family, :abstract, :address_type, :path]
                end
            function Base.getproperty(o::GUnixSocketAddressLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:path_as_array => (:GByteArray, 0, 11), :family => (:SocketFamily, 0, 1), :abstract => (:Bool, 0, 11), :address_type => (:UnixSocketAddressType, 0, 11), :path => (:String, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GUnixSocketAddressLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:path_as_array => (:GByteArray, 0, 11), :abstract => (:Bool, 0, 11), :address_type => (:UnixSocketAddressType, 0, 11), :path => (:String, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GVfs <: GObject end
    end
    begin
        mutable struct GVfsLeaf <: GVfs
            handle::Ptr{GObject}
            function GVfsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GVfsLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GVfsLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GVfsLeaf, args))
            end
            w = GVfsLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GVfs] = GVfsLeaf
        function GVfs(args...; kwargs...)
            GVfsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GZlibCompressor <: GObject end
    end
    begin
        mutable struct GZlibCompressorLeaf <: GZlibCompressor
            handle::Ptr{GObject}
            function GZlibCompressorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GZlibCompressorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GZlibCompressorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GZlibCompressorLeaf, args))
            end
            w = GZlibCompressorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GZlibCompressor] = GZlibCompressorLeaf
        function GZlibCompressor(args...; kwargs...)
            GZlibCompressorLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GZlibCompressorLeaf) = begin
                    [:handle, :level, :file_info, :format]
                end
            function Base.getproperty(o::GZlibCompressorLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:level => (:Int32, 0, 11), :file_info => (:GFileInfo, 0, 3), :format => (:ZlibCompressorFormat, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GZlibCompressorLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:level => (:Int32, 0, 11), :file_info => (:GFileInfo, 0, 3), :format => (:ZlibCompressorFormat, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        abstract type GZlibDecompressor <: GObject end
    end
    begin
        mutable struct GZlibDecompressorLeaf <: GZlibDecompressor
            handle::Ptr{GObject}
            function GZlibDecompressorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GZlibDecompressorLeaf with a NULL pointer")
                end
                is_floating = ccall(("g_object_is_floating", libgobject), Cint, (Ptr{GObject},), handle) != 0
                if !owns || is_floating
                    gc_ref_sink(handle)
                end
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GZlibDecompressorLeaf(args...; kwargs...)
            if isempty(kwargs)
                error(MethodError(GZlibDecompressorLeaf, args))
            end
            w = GZlibDecompressorLeaf(args...)
            for (kw, val) = kwargs
                set_gtk_property!(w, kw, val)
            end
            w
        end
        gtype_wrapper_cache[:GZlibDecompressor] = GZlibDecompressorLeaf
        function GZlibDecompressor(args...; kwargs...)
            GZlibDecompressorLeaf(args...; kwargs...)
        end
        begin
            Base.propertynames(o::GZlibDecompressorLeaf) = begin
                    [:handle, :file_info, :format]
                end
            function Base.getproperty(o::GZlibDecompressorLeaf, name::Symbol)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:file_info => (:GFileInfo, 0, 1), :format => (:ZlibCompressorFormat, 0, 11))
                if name in keys(d)
                    return get_gtk_property(o, name, eval((d[name])[1]))
                else
                    return getfield(o, name)
                end
            end
            function Base.setproperty!(o::GZlibDecompressorLeaf, name::Symbol, x)
                d = Dict{Symbol, Tuple{Any, Int32, Int32}}(:format => (:ZlibCompressorFormat, 0, 11))
                if name in keys(d)
                    set_gtk_property!(o, name, x)
                else
                    setfield!(o, name, x)
                end
            end
        end
    end
    begin
        struct GAction <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GAction(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GActionGroup <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GActionGroup(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GActionMap <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GActionMap(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GAppInfo <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GAppInfo(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GAsyncInitable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GAsyncInitable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GAsyncResult <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GAsyncResult(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GConverter <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GConverter(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDBusInterface <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDBusInterface(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDBusObject <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDBusObject(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDBusObjectManager <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDBusObjectManager(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDatagramBased <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDatagramBased(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDrive <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDrive(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDtlsClientConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDtlsClientConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDtlsConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDtlsConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GDtlsServerConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GDtlsServerConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GFile <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GFile(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GFileDescriptorBased <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GFileDescriptorBased(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GIcon <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GIcon(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GInitable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GInitable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GListModel <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GListModel(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GLoadableIcon <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GLoadableIcon(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GMemoryMonitor <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GMemoryMonitor(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GMount <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GMount(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GNetworkMonitor <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GNetworkMonitor(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GPollableInputStream <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GPollableInputStream(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GPollableOutputStream <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GPollableOutputStream(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct void <: GInterface
            handle::Ptr{GObject}
            gc::Any
            void(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GProxy <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GProxy(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GProxyResolver <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GProxyResolver(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GRemoteActionGroup <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GRemoteActionGroup(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GSeekable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GSeekable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GSocketConnectable <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GSocketConnectable(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GTlsBackend <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GTlsBackend(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GTlsClientConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GTlsClientConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GTlsFileDatabase <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GTlsFileDatabase(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GTlsServerConnection <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GTlsServerConnection(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    begin
        struct GVolume <: GInterface
            handle::Ptr{GObject}
            gc::Any
            GVolume(x::GObject) = begin
                    new(unsafe_convert(Ptr{GObject}, x), x)
                end
        end
    end
    export GDBusErrorEntry, GFileAttributeInfo, GFileAttributeInfoList, GFileAttributeMatcher, GInputVector, GOutputVector, GResource, GSettingsSchema, GSettingsSchemaKey, GSettingsSchemaSource, GSrvTarget, GUnixMountEntry, GUnixMountPoint, GAppInfoMonitor, GAppLaunchContext, GApplication, GApplicationCommandLine, GBufferedInputStream, GBufferedOutputStream, GBytesIcon, GCancellable, GCharsetConverter, GConverterInputStream, GConverterOutputStream, GCredentials, GDBusActionGroup, GDBusAuthObserver, GDBusConnection, GDBusInterfaceSkeleton, GDBusMenuModel, GDBusMessage, GDBusMethodInvocation, GDBusObjectManagerClient, GDBusObjectManagerServer, GDBusObjectProxy, GDBusObjectSkeleton, GDBusProxy, GDBusServer, GDataInputStream, GDataOutputStream, GDesktopAppInfo, GEmblem, GEmblemedIcon, GFileEnumerator, GFileIOStream, GFileIcon, GFileInfo, GFileInputStream, GFileMonitor, GFileOutputStream, GFilenameCompleter, GFilterInputStream, GFilterOutputStream, GIOModule, GIOStream, GInetAddress, GInetAddressMask, GInetSocketAddress, GInputStream, GListStore, GMemoryInputStream, GMemoryOutputStream, GMenu, GMenuAttributeIter, GMenuItem, GMenuLinkIter, GMenuModel, GMountOperation, GNativeSocketAddress, GNativeVolumeMonitor, GNetworkAddress, GNetworkService, GNotification, GOutputStream, GPermission, GPropertyAction, GProxyAddress, GProxyAddressEnumerator, GResolver, GSettings, GSettingsBackend, GSimpleAction, GSimpleActionGroup, GSimpleAsyncResult, GSimpleIOStream, GSimplePermission, GSimpleProxyResolver, GSocket, GSocketAddress, GSocketAddressEnumerator, GSocketClient, GSocketConnection, GSocketControlMessage, GSocketListener, GSocketService, GSubprocess, GSubprocessLauncher, GTask, GTcpConnection, GTcpWrapperConnection, GTestDBus, GThemedIcon, GThreadedSocketService, GTlsCertificate, GTlsConnection, GTlsDatabase, GTlsInteraction, GTlsPassword, GUnixConnection, GUnixCredentialsMessage, GUnixFDList, GUnixFDMessage, GUnixInputStream, GUnixMountMonitor, GUnixOutputStream, GUnixSocketAddress, GVfs, GVolumeMonitor, GZlibCompressor, GZlibDecompressor, GAction, GActionGroup, GActionMap, GAppInfo, GAsyncInitable, GAsyncResult, GConverter, GDBusInterface, GDBusObject, GDBusObjectManager, GDatagramBased, GDrive, GDtlsClientConnection, GDtlsConnection, GDtlsServerConnection, GFile, GFileDescriptorBased, GIcon, GInitable, GListModel, GLoadableIcon, GMemoryMonitor, GMount, GNetworkMonitor, GPollableInputStream, GPollableOutputStream, GPowerProfileMonitor, GProxy, GProxyResolver, GRemoteActionGroup, GSeekable, GSocketConnectable, GTlsBackend, GTlsClientConnection, GTlsFileDatabase, GTlsServerConnection, GVolume
end))
end
