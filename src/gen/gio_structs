quote
$(Expr(:toplevel, quote
    begin
        struct _GDBusErrorEntry
            error_code::Int32
            dbus_error_name::Cstring
        end
        mutable struct GDBusErrorEntry
            handle::Ptr{_GDBusErrorEntry}
        end
        unsafe_convert(::Type{Ptr{_GDBusErrorEntry}}, box::GDBusErrorEntry) = begin
                convert(Ptr{_GDBusErrorEntry}, box.handle)
            end
    end
    begin
        struct _GFileAttributeInfo
            name::Cstring
            type::UInt32
            flags::UInt32
        end
        mutable struct GFileAttributeInfo
            handle::Ptr{_GFileAttributeInfo}
        end
        unsafe_convert(::Type{Ptr{_GFileAttributeInfo}}, box::GFileAttributeInfo) = begin
                convert(Ptr{_GFileAttributeInfo}, box.handle)
            end
    end
    begin
        struct _GFileAttributeInfoList
            infos::Ptr{_GFileAttributeInfo}
            n_infos::Int32
        end
        mutable struct GFileAttributeInfoList <: GBoxed
            handle::Ptr{_GFileAttributeInfoList}
            begin
                (GLib.g_type(::Type{T}) where T <: GFileAttributeInfoList) = begin
                        ccall(("g_file_attribute_info_list_get_type", libgio), GType, ())
                    end
                function GFileAttributeInfoList(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GFileAttributeInfoList)
            end
        end
        unsafe_convert(::Type{Ptr{_GFileAttributeInfoList}}, box::GFileAttributeInfoList) = begin
                convert(Ptr{_GFileAttributeInfoList}, box.handle)
            end
    end
    mutable struct GFileAttributeMatcher <: GBoxed
        handle::Ptr{GFileAttributeMatcher}
        begin
            (GLib.g_type(::Type{T}) where T <: GFileAttributeMatcher) = begin
                    ccall(("g_file_attribute_matcher_get_type", libgio), GType, ())
                end
            function GFileAttributeMatcher(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GFileAttributeMatcher)
        end
    end
    begin
        struct _GInputVector
            buffer::Ptr{Nothing}
            size::UInt64
        end
        mutable struct GInputVector
            handle::Ptr{_GInputVector}
        end
        unsafe_convert(::Type{Ptr{_GInputVector}}, box::GInputVector) = begin
                convert(Ptr{_GInputVector}, box.handle)
            end
    end
    begin
        struct _GOutputVector
            buffer::Ptr{Nothing}
            size::UInt64
        end
        mutable struct GOutputVector
            handle::Ptr{_GOutputVector}
        end
        unsafe_convert(::Type{Ptr{_GOutputVector}}, box::GOutputVector) = begin
                convert(Ptr{_GOutputVector}, box.handle)
            end
    end
    mutable struct GResource <: GBoxed
        handle::Ptr{GResource}
        begin
            (GLib.g_type(::Type{T}) where T <: GResource) = begin
                    ccall(("g_resource_get_type", libgio), GType, ())
                end
            function GResource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GResource)
        end
    end
    mutable struct GSettingsSchema <: GBoxed
        handle::Ptr{GSettingsSchema}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchema) = begin
                    ccall(("g_settings_schema_get_type", libgio), GType, ())
                end
            function GSettingsSchema(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchema)
        end
    end
    mutable struct GSettingsSchemaKey <: GBoxed
        handle::Ptr{GSettingsSchemaKey}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchemaKey) = begin
                    ccall(("g_settings_schema_key_get_type", libgio), GType, ())
                end
            function GSettingsSchemaKey(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchemaKey)
        end
    end
    mutable struct GSettingsSchemaSource <: GBoxed
        handle::Ptr{GSettingsSchemaSource}
        begin
            (GLib.g_type(::Type{T}) where T <: GSettingsSchemaSource) = begin
                    ccall(("g_settings_schema_source_get_type", libgio), GType, ())
                end
            function GSettingsSchemaSource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSettingsSchemaSource)
        end
    end
    mutable struct GSrvTarget <: GBoxed
        handle::Ptr{GSrvTarget}
        begin
            (GLib.g_type(::Type{T}) where T <: GSrvTarget) = begin
                    ccall(("g_srv_target_get_type", libgio), GType, ())
                end
            function GSrvTarget(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                x = new(ref)
                if own
                    finalizer(x) do x
                        GLib.delboxed(x)
                    end
                end
                x
            end
            push!(gboxed_types, GSrvTarget)
        end
    end
    @doc "Struct used in g_dbus_error_register_error_domain().\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.DBusErrorEntry.html)." GDBusErrorEntry
    @doc "Information about a specific attribute.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.FileAttributeInfo.html)." GFileAttributeInfo
    @doc "Acts as a lightweight registry for possible valid file attributes.\nThe registry stores Key-Value pair formats as #GFileAttributeInfos.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.FileAttributeInfoList.html)." GFileAttributeInfoList
    @doc "Determines if a string matches a file attribute.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.FileAttributeMatcher.html)." GFileAttributeMatcher
    @doc "Structure used for scatter/gather data input.\nYou generally pass in an array of #GInputVectors\nand the operation will store the read data starting in the\nfirst buffer, switching to the next as needed.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.InputVector.html)." GInputVector
    @doc "Structure used for scatter/gather data output.\nYou generally pass in an array of #GOutputVectors\nand the operation will use all the buffers as if they were\none buffer.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.OutputVector.html)." GOutputVector
    @doc "Applications and libraries often contain binary or textual data that is\nreally part of the application, rather than user data. For instance\n#GtkBuilder .ui files, splashscreen images, GMenu markup XML, CSS files,\nicons, etc. These are often shipped as files in `\$datadir/appname`, or\nmanually included as literal strings in the code.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.Resource.html)." GResource
    @doc "The #GSettingsSchemaSource and #GSettingsSchema APIs provide a\nmechanism for advanced control over the loading of schemas and a\nmechanism for introspecting their content.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.SettingsSchema.html)." GSettingsSchema
    @doc "#GSettingsSchemaKey is an opaque data structure and can only be accessed\nusing the following functions.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.SettingsSchemaKey.html)." GSettingsSchemaKey
    @doc "This is an opaque structure type.  You may not access it directly.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.SettingsSchemaSource.html)." GSettingsSchemaSource
    @doc "SRV (service) records are used by some network protocols to provide\nservice-specific aliasing and load-balancing. For example, XMPP\n(Jabber) uses SRV records to locate the XMPP server for a domain;\nrather than connecting directly to \"example.com\" or assuming a\nspecific server hostname like \"xmpp.example.com\", an XMPP client\nwould look up the \"xmpp-client\" SRV record for \"example.com\", and\nthen connect to whatever host was pointed to by that record.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/struct.SrvTarget.html)." GSrvTarget
    begin
        abstract type GAppInfoMonitor <: GObject end
        mutable struct GAppInfoMonitorLeaf <: GAppInfoMonitor
            handle::Ptr{GObject}
            function GAppInfoMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GAppInfoMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GAppInfoMonitorLeaf(args...; kwargs...)
            w = GAppInfoMonitor(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GAppInfoMonitor] = GAppInfoMonitorLeaf
        function GAppInfoMonitor(args...; kwargs...)
            GAppInfoMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GAppLaunchContext <: GObject end
        mutable struct GAppLaunchContextLeaf <: GAppLaunchContext
            handle::Ptr{GObject}
            function GAppLaunchContextLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GAppLaunchContextLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GAppLaunchContextLeaf(args...; kwargs...)
            w = GAppLaunchContext(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GAppLaunchContext] = GAppLaunchContextLeaf
        function GAppLaunchContext(args...; kwargs...)
            GAppLaunchContextLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GApplication <: GObject end
        mutable struct GApplicationLeaf <: GApplication
            handle::Ptr{GObject}
            function GApplicationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GApplicationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GApplicationLeaf(args...; kwargs...)
            w = GApplication(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GApplication] = GApplicationLeaf
        function GApplication(args...; kwargs...)
            GApplicationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GApplicationCommandLine <: GObject end
        mutable struct GApplicationCommandLineLeaf <: GApplicationCommandLine
            handle::Ptr{GObject}
            function GApplicationCommandLineLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GApplicationCommandLineLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GApplicationCommandLineLeaf(args...; kwargs...)
            w = GApplicationCommandLine(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GApplicationCommandLine] = GApplicationCommandLineLeaf
        function GApplicationCommandLine(args...; kwargs...)
            GApplicationCommandLineLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GInputStream <: GObject end
        mutable struct GInputStreamLeaf <: GInputStream
            handle::Ptr{GObject}
            function GInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInputStreamLeaf(args...; kwargs...)
            w = GInputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GInputStream] = GInputStreamLeaf
        function GInputStream(args...; kwargs...)
            GInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFilterInputStream <: GInputStream end
        mutable struct GFilterInputStreamLeaf <: GFilterInputStream
            handle::Ptr{GObject}
            function GFilterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilterInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFilterInputStreamLeaf(args...; kwargs...)
            w = GFilterInputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFilterInputStream] = GFilterInputStreamLeaf
        function GFilterInputStream(args...; kwargs...)
            GFilterInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GBufferedInputStream <: GFilterInputStream end
        mutable struct GBufferedInputStreamLeaf <: GBufferedInputStream
            handle::Ptr{GObject}
            function GBufferedInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBufferedInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GBufferedInputStreamLeaf(args...; kwargs...)
            w = GBufferedInputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GBufferedInputStream] = GBufferedInputStreamLeaf
        function GBufferedInputStream(args...; kwargs...)
            GBufferedInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GOutputStream <: GObject end
        mutable struct GOutputStreamLeaf <: GOutputStream
            handle::Ptr{GObject}
            function GOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GOutputStreamLeaf(args...; kwargs...)
            w = GOutputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GOutputStream] = GOutputStreamLeaf
        function GOutputStream(args...; kwargs...)
            GOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFilterOutputStream <: GOutputStream end
        mutable struct GFilterOutputStreamLeaf <: GFilterOutputStream
            handle::Ptr{GObject}
            function GFilterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilterOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFilterOutputStreamLeaf(args...; kwargs...)
            w = GFilterOutputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFilterOutputStream] = GFilterOutputStreamLeaf
        function GFilterOutputStream(args...; kwargs...)
            GFilterOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GBufferedOutputStream <: GFilterOutputStream end
        mutable struct GBufferedOutputStreamLeaf <: GBufferedOutputStream
            handle::Ptr{GObject}
            function GBufferedOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBufferedOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GBufferedOutputStreamLeaf(args...; kwargs...)
            w = GBufferedOutputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GBufferedOutputStream] = GBufferedOutputStreamLeaf
        function GBufferedOutputStream(args...; kwargs...)
            GBufferedOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GBytesIcon <: GObject end
        mutable struct GBytesIconLeaf <: GBytesIcon
            handle::Ptr{GObject}
            function GBytesIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBytesIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GBytesIconLeaf(args...; kwargs...)
            w = GBytesIcon(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GBytesIcon] = GBytesIconLeaf
        function GBytesIcon(args...; kwargs...)
            GBytesIconLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GCancellable <: GObject end
        mutable struct GCancellableLeaf <: GCancellable
            handle::Ptr{GObject}
            function GCancellableLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCancellableLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GCancellableLeaf(args...; kwargs...)
            w = GCancellable(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GCancellable] = GCancellableLeaf
        function GCancellable(args...; kwargs...)
            GCancellableLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GCharsetConverter <: GObject end
        mutable struct GCharsetConverterLeaf <: GCharsetConverter
            handle::Ptr{GObject}
            function GCharsetConverterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCharsetConverterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GCharsetConverterLeaf(args...; kwargs...)
            w = GCharsetConverter(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GCharsetConverter] = GCharsetConverterLeaf
        function GCharsetConverter(args...; kwargs...)
            GCharsetConverterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GConverterInputStream <: GFilterInputStream end
        mutable struct GConverterInputStreamLeaf <: GConverterInputStream
            handle::Ptr{GObject}
            function GConverterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GConverterInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GConverterInputStreamLeaf(args...; kwargs...)
            w = GConverterInputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GConverterInputStream] = GConverterInputStreamLeaf
        function GConverterInputStream(args...; kwargs...)
            GConverterInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GConverterOutputStream <: GFilterOutputStream end
        mutable struct GConverterOutputStreamLeaf <: GConverterOutputStream
            handle::Ptr{GObject}
            function GConverterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GConverterOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GConverterOutputStreamLeaf(args...; kwargs...)
            w = GConverterOutputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GConverterOutputStream] = GConverterOutputStreamLeaf
        function GConverterOutputStream(args...; kwargs...)
            GConverterOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GCredentials <: GObject end
        mutable struct GCredentialsLeaf <: GCredentials
            handle::Ptr{GObject}
            function GCredentialsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GCredentialsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GCredentialsLeaf(args...; kwargs...)
            w = GCredentials(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GCredentials] = GCredentialsLeaf
        function GCredentials(args...; kwargs...)
            GCredentialsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusActionGroup <: GObject end
        mutable struct GDBusActionGroupLeaf <: GDBusActionGroup
            handle::Ptr{GObject}
            function GDBusActionGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusActionGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusActionGroupLeaf(args...; kwargs...)
            w = GDBusActionGroup(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusActionGroup] = GDBusActionGroupLeaf
        function GDBusActionGroup(args...; kwargs...)
            GDBusActionGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusAuthObserver <: GObject end
        mutable struct GDBusAuthObserverLeaf <: GDBusAuthObserver
            handle::Ptr{GObject}
            function GDBusAuthObserverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusAuthObserverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusAuthObserverLeaf(args...; kwargs...)
            w = GDBusAuthObserver(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusAuthObserver] = GDBusAuthObserverLeaf
        function GDBusAuthObserver(args...; kwargs...)
            GDBusAuthObserverLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusConnection <: GObject end
        mutable struct GDBusConnectionLeaf <: GDBusConnection
            handle::Ptr{GObject}
            function GDBusConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusConnectionLeaf(args...; kwargs...)
            w = GDBusConnection(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusConnection] = GDBusConnectionLeaf
        function GDBusConnection(args...; kwargs...)
            GDBusConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusInterfaceSkeleton <: GObject end
        mutable struct GDBusInterfaceSkeletonLeaf <: GDBusInterfaceSkeleton
            handle::Ptr{GObject}
            function GDBusInterfaceSkeletonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusInterfaceSkeletonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusInterfaceSkeletonLeaf(args...; kwargs...)
            w = GDBusInterfaceSkeleton(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusInterfaceSkeleton] = GDBusInterfaceSkeletonLeaf
        function GDBusInterfaceSkeleton(args...; kwargs...)
            GDBusInterfaceSkeletonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuModel <: GObject end
        mutable struct GMenuModelLeaf <: GMenuModel
            handle::Ptr{GObject}
            function GMenuModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuModelLeaf(args...; kwargs...)
            w = GMenuModel(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GMenuModel] = GMenuModelLeaf
        function GMenuModel(args...; kwargs...)
            GMenuModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusMenuModel <: GMenuModel end
        mutable struct GDBusMenuModelLeaf <: GDBusMenuModel
            handle::Ptr{GObject}
            function GDBusMenuModelLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMenuModelLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusMenuModelLeaf(args...; kwargs...)
            w = GDBusMenuModel(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusMenuModel] = GDBusMenuModelLeaf
        function GDBusMenuModel(args...; kwargs...)
            GDBusMenuModelLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusMessage <: GObject end
        mutable struct GDBusMessageLeaf <: GDBusMessage
            handle::Ptr{GObject}
            function GDBusMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMessageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusMessageLeaf(args...; kwargs...)
            w = GDBusMessage(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusMessage] = GDBusMessageLeaf
        function GDBusMessage(args...; kwargs...)
            GDBusMessageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusMethodInvocation <: GObject end
        mutable struct GDBusMethodInvocationLeaf <: GDBusMethodInvocation
            handle::Ptr{GObject}
            function GDBusMethodInvocationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusMethodInvocationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusMethodInvocationLeaf(args...; kwargs...)
            w = GDBusMethodInvocation(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusMethodInvocation] = GDBusMethodInvocationLeaf
        function GDBusMethodInvocation(args...; kwargs...)
            GDBusMethodInvocationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusObjectManagerClient <: GObject end
        mutable struct GDBusObjectManagerClientLeaf <: GDBusObjectManagerClient
            handle::Ptr{GObject}
            function GDBusObjectManagerClientLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectManagerClientLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectManagerClientLeaf(args...; kwargs...)
            w = GDBusObjectManagerClient(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusObjectManagerClient] = GDBusObjectManagerClientLeaf
        function GDBusObjectManagerClient(args...; kwargs...)
            GDBusObjectManagerClientLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusObjectManagerServer <: GObject end
        mutable struct GDBusObjectManagerServerLeaf <: GDBusObjectManagerServer
            handle::Ptr{GObject}
            function GDBusObjectManagerServerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectManagerServerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectManagerServerLeaf(args...; kwargs...)
            w = GDBusObjectManagerServer(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusObjectManagerServer] = GDBusObjectManagerServerLeaf
        function GDBusObjectManagerServer(args...; kwargs...)
            GDBusObjectManagerServerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusObjectProxy <: GObject end
        mutable struct GDBusObjectProxyLeaf <: GDBusObjectProxy
            handle::Ptr{GObject}
            function GDBusObjectProxyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectProxyLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectProxyLeaf(args...; kwargs...)
            w = GDBusObjectProxy(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusObjectProxy] = GDBusObjectProxyLeaf
        function GDBusObjectProxy(args...; kwargs...)
            GDBusObjectProxyLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusObjectSkeleton <: GObject end
        mutable struct GDBusObjectSkeletonLeaf <: GDBusObjectSkeleton
            handle::Ptr{GObject}
            function GDBusObjectSkeletonLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusObjectSkeletonLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusObjectSkeletonLeaf(args...; kwargs...)
            w = GDBusObjectSkeleton(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusObjectSkeleton] = GDBusObjectSkeletonLeaf
        function GDBusObjectSkeleton(args...; kwargs...)
            GDBusObjectSkeletonLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusProxy <: GObject end
        mutable struct GDBusProxyLeaf <: GDBusProxy
            handle::Ptr{GObject}
            function GDBusProxyLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusProxyLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusProxyLeaf(args...; kwargs...)
            w = GDBusProxy(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusProxy] = GDBusProxyLeaf
        function GDBusProxy(args...; kwargs...)
            GDBusProxyLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDBusServer <: GObject end
        mutable struct GDBusServerLeaf <: GDBusServer
            handle::Ptr{GObject}
            function GDBusServerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDBusServerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDBusServerLeaf(args...; kwargs...)
            w = GDBusServer(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDBusServer] = GDBusServerLeaf
        function GDBusServer(args...; kwargs...)
            GDBusServerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDataInputStream <: GBufferedInputStream end
        mutable struct GDataInputStreamLeaf <: GDataInputStream
            handle::Ptr{GObject}
            function GDataInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDataInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDataInputStreamLeaf(args...; kwargs...)
            w = GDataInputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDataInputStream] = GDataInputStreamLeaf
        function GDataInputStream(args...; kwargs...)
            GDataInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDataOutputStream <: GFilterOutputStream end
        mutable struct GDataOutputStreamLeaf <: GDataOutputStream
            handle::Ptr{GObject}
            function GDataOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDataOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDataOutputStreamLeaf(args...; kwargs...)
            w = GDataOutputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDataOutputStream] = GDataOutputStreamLeaf
        function GDataOutputStream(args...; kwargs...)
            GDataOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GDesktopAppInfo <: GObject end
        mutable struct GDesktopAppInfoLeaf <: GDesktopAppInfo
            handle::Ptr{GObject}
            function GDesktopAppInfoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GDesktopAppInfoLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GDesktopAppInfoLeaf(args...; kwargs...)
            w = GDesktopAppInfo(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GDesktopAppInfo] = GDesktopAppInfoLeaf
        function GDesktopAppInfo(args...; kwargs...)
            GDesktopAppInfoLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GEmblem <: GObject end
        mutable struct GEmblemLeaf <: GEmblem
            handle::Ptr{GObject}
            function GEmblemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GEmblemLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GEmblemLeaf(args...; kwargs...)
            w = GEmblem(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GEmblem] = GEmblemLeaf
        function GEmblem(args...; kwargs...)
            GEmblemLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GEmblemedIcon <: GObject end
        mutable struct GEmblemedIconLeaf <: GEmblemedIcon
            handle::Ptr{GObject}
            function GEmblemedIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GEmblemedIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GEmblemedIconLeaf(args...; kwargs...)
            w = GEmblemedIcon(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GEmblemedIcon] = GEmblemedIconLeaf
        function GEmblemedIcon(args...; kwargs...)
            GEmblemedIconLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileEnumerator <: GObject end
        mutable struct GFileEnumeratorLeaf <: GFileEnumerator
            handle::Ptr{GObject}
            function GFileEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileEnumeratorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileEnumeratorLeaf(args...; kwargs...)
            w = GFileEnumerator(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFileEnumerator] = GFileEnumeratorLeaf
        function GFileEnumerator(args...; kwargs...)
            GFileEnumeratorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GIOStream <: GObject end
        mutable struct GIOStreamLeaf <: GIOStream
            handle::Ptr{GObject}
            function GIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GIOStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GIOStreamLeaf(args...; kwargs...)
            w = GIOStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GIOStream] = GIOStreamLeaf
        function GIOStream(args...; kwargs...)
            GIOStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileIOStream <: GIOStream end
        mutable struct GFileIOStreamLeaf <: GFileIOStream
            handle::Ptr{GObject}
            function GFileIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileIOStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileIOStreamLeaf(args...; kwargs...)
            w = GFileIOStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFileIOStream] = GFileIOStreamLeaf
        function GFileIOStream(args...; kwargs...)
            GFileIOStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileIcon <: GObject end
        mutable struct GFileIconLeaf <: GFileIcon
            handle::Ptr{GObject}
            function GFileIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileIconLeaf(args...; kwargs...)
            w = GFileIcon(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFileIcon] = GFileIconLeaf
        function GFileIcon(args...; kwargs...)
            GFileIconLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileInfo <: GObject end
        mutable struct GFileInfoLeaf <: GFileInfo
            handle::Ptr{GObject}
            function GFileInfoLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileInfoLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileInfoLeaf(args...; kwargs...)
            w = GFileInfo(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFileInfo] = GFileInfoLeaf
        function GFileInfo(args...; kwargs...)
            GFileInfoLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileInputStream <: GInputStream end
        mutable struct GFileInputStreamLeaf <: GFileInputStream
            handle::Ptr{GObject}
            function GFileInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileInputStreamLeaf(args...; kwargs...)
            w = GFileInputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFileInputStream] = GFileInputStreamLeaf
        function GFileInputStream(args...; kwargs...)
            GFileInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileMonitor <: GObject end
        mutable struct GFileMonitorLeaf <: GFileMonitor
            handle::Ptr{GObject}
            function GFileMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileMonitorLeaf(args...; kwargs...)
            w = GFileMonitor(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFileMonitor] = GFileMonitorLeaf
        function GFileMonitor(args...; kwargs...)
            GFileMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFileOutputStream <: GOutputStream end
        mutable struct GFileOutputStreamLeaf <: GFileOutputStream
            handle::Ptr{GObject}
            function GFileOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFileOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFileOutputStreamLeaf(args...; kwargs...)
            w = GFileOutputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFileOutputStream] = GFileOutputStreamLeaf
        function GFileOutputStream(args...; kwargs...)
            GFileOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GFilenameCompleter <: GObject end
        mutable struct GFilenameCompleterLeaf <: GFilenameCompleter
            handle::Ptr{GObject}
            function GFilenameCompleterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GFilenameCompleterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GFilenameCompleterLeaf(args...; kwargs...)
            w = GFilenameCompleter(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GFilenameCompleter] = GFilenameCompleterLeaf
        function GFilenameCompleter(args...; kwargs...)
            GFilenameCompleterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GIOModule <: GTypeModule end
        mutable struct GIOModuleLeaf <: GIOModule
            handle::Ptr{GObject}
            function GIOModuleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GIOModuleLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GIOModuleLeaf(args...; kwargs...)
            w = GIOModule(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GIOModule] = GIOModuleLeaf
        function GIOModule(args...; kwargs...)
            GIOModuleLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GInetAddress <: GObject end
        mutable struct GInetAddressLeaf <: GInetAddress
            handle::Ptr{GObject}
            function GInetAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInetAddressLeaf(args...; kwargs...)
            w = GInetAddress(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GInetAddress] = GInetAddressLeaf
        function GInetAddress(args...; kwargs...)
            GInetAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GInetAddressMask <: GObject end
        mutable struct GInetAddressMaskLeaf <: GInetAddressMask
            handle::Ptr{GObject}
            function GInetAddressMaskLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetAddressMaskLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInetAddressMaskLeaf(args...; kwargs...)
            w = GInetAddressMask(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GInetAddressMask] = GInetAddressMaskLeaf
        function GInetAddressMask(args...; kwargs...)
            GInetAddressMaskLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketAddress <: GObject end
        mutable struct GSocketAddressLeaf <: GSocketAddress
            handle::Ptr{GObject}
            function GSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketAddressLeaf(args...; kwargs...)
            w = GSocketAddress(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSocketAddress] = GSocketAddressLeaf
        function GSocketAddress(args...; kwargs...)
            GSocketAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GInetSocketAddress <: GSocketAddress end
        mutable struct GInetSocketAddressLeaf <: GInetSocketAddress
            handle::Ptr{GObject}
            function GInetSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInetSocketAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GInetSocketAddressLeaf(args...; kwargs...)
            w = GInetSocketAddress(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GInetSocketAddress] = GInetSocketAddressLeaf
        function GInetSocketAddress(args...; kwargs...)
            GInetSocketAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GListStore <: GObject end
        mutable struct GListStoreLeaf <: GListStore
            handle::Ptr{GObject}
            function GListStoreLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GListStoreLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GListStoreLeaf(args...; kwargs...)
            w = GListStore(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GListStore] = GListStoreLeaf
        function GListStore(args...; kwargs...)
            GListStoreLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMemoryInputStream <: GInputStream end
        mutable struct GMemoryInputStreamLeaf <: GMemoryInputStream
            handle::Ptr{GObject}
            function GMemoryInputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMemoryInputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMemoryInputStreamLeaf(args...; kwargs...)
            w = GMemoryInputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GMemoryInputStream] = GMemoryInputStreamLeaf
        function GMemoryInputStream(args...; kwargs...)
            GMemoryInputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMemoryOutputStream <: GOutputStream end
        mutable struct GMemoryOutputStreamLeaf <: GMemoryOutputStream
            handle::Ptr{GObject}
            function GMemoryOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMemoryOutputStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMemoryOutputStreamLeaf(args...; kwargs...)
            w = GMemoryOutputStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GMemoryOutputStream] = GMemoryOutputStreamLeaf
        function GMemoryOutputStream(args...; kwargs...)
            GMemoryOutputStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenu <: GMenuModel end
        mutable struct GMenuLeaf <: GMenu
            handle::Ptr{GObject}
            function GMenuLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuLeaf(args...; kwargs...)
            w = GMenu(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GMenu] = GMenuLeaf
        function GMenu(args...; kwargs...)
            GMenuLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuAttributeIter <: GObject end
        mutable struct GMenuAttributeIterLeaf <: GMenuAttributeIter
            handle::Ptr{GObject}
            function GMenuAttributeIterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuAttributeIterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuAttributeIterLeaf(args...; kwargs...)
            w = GMenuAttributeIter(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GMenuAttributeIter] = GMenuAttributeIterLeaf
        function GMenuAttributeIter(args...; kwargs...)
            GMenuAttributeIterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuItem <: GObject end
        mutable struct GMenuItemLeaf <: GMenuItem
            handle::Ptr{GObject}
            function GMenuItemLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuItemLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuItemLeaf(args...; kwargs...)
            w = GMenuItem(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GMenuItem] = GMenuItemLeaf
        function GMenuItem(args...; kwargs...)
            GMenuItemLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMenuLinkIter <: GObject end
        mutable struct GMenuLinkIterLeaf <: GMenuLinkIter
            handle::Ptr{GObject}
            function GMenuLinkIterLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMenuLinkIterLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMenuLinkIterLeaf(args...; kwargs...)
            w = GMenuLinkIter(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GMenuLinkIter] = GMenuLinkIterLeaf
        function GMenuLinkIter(args...; kwargs...)
            GMenuLinkIterLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GMountOperation <: GObject end
        mutable struct GMountOperationLeaf <: GMountOperation
            handle::Ptr{GObject}
            function GMountOperationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GMountOperationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GMountOperationLeaf(args...; kwargs...)
            w = GMountOperation(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GMountOperation] = GMountOperationLeaf
        function GMountOperation(args...; kwargs...)
            GMountOperationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNativeSocketAddress <: GSocketAddress end
        mutable struct GNativeSocketAddressLeaf <: GNativeSocketAddress
            handle::Ptr{GObject}
            function GNativeSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNativeSocketAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNativeSocketAddressLeaf(args...; kwargs...)
            w = GNativeSocketAddress(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GNativeSocketAddress] = GNativeSocketAddressLeaf
        function GNativeSocketAddress(args...; kwargs...)
            GNativeSocketAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GVolumeMonitor <: GObject end
        mutable struct GVolumeMonitorLeaf <: GVolumeMonitor
            handle::Ptr{GObject}
            function GVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GVolumeMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GVolumeMonitorLeaf(args...; kwargs...)
            w = GVolumeMonitor(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GVolumeMonitor] = GVolumeMonitorLeaf
        function GVolumeMonitor(args...; kwargs...)
            GVolumeMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNativeVolumeMonitor <: GVolumeMonitor end
        mutable struct GNativeVolumeMonitorLeaf <: GNativeVolumeMonitor
            handle::Ptr{GObject}
            function GNativeVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNativeVolumeMonitorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNativeVolumeMonitorLeaf(args...; kwargs...)
            w = GNativeVolumeMonitor(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GNativeVolumeMonitor] = GNativeVolumeMonitorLeaf
        function GNativeVolumeMonitor(args...; kwargs...)
            GNativeVolumeMonitorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNetworkAddress <: GObject end
        mutable struct GNetworkAddressLeaf <: GNetworkAddress
            handle::Ptr{GObject}
            function GNetworkAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNetworkAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNetworkAddressLeaf(args...; kwargs...)
            w = GNetworkAddress(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GNetworkAddress] = GNetworkAddressLeaf
        function GNetworkAddress(args...; kwargs...)
            GNetworkAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNetworkService <: GObject end
        mutable struct GNetworkServiceLeaf <: GNetworkService
            handle::Ptr{GObject}
            function GNetworkServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNetworkServiceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNetworkServiceLeaf(args...; kwargs...)
            w = GNetworkService(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GNetworkService] = GNetworkServiceLeaf
        function GNetworkService(args...; kwargs...)
            GNetworkServiceLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GNotification <: GObject end
        mutable struct GNotificationLeaf <: GNotification
            handle::Ptr{GObject}
            function GNotificationLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GNotificationLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GNotificationLeaf(args...; kwargs...)
            w = GNotification(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GNotification] = GNotificationLeaf
        function GNotification(args...; kwargs...)
            GNotificationLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GPermission <: GObject end
        mutable struct GPermissionLeaf <: GPermission
            handle::Ptr{GObject}
            function GPermissionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GPermissionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GPermissionLeaf(args...; kwargs...)
            w = GPermission(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GPermission] = GPermissionLeaf
        function GPermission(args...; kwargs...)
            GPermissionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GPropertyAction <: GObject end
        mutable struct GPropertyActionLeaf <: GPropertyAction
            handle::Ptr{GObject}
            function GPropertyActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GPropertyActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GPropertyActionLeaf(args...; kwargs...)
            w = GPropertyAction(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GPropertyAction] = GPropertyActionLeaf
        function GPropertyAction(args...; kwargs...)
            GPropertyActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GProxyAddress <: GInetSocketAddress end
        mutable struct GProxyAddressLeaf <: GProxyAddress
            handle::Ptr{GObject}
            function GProxyAddressLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GProxyAddressLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GProxyAddressLeaf(args...; kwargs...)
            w = GProxyAddress(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GProxyAddress] = GProxyAddressLeaf
        function GProxyAddress(args...; kwargs...)
            GProxyAddressLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketAddressEnumerator <: GObject end
        mutable struct GSocketAddressEnumeratorLeaf <: GSocketAddressEnumerator
            handle::Ptr{GObject}
            function GSocketAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketAddressEnumeratorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketAddressEnumeratorLeaf(args...; kwargs...)
            w = GSocketAddressEnumerator(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSocketAddressEnumerator] = GSocketAddressEnumeratorLeaf
        function GSocketAddressEnumerator(args...; kwargs...)
            GSocketAddressEnumeratorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GProxyAddressEnumerator <: GSocketAddressEnumerator end
        mutable struct GProxyAddressEnumeratorLeaf <: GProxyAddressEnumerator
            handle::Ptr{GObject}
            function GProxyAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GProxyAddressEnumeratorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GProxyAddressEnumeratorLeaf(args...; kwargs...)
            w = GProxyAddressEnumerator(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GProxyAddressEnumerator] = GProxyAddressEnumeratorLeaf
        function GProxyAddressEnumerator(args...; kwargs...)
            GProxyAddressEnumeratorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GResolver <: GObject end
        mutable struct GResolverLeaf <: GResolver
            handle::Ptr{GObject}
            function GResolverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GResolverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GResolverLeaf(args...; kwargs...)
            w = GResolver(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GResolver] = GResolverLeaf
        function GResolver(args...; kwargs...)
            GResolverLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSettings <: GObject end
        mutable struct GSettingsLeaf <: GSettings
            handle::Ptr{GObject}
            function GSettingsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSettingsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSettingsLeaf(args...; kwargs...)
            w = GSettings(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSettings] = GSettingsLeaf
        function GSettings(args...; kwargs...)
            GSettingsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSettingsBackend <: GObject end
        mutable struct GSettingsBackendLeaf <: GSettingsBackend
            handle::Ptr{GObject}
            function GSettingsBackendLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSettingsBackendLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSettingsBackendLeaf(args...; kwargs...)
            w = GSettingsBackend(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSettingsBackend] = GSettingsBackendLeaf
        function GSettingsBackend(args...; kwargs...)
            GSettingsBackendLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleAction <: GObject end
        mutable struct GSimpleActionLeaf <: GSimpleAction
            handle::Ptr{GObject}
            function GSimpleActionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleActionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleActionLeaf(args...; kwargs...)
            w = GSimpleAction(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSimpleAction] = GSimpleActionLeaf
        function GSimpleAction(args...; kwargs...)
            GSimpleActionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleActionGroup <: GObject end
        mutable struct GSimpleActionGroupLeaf <: GSimpleActionGroup
            handle::Ptr{GObject}
            function GSimpleActionGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleActionGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleActionGroupLeaf(args...; kwargs...)
            w = GSimpleActionGroup(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSimpleActionGroup] = GSimpleActionGroupLeaf
        function GSimpleActionGroup(args...; kwargs...)
            GSimpleActionGroupLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleAsyncResult <: GObject end
        mutable struct GSimpleAsyncResultLeaf <: GSimpleAsyncResult
            handle::Ptr{GObject}
            function GSimpleAsyncResultLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleAsyncResultLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleAsyncResultLeaf(args...; kwargs...)
            w = GSimpleAsyncResult(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSimpleAsyncResult] = GSimpleAsyncResultLeaf
        function GSimpleAsyncResult(args...; kwargs...)
            GSimpleAsyncResultLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleIOStream <: GIOStream end
        mutable struct GSimpleIOStreamLeaf <: GSimpleIOStream
            handle::Ptr{GObject}
            function GSimpleIOStreamLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleIOStreamLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleIOStreamLeaf(args...; kwargs...)
            w = GSimpleIOStream(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSimpleIOStream] = GSimpleIOStreamLeaf
        function GSimpleIOStream(args...; kwargs...)
            GSimpleIOStreamLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimplePermission <: GPermission end
        mutable struct GSimplePermissionLeaf <: GSimplePermission
            handle::Ptr{GObject}
            function GSimplePermissionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimplePermissionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimplePermissionLeaf(args...; kwargs...)
            w = GSimplePermission(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSimplePermission] = GSimplePermissionLeaf
        function GSimplePermission(args...; kwargs...)
            GSimplePermissionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSimpleProxyResolver <: GObject end
        mutable struct GSimpleProxyResolverLeaf <: GSimpleProxyResolver
            handle::Ptr{GObject}
            function GSimpleProxyResolverLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSimpleProxyResolverLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSimpleProxyResolverLeaf(args...; kwargs...)
            w = GSimpleProxyResolver(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSimpleProxyResolver] = GSimpleProxyResolverLeaf
        function GSimpleProxyResolver(args...; kwargs...)
            GSimpleProxyResolverLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocket <: GObject end
        mutable struct GSocketLeaf <: GSocket
            handle::Ptr{GObject}
            function GSocketLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketLeaf(args...; kwargs...)
            w = GSocket(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSocket] = GSocketLeaf
        function GSocket(args...; kwargs...)
            GSocketLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketClient <: GObject end
        mutable struct GSocketClientLeaf <: GSocketClient
            handle::Ptr{GObject}
            function GSocketClientLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketClientLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketClientLeaf(args...; kwargs...)
            w = GSocketClient(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSocketClient] = GSocketClientLeaf
        function GSocketClient(args...; kwargs...)
            GSocketClientLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketConnection <: GIOStream end
        mutable struct GSocketConnectionLeaf <: GSocketConnection
            handle::Ptr{GObject}
            function GSocketConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketConnectionLeaf(args...; kwargs...)
            w = GSocketConnection(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSocketConnection] = GSocketConnectionLeaf
        function GSocketConnection(args...; kwargs...)
            GSocketConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketControlMessage <: GObject end
        mutable struct GSocketControlMessageLeaf <: GSocketControlMessage
            handle::Ptr{GObject}
            function GSocketControlMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketControlMessageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketControlMessageLeaf(args...; kwargs...)
            w = GSocketControlMessage(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSocketControlMessage] = GSocketControlMessageLeaf
        function GSocketControlMessage(args...; kwargs...)
            GSocketControlMessageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketListener <: GObject end
        mutable struct GSocketListenerLeaf <: GSocketListener
            handle::Ptr{GObject}
            function GSocketListenerLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketListenerLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketListenerLeaf(args...; kwargs...)
            w = GSocketListener(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSocketListener] = GSocketListenerLeaf
        function GSocketListener(args...; kwargs...)
            GSocketListenerLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSocketService <: GSocketListener end
        mutable struct GSocketServiceLeaf <: GSocketService
            handle::Ptr{GObject}
            function GSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSocketServiceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSocketServiceLeaf(args...; kwargs...)
            w = GSocketService(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSocketService] = GSocketServiceLeaf
        function GSocketService(args...; kwargs...)
            GSocketServiceLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSubprocess <: GObject end
        mutable struct GSubprocessLeaf <: GSubprocess
            handle::Ptr{GObject}
            function GSubprocessLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSubprocessLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSubprocessLeaf(args...; kwargs...)
            w = GSubprocess(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSubprocess] = GSubprocessLeaf
        function GSubprocess(args...; kwargs...)
            GSubprocessLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GSubprocessLauncher <: GObject end
        mutable struct GSubprocessLauncherLeaf <: GSubprocessLauncher
            handle::Ptr{GObject}
            function GSubprocessLauncherLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GSubprocessLauncherLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GSubprocessLauncherLeaf(args...; kwargs...)
            w = GSubprocessLauncher(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GSubprocessLauncher] = GSubprocessLauncherLeaf
        function GSubprocessLauncher(args...; kwargs...)
            GSubprocessLauncherLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTask <: GObject end
        mutable struct GTaskLeaf <: GTask
            handle::Ptr{GObject}
            function GTaskLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTaskLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTaskLeaf(args...; kwargs...)
            w = GTask(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GTask] = GTaskLeaf
        function GTask(args...; kwargs...)
            GTaskLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTcpConnection <: GSocketConnection end
        mutable struct GTcpConnectionLeaf <: GTcpConnection
            handle::Ptr{GObject}
            function GTcpConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTcpConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTcpConnectionLeaf(args...; kwargs...)
            w = GTcpConnection(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GTcpConnection] = GTcpConnectionLeaf
        function GTcpConnection(args...; kwargs...)
            GTcpConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTcpWrapperConnection <: GTcpConnection end
        mutable struct GTcpWrapperConnectionLeaf <: GTcpWrapperConnection
            handle::Ptr{GObject}
            function GTcpWrapperConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTcpWrapperConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTcpWrapperConnectionLeaf(args...; kwargs...)
            w = GTcpWrapperConnection(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GTcpWrapperConnection] = GTcpWrapperConnectionLeaf
        function GTcpWrapperConnection(args...; kwargs...)
            GTcpWrapperConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTestDBus <: GObject end
        mutable struct GTestDBusLeaf <: GTestDBus
            handle::Ptr{GObject}
            function GTestDBusLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTestDBusLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTestDBusLeaf(args...; kwargs...)
            w = GTestDBus(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GTestDBus] = GTestDBusLeaf
        function GTestDBus(args...; kwargs...)
            GTestDBusLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GThemedIcon <: GObject end
        mutable struct GThemedIconLeaf <: GThemedIcon
            handle::Ptr{GObject}
            function GThemedIconLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GThemedIconLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GThemedIconLeaf(args...; kwargs...)
            w = GThemedIcon(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GThemedIcon] = GThemedIconLeaf
        function GThemedIcon(args...; kwargs...)
            GThemedIconLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GThreadedSocketService <: GSocketService end
        mutable struct GThreadedSocketServiceLeaf <: GThreadedSocketService
            handle::Ptr{GObject}
            function GThreadedSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GThreadedSocketServiceLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GThreadedSocketServiceLeaf(args...; kwargs...)
            w = GThreadedSocketService(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GThreadedSocketService] = GThreadedSocketServiceLeaf
        function GThreadedSocketService(args...; kwargs...)
            GThreadedSocketServiceLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsCertificate <: GObject end
        mutable struct GTlsCertificateLeaf <: GTlsCertificate
            handle::Ptr{GObject}
            function GTlsCertificateLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsCertificateLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsCertificateLeaf(args...; kwargs...)
            w = GTlsCertificate(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GTlsCertificate] = GTlsCertificateLeaf
        function GTlsCertificate(args...; kwargs...)
            GTlsCertificateLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsConnection <: GIOStream end
        mutable struct GTlsConnectionLeaf <: GTlsConnection
            handle::Ptr{GObject}
            function GTlsConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsConnectionLeaf(args...; kwargs...)
            w = GTlsConnection(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GTlsConnection] = GTlsConnectionLeaf
        function GTlsConnection(args...; kwargs...)
            GTlsConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsDatabase <: GObject end
        mutable struct GTlsDatabaseLeaf <: GTlsDatabase
            handle::Ptr{GObject}
            function GTlsDatabaseLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsDatabaseLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsDatabaseLeaf(args...; kwargs...)
            w = GTlsDatabase(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GTlsDatabase] = GTlsDatabaseLeaf
        function GTlsDatabase(args...; kwargs...)
            GTlsDatabaseLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsInteraction <: GObject end
        mutable struct GTlsInteractionLeaf <: GTlsInteraction
            handle::Ptr{GObject}
            function GTlsInteractionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsInteractionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsInteractionLeaf(args...; kwargs...)
            w = GTlsInteraction(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GTlsInteraction] = GTlsInteractionLeaf
        function GTlsInteraction(args...; kwargs...)
            GTlsInteractionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GTlsPassword <: GObject end
        mutable struct GTlsPasswordLeaf <: GTlsPassword
            handle::Ptr{GObject}
            function GTlsPasswordLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTlsPasswordLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GTlsPasswordLeaf(args...; kwargs...)
            w = GTlsPassword(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GTlsPassword] = GTlsPasswordLeaf
        function GTlsPassword(args...; kwargs...)
            GTlsPasswordLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GUnixConnection <: GSocketConnection end
        mutable struct GUnixConnectionLeaf <: GUnixConnection
            handle::Ptr{GObject}
            function GUnixConnectionLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixConnectionLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixConnectionLeaf(args...; kwargs...)
            w = GUnixConnection(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GUnixConnection] = GUnixConnectionLeaf
        function GUnixConnection(args...; kwargs...)
            GUnixConnectionLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GUnixCredentialsMessage <: GSocketControlMessage end
        mutable struct GUnixCredentialsMessageLeaf <: GUnixCredentialsMessage
            handle::Ptr{GObject}
            function GUnixCredentialsMessageLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GUnixCredentialsMessageLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GUnixCredentialsMessageLeaf(args...; kwargs...)
            w = GUnixCredentialsMessage(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GUnixCredentialsMessage] = GUnixCredentialsMessageLeaf
        function GUnixCredentialsMessage(args...; kwargs...)
            GUnixCredentialsMessageLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GVfs <: GObject end
        mutable struct GVfsLeaf <: GVfs
            handle::Ptr{GObject}
            function GVfsLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GVfsLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GVfsLeaf(args...; kwargs...)
            w = GVfs(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GVfs] = GVfsLeaf
        function GVfs(args...; kwargs...)
            GVfsLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GZlibCompressor <: GObject end
        mutable struct GZlibCompressorLeaf <: GZlibCompressor
            handle::Ptr{GObject}
            function GZlibCompressorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GZlibCompressorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GZlibCompressorLeaf(args...; kwargs...)
            w = GZlibCompressor(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GZlibCompressor] = GZlibCompressorLeaf
        function GZlibCompressor(args...; kwargs...)
            GZlibCompressorLeaf(args...; kwargs...)
        end
    end
    begin
        abstract type GZlibDecompressor <: GObject end
        mutable struct GZlibDecompressorLeaf <: GZlibDecompressor
            handle::Ptr{GObject}
            function GZlibDecompressorLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GZlibDecompressorLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        local kwargs
        function GZlibDecompressorLeaf(args...; kwargs...)
            w = GZlibDecompressor(args...)
            setproperties!(w; kwargs...)
            w
        end
        gtype_wrapper_cache[:GZlibDecompressor] = GZlibDecompressorLeaf
        function GZlibDecompressor(args...; kwargs...)
            GZlibDecompressorLeaf(args...; kwargs...)
        end
    end
    @doc "#GAppInfoMonitor is a very simple object used for monitoring the app\ninfo database for changes (ie: newly installed or removed\napplications).\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.AppInfoMonitor.html)." GAppInfoMonitor
    @doc "Integrating the launch with the launching application. This is used to\nhandle for instance startup notification and launching the new application\non the same screen as the launching window.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.AppLaunchContext.html)." GAppLaunchContext
    @doc "A #GApplication is the foundation of an application.  It wraps some\nlow-level platform-specific services and is intended to act as the\nfoundation for higher-level application classes such as\n#GtkApplication or #MxApplication.  In general, you should not use\nthis class outside of a higher level framework.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Application.html)." GApplication
    @doc "#GApplicationCommandLine represents a command-line invocation of\nan application.  It is created by #GApplication and emitted\nin the #GApplication::command-line signal and virtual function.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ApplicationCommandLine.html)." GApplicationCommandLine
    @doc "Buffered input stream implements #GFilterInputStream and provides\nfor buffered reads.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.BufferedInputStream.html)." GBufferedInputStream
    @doc "Buffered output stream implements #GFilterOutputStream and provides\nfor buffered writes.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.BufferedOutputStream.html)." GBufferedOutputStream
    @doc "#GBytesIcon specifies an image held in memory in a common format (usually\npng) to be used as icon.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.BytesIcon.html)." GBytesIcon
    @doc "GCancellable is a thread-safe operation cancellation stack used\nthroughout GIO to allow for cancellation of synchronous and\nasynchronous operations.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Cancellable.html)." GCancellable
    @doc "#GCharsetConverter is an implementation of #GConverter based on\nGIConv.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.CharsetConverter.html)." GCharsetConverter
    @doc "Converter input stream implements #GInputStream and allows\nconversion of data of various types during reading.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ConverterInputStream.html)." GConverterInputStream
    @doc "Converter output stream implements #GOutputStream and allows\nconversion of data of various types during reading.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ConverterOutputStream.html)." GConverterOutputStream
    @doc "The #GCredentials type is a reference-counted wrapper for native\ncredentials. This information is typically used for identifying,\nauthenticating and authorizing other processes.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Credentials.html)." GCredentials
    @doc "#GDBusActionGroup is an implementation of the #GActionGroup\ninterface that can be used as a proxy for an action group\nthat is exported over D-Bus with g_dbus_connection_export_action_group().\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusActionGroup.html)." GDBusActionGroup
    @doc "The #GDBusAuthObserver type provides a mechanism for participating\nin how a #GDBusServer (or a #GDBusConnection) authenticates remote\npeers. Simply instantiate a #GDBusAuthObserver and connect to the\nsignals you are interested in. Note that new signals may be added\nin the future\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusAuthObserver.html)." GDBusAuthObserver
    @doc "The #GDBusConnection type is used for D-Bus connections to remote\npeers such as a message buses. It is a low-level API that offers a\nlot of flexibility. For instance, it lets you establish a connection\nover any transport that can by represented as a #GIOStream.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusConnection.html)." GDBusConnection
    @doc "Abstract base class for D-Bus interfaces on the service side.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusInterfaceSkeleton.html)." GDBusInterfaceSkeleton
    @doc "#GDBusMenuModel is an implementation of #GMenuModel that can be used\nas a proxy for a menu model that is exported over D-Bus with\ng_dbus_connection_export_menu_model().\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusMenuModel.html)." GDBusMenuModel
    @doc "A type for representing D-Bus messages that can be sent or received\non a #GDBusConnection.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusMessage.html)." GDBusMessage
    @doc "Instances of the #GDBusMethodInvocation class are used when\nhandling D-Bus method calls. It provides a way to asynchronously\nreturn results and errors.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusMethodInvocation.html)." GDBusMethodInvocation
    @doc "#GDBusObjectManagerClient is used to create, monitor and delete object\nproxies for remote objects exported by a #GDBusObjectManagerServer (or any\ncode implementing the\n[org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)\ninterface).\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectManagerClient.html)." GDBusObjectManagerClient
    @doc "#GDBusObjectManagerServer is used to export #GDBusObject instances using\nthe standardized\n[org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)\ninterface. For example, remote D-Bus clients can get all objects\nand properties in a single call. Additionally, any change in the\nobject hierarchy is broadcast using signals. This means that D-Bus\nclients can keep caches up to date by only listening to D-Bus\nsignals.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectManagerServer.html)." GDBusObjectManagerServer
    @doc "A #GDBusObjectProxy is an object used to represent a remote object\nwith one or more D-Bus interfaces. Normally, you don't instantiate\na #GDBusObjectProxy yourself - typically #GDBusObjectManagerClient\nis used to obtain it.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectProxy.html)." GDBusObjectProxy
    @doc "A #GDBusObjectSkeleton instance is essentially a group of D-Bus\ninterfaces. The set of exported interfaces on the object may be\ndynamic and change at runtime.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectSkeleton.html)." GDBusObjectSkeleton
    @doc "#GDBusProxy is a base class used for proxies to access a D-Bus\ninterface on a remote object. A #GDBusProxy can be constructed for\nboth well-known and unique names.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusProxy.html)." GDBusProxy
    @doc "#GDBusServer is a helper for listening to and accepting D-Bus\nconnections. This can be used to create a new D-Bus server, allowing two\npeers to use the D-Bus protocol for their own specialized communication.\nA server instance provided in this way will not perform message routing or\nimplement the org.freedesktop.DBus interface.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DBusServer.html)." GDBusServer
    @doc "Data input stream implements #GInputStream and includes functions for\nreading structured data directly from a binary input stream.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DataInputStream.html)." GDataInputStream
    @doc "Data output stream implements #GOutputStream and includes functions for\nwriting data directly to an output stream.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DataOutputStream.html)." GDataOutputStream
    @doc "#GDesktopAppInfo is an implementation of #GAppInfo based on\ndesktop files.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.DesktopAppInfo.html)." GDesktopAppInfo
    @doc "#GEmblem is an implementation of #GIcon that supports\nhaving an emblem, which is an icon with additional properties.\nIt can than be added to a #GEmblemedIcon.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Emblem.html)." GEmblem
    @doc "#GEmblemedIcon is an implementation of #GIcon that supports\nadding an emblem to an icon. Adding multiple emblems to an\nicon is ensured via g_emblemed_icon_add_emblem().\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.EmblemedIcon.html)." GEmblemedIcon
    @doc "#GFileEnumerator allows you to operate on a set of #GFiles,\nreturning a #GFileInfo structure for each file enumerated (e.g.\ng_file_enumerate_children() will return a #GFileEnumerator for each\nof the children within a directory).\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FileEnumerator.html)." GFileEnumerator
    @doc "GFileIOStream provides io streams that both read and write to the same\nfile handle.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FileIOStream.html)." GFileIOStream
    @doc "#GFileIcon specifies an icon by pointing to an image file\nto be used as icon.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FileIcon.html)." GFileIcon
    @doc "Functionality for manipulating basic metadata for files. #GFileInfo\nimplements methods for getting information that all files should\ncontain, and allows for manipulation of extended attributes.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FileInfo.html)." GFileInfo
    @doc "GFileInputStream provides input streams that take their\ncontent from a file.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FileInputStream.html)." GFileInputStream
    @doc "Monitors a file or directory for changes.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FileMonitor.html)." GFileMonitor
    @doc "GFileOutputStream provides output streams that write their\ncontent to a file.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FileOutputStream.html)." GFileOutputStream
    @doc "Completes partial file and directory names given a partial string by\nlooking in the file system for clues. Can return a list of possible\ncompletion strings for widget implementations.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FilenameCompleter.html)." GFilenameCompleter
    @doc "Base class for input stream implementations that perform some\nkind of filtering operation on a base stream. Typical examples\nof filtering operations are character set conversion, compression\nand byte order flipping.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FilterInputStream.html)." GFilterInputStream
    @doc "Base class for output stream implementations that perform some\nkind of filtering operation on a base stream. Typical examples\nof filtering operations are character set conversion, compression\nand byte order flipping.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.FilterOutputStream.html)." GFilterOutputStream
    @doc "Provides an interface and default functions for loading and unloading\nmodules. This is used internally to make GIO extensible, but can also\nbe used by others to implement module loading.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.IOModule.html)." GIOModule
    @doc "GIOStream represents an object that has both read and write streams.\nGenerally the two streams act as separate input and output streams,\nbut they share some common resources and state. For instance, for\nseekable streams, both streams may use the same position.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.IOStream.html)." GIOStream
    @doc "#GInetAddress represents an IPv4 or IPv6 internet address. Use\ng_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to\nlook up the #GInetAddress for a hostname. Use\ng_resolver_lookup_by_address() or\ng_resolver_lookup_by_address_async() to look up the hostname for a\n#GInetAddress.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.InetAddress.html)." GInetAddress
    @doc "#GInetAddressMask represents a range of IPv4 or IPv6 addresses\ndescribed by a base address and a length indicating how many bits\nof the base address are relevant for matching purposes. These are\noften given in string form. Eg, \"10.0.0.0/8\", or \"fe80::/10\".\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.InetAddressMask.html)." GInetAddressMask
    @doc "An IPv4 or IPv6 socket address; that is, the combination of a\n#GInetAddress and a port number.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.InetSocketAddress.html)." GInetSocketAddress
    @doc "#GInputStream has functions to read from a stream (g_input_stream_read()),\nto close a stream (g_input_stream_close()) and to skip some content\n(g_input_stream_skip()).\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.InputStream.html)." GInputStream
    @doc "#GListStore is a simple implementation of #GListModel that stores all\nitems in memory.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ListStore.html)." GListStore
    @doc "#GMemoryInputStream is a class for using arbitrary\nmemory chunks as input for GIO streaming input operations.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.MemoryInputStream.html)." GMemoryInputStream
    @doc "#GMemoryOutputStream is a class for using arbitrary\nmemory chunks as output for GIO streaming output operations.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.MemoryOutputStream.html)." GMemoryOutputStream
    @doc "#GMenu is a simple implementation of #GMenuModel.\nYou populate a #GMenu by adding #GMenuItem instances to it.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Menu.html)." GMenu
    @doc "#GMenuAttributeIter is an opaque structure type.  You must access it\nusing the functions below.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.MenuAttributeIter.html)." GMenuAttributeIter
    @doc "#GMenuItem is an opaque structure type.  You must access it using the\nfunctions below.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.MenuItem.html)." GMenuItem
    @doc "#GMenuLinkIter is an opaque structure type.  You must access it using\nthe functions below.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.MenuLinkIter.html)." GMenuLinkIter
    @doc "#GMenuModel represents the contents of a menu -- an ordered list of\nmenu items. The items are associated with actions, which can be\nactivated through them. Items can be grouped in sections, and may\nhave submenus associated with them. Both items and sections usually\nhave some representation data, such as labels or icons. The type of\nthe associated action (ie whether it is stateful, and what kind of\nstate it has) can influence the representation of the item.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.MenuModel.html)." GMenuModel
    @doc "#GMountOperation provides a mechanism for interacting with the user.\nIt can be used for authenticating mountable operations, such as loop\nmounting files, hard drive partitions or server locations. It can\nalso be used to ask the user questions or show a list of applications\npreventing unmount or eject operations from completing.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.MountOperation.html)." GMountOperation
    @doc "A socket address of some unknown native type.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.NativeSocketAddress.html)." GNativeSocketAddress
    @doc "#GNetworkAddress provides an easy way to resolve a hostname and\nthen attempt to connect to that host, handling the possibility of\nmultiple IP addresses and multiple address families.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.NetworkAddress.html)." GNetworkAddress
    @doc "Like #GNetworkAddress does with hostnames, #GNetworkService\nprovides an easy way to resolve a SRV record, and then attempt to\nconnect to one of the hosts that implements that service, handling\nservice priority/weighting, multiple IP addresses, and multiple\naddress families.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.NetworkService.html)." GNetworkService
    @doc "#GNotification is a mechanism for creating a notification to be shown\nto the user -- typically as a pop-up notification presented by the\ndesktop environment shell.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Notification.html)." GNotification
    @doc "#GOutputStream has functions to write to a stream (g_output_stream_write()),\nto close a stream (g_output_stream_close()) and to flush pending writes\n(g_output_stream_flush()).\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.OutputStream.html)." GOutputStream
    @doc "A #GPermission represents the status of the caller's permission to\nperform a certain action.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Permission.html)." GPermission
    @doc "A #GPropertyAction is a way to get a #GAction with a state value\nreflecting and controlling the value of a #GObject property.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.PropertyAction.html)." GPropertyAction
    @doc "Support for proxied #GInetSocketAddress.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ProxyAddress.html)." GProxyAddress
    @doc "#GProxyAddressEnumerator is a wrapper around #GSocketAddressEnumerator which\ntakes the #GSocketAddress instances returned by the #GSocketAddressEnumerator\nand wraps them in #GProxyAddress instances, using the given\n#GProxyAddressEnumerator:proxy-resolver.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ProxyAddressEnumerator.html)." GProxyAddressEnumerator
    @doc "#GResolver provides cancellable synchronous and asynchronous DNS\nresolution, for hostnames (g_resolver_lookup_by_address(),\ng_resolver_lookup_by_name() and their async variants) and SRV\n(service) records (g_resolver_lookup_service()).\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Resolver.html)." GResolver
    @doc "The #GSettings class provides a convenient API for storing and retrieving\napplication settings.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Settings.html)." GSettings
    @doc "The #GSettingsBackend interface defines a generic interface for\nnon-strictly-typed data that is stored in a hierarchy. To implement\nan alternative storage backend for #GSettings, you need to implement\nthe #GSettingsBackend interface and then make it implement the\nextension point %G_SETTINGS_BACKEND_EXTENSION_POINT_NAME.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SettingsBackend.html)." GSettingsBackend
    @doc "A #GSimpleAction is the obvious simple implementation of the #GAction\ninterface. This is the easiest way to create an action for purposes of\nadding it to a #GSimpleActionGroup.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SimpleAction.html)." GSimpleAction
    @doc "#GSimpleActionGroup is a hash table filled with #GAction objects,\nimplementing the #GActionGroup and #GActionMap interfaces.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SimpleActionGroup.html)." GSimpleActionGroup
    @doc "As of GLib 2.46, #GSimpleAsyncResult is deprecated in favor of\n#GTask, which provides a simpler API.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SimpleAsyncResult.html)." GSimpleAsyncResult
    @doc "GSimpleIOStream creates a #GIOStream from an arbitrary #GInputStream and\n#GOutputStream. This allows any pair of input and output streams to be used\nwith #GIOStream methods.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SimpleIOStream.html)." GSimpleIOStream
    @doc "#GSimplePermission is a trivial implementation of #GPermission that\nrepresents a permission that is either always or never allowed.  The\nvalue is given at construction and doesn't change.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SimplePermission.html)." GSimplePermission
    @doc "#GSimpleProxyResolver is a simple #GProxyResolver implementation\nthat handles a single default proxy, multiple URI-scheme-specific\nproxies, and a list of hosts that proxies should not be used for.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SimpleProxyResolver.html)." GSimpleProxyResolver
    @doc "A #GSocket is a low-level networking primitive. It is a more or less\ndirect mapping of the BSD socket API in a portable GObject based API.\nIt supports both the UNIX socket implementations and winsock2 on Windows.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Socket.html)." GSocket
    @doc "#GSocketAddress is the equivalent of struct sockaddr in the BSD\nsockets API. This is an abstract class; use #GInetSocketAddress\nfor internet sockets, or #GUnixSocketAddress for UNIX domain sockets.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SocketAddress.html)." GSocketAddress
    @doc "#GSocketAddressEnumerator is an enumerator type for #GSocketAddress\ninstances. It is returned by enumeration functions such as\ng_socket_connectable_enumerate(), which returns a #GSocketAddressEnumerator\nto list each #GSocketAddress which could be used to connect to that\n#GSocketConnectable.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SocketAddressEnumerator.html)." GSocketAddressEnumerator
    @doc "#GSocketClient is a lightweight high-level utility class for connecting to\na network host using a connection oriented socket type.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SocketClient.html)." GSocketClient
    @doc "#GSocketConnection is a #GIOStream for a connected socket. They\ncan be created either by #GSocketClient when connecting to a host,\nor by #GSocketListener when accepting a new client.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SocketConnection.html)." GSocketConnection
    @doc "A #GSocketControlMessage is a special-purpose utility message that\ncan be sent to or received from a #GSocket. These types of\nmessages are often called \"ancillary data\".\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SocketControlMessage.html)." GSocketControlMessage
    @doc "A #GSocketListener is an object that keeps track of a set\nof server sockets and helps you accept sockets from any of the\nsocket, either sync or async.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SocketListener.html)." GSocketListener
    @doc "A #GSocketService is an object that represents a service that\nis provided to the network or over local sockets.  When a new\nconnection is made to the service the #GSocketService::incoming\nsignal is emitted.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SocketService.html)." GSocketService
    @doc "#GSubprocess allows the creation of and interaction with child\nprocesses.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Subprocess.html)." GSubprocess
    @doc "This class contains a set of options for launching child processes,\nsuch as where its standard input and output will be directed, the\nargument list, the environment, and more.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.SubprocessLauncher.html)." GSubprocessLauncher
    @doc "A #GTask represents and manages a cancellable \"task\".\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Task.html)." GTask
    @doc "This is the subclass of #GSocketConnection that is created\nfor TCP/IP sockets.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.TcpConnection.html)." GTcpConnection
    @doc "A #GTcpWrapperConnection can be used to wrap a #GIOStream that is\nbased on a #GSocket, but which is not actually a\n#GSocketConnection. This is used by #GSocketClient so that it can\nalways return a #GSocketConnection, even when the connection it has\nactually created is not directly a #GSocketConnection.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.TcpWrapperConnection.html)." GTcpWrapperConnection
    @doc "A helper class for testing code which uses D-Bus without touching the user's\nsession bus.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.TestDBus.html)." GTestDBus
    @doc "#GThemedIcon is an implementation of #GIcon that supports icon themes.\n#GThemedIcon contains a list of all of the icons present in an icon\ntheme, so that icons can be looked up quickly. #GThemedIcon does\nnot provide actual pixmaps for icons, just the icon names.\nIdeally something like gtk_icon_theme_choose_icon() should be used to\nresolve the list of names so that fallback icons work nicely with\nthemes that inherit other themes.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ThemedIcon.html)." GThemedIcon
    @doc "A #GThreadedSocketService is a simple subclass of #GSocketService\nthat handles incoming connections by creating a worker thread and\ndispatching the connection to it by emitting the\n#GThreadedSocketService::run signal in the new thread.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ThreadedSocketService.html)." GThreadedSocketService
    @doc "A certificate used for TLS authentication and encryption.\nThis can represent either a certificate only (eg, the certificate\nreceived by a client from a server), or the combination of\na certificate and a private key (which is needed when acting as a\n#GTlsServerConnection).\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.TlsCertificate.html)." GTlsCertificate
    @doc "#GTlsConnection is the base TLS connection class type, which wraps\na #GIOStream and provides TLS encryption on top of it. Its\nsubclasses, #GTlsClientConnection and #GTlsServerConnection,\nimplement client-side and server-side TLS, respectively.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.TlsConnection.html)." GTlsConnection
    @doc "#GTlsDatabase is used to look up certificates and other information\nfrom a certificate or key store. It is an abstract base class which\nTLS library specific subtypes override.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.TlsDatabase.html)." GTlsDatabase
    @doc "#GTlsInteraction provides a mechanism for the TLS connection and database\ncode to interact with the user. It can be used to ask the user for passwords.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.TlsInteraction.html)." GTlsInteraction
    @doc "Holds a password used in TLS.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.TlsPassword.html)." GTlsPassword
    @doc "This is the subclass of #GSocketConnection that is created\nfor UNIX domain sockets.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.UnixConnection.html)." GUnixConnection
    @doc "This #GSocketControlMessage contains a #GCredentials instance.  It\nmay be sent using g_socket_send_message() and received using\ng_socket_receive_message() over UNIX sockets (ie: sockets in the\n%G_SOCKET_FAMILY_UNIX family).\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.UnixCredentialsMessage.html)." GUnixCredentialsMessage
    @doc "Entry point for using GIO functionality.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.Vfs.html)." GVfs
    @doc "#GVolumeMonitor is for listing the user interesting devices and volumes\non the computer. In other words, what a file selector or file manager\nwould show in a sidebar.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.VolumeMonitor.html)." GVolumeMonitor
    @doc "#GZlibCompressor is an implementation of #GConverter that\ncompresses data using zlib.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ZlibCompressor.html)." GZlibCompressor
    @doc "#GZlibDecompressor is an implementation of #GConverter that\ndecompresses data compressed with zlib.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gio/class.ZlibDecompressor.html)." GZlibDecompressor
    struct GAction <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GAction(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GActionGroup <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GActionGroup(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GActionMap <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GActionMap(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GAppInfo <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GAppInfo(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GAsyncInitable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GAsyncInitable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GAsyncResult <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GAsyncResult(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GConverter <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GConverter(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDBusInterface <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDBusInterface(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDBusObject <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDBusObject(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDBusObjectManager <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDBusObjectManager(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDatagramBased <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDatagramBased(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDebugController <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDebugController(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDrive <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDrive(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDtlsClientConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDtlsClientConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDtlsConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDtlsConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GDtlsServerConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GDtlsServerConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GFile <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GFile(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GFileDescriptorBased <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GFileDescriptorBased(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GIcon <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GIcon(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GInitable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GInitable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GListModel <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GListModel(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GLoadableIcon <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GLoadableIcon(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GMemoryMonitor <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GMemoryMonitor(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GMount <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GMount(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GNetworkMonitor <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GNetworkMonitor(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GPollableInputStream <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GPollableInputStream(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GPollableOutputStream <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GPollableOutputStream(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GPowerProfileMonitor <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GPowerProfileMonitor(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GProxy <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GProxy(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GProxyResolver <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GProxyResolver(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GRemoteActionGroup <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GRemoteActionGroup(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GSeekable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GSeekable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GSocketConnectable <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GSocketConnectable(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GTlsBackend <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GTlsBackend(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GTlsClientConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GTlsClientConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GTlsFileDatabase <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GTlsFileDatabase(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GTlsServerConnection <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GTlsServerConnection(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    struct GVolume <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GVolume(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    export GDBusErrorEntry, _GDBusErrorEntry, GFileAttributeInfo, _GFileAttributeInfo, GFileAttributeInfoList, _GFileAttributeInfoList, GFileAttributeMatcher, GInputVector, _GInputVector, GOutputVector, _GOutputVector, GResource, GSettingsSchema, GSettingsSchemaKey, GSettingsSchemaSource, GSrvTarget, GAppInfoMonitor, GAppLaunchContext, GApplication, GApplicationCommandLine, GBufferedInputStream, GBufferedOutputStream, GBytesIcon, GCancellable, GCharsetConverter, GConverterInputStream, GConverterOutputStream, GCredentials, GDBusActionGroup, GDBusAuthObserver, GDBusConnection, GDBusInterfaceSkeleton, GDBusMenuModel, GDBusMessage, GDBusMethodInvocation, GDBusObjectManagerClient, GDBusObjectManagerServer, GDBusObjectProxy, GDBusObjectSkeleton, GDBusProxy, GDBusServer, GDataInputStream, GDataOutputStream, GDesktopAppInfo, GEmblem, GEmblemedIcon, GFileEnumerator, GFileIOStream, GFileIcon, GFileInfo, GFileInputStream, GFileMonitor, GFileOutputStream, GFilenameCompleter, GFilterInputStream, GFilterOutputStream, GIOModule, GIOStream, GInetAddress, GInetAddressMask, GInetSocketAddress, GInputStream, GListStore, GMemoryInputStream, GMemoryOutputStream, GMenu, GMenuAttributeIter, GMenuItem, GMenuLinkIter, GMenuModel, GMountOperation, GNativeSocketAddress, GNativeVolumeMonitor, GNetworkAddress, GNetworkService, GNotification, GOutputStream, GPermission, GPropertyAction, GProxyAddress, GProxyAddressEnumerator, GResolver, GSettings, GSettingsBackend, GSimpleAction, GSimpleActionGroup, GSimpleAsyncResult, GSimpleIOStream, GSimplePermission, GSimpleProxyResolver, GSocket, GSocketAddress, GSocketAddressEnumerator, GSocketClient, GSocketConnection, GSocketControlMessage, GSocketListener, GSocketService, GSubprocess, GSubprocessLauncher, GTask, GTcpConnection, GTcpWrapperConnection, GTestDBus, GThemedIcon, GThreadedSocketService, GTlsCertificate, GTlsConnection, GTlsDatabase, GTlsInteraction, GTlsPassword, GUnixConnection, GUnixCredentialsMessage, GVfs, GVolumeMonitor, GZlibCompressor, GZlibDecompressor, GAction, GActionGroup, GActionMap, GAppInfo, GAsyncInitable, GAsyncResult, GConverter, GDBusInterface, GDBusObject, GDBusObjectManager, GDatagramBased, GDebugController, GDrive, GDtlsClientConnection, GDtlsConnection, GDtlsServerConnection, GFile, GFileDescriptorBased, GIcon, GInitable, GListModel, GLoadableIcon, GMemoryMonitor, GMount, GNetworkMonitor, GPollableInputStream, GPollableOutputStream, GPowerProfileMonitor, GProxy, GProxyResolver, GRemoteActionGroup, GSeekable, GSocketConnectable, GTlsBackend, GTlsClientConnection, GTlsFileDatabase, GTlsServerConnection, GVolume
end))
end
