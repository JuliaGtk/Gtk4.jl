begin
    struct _GDBusErrorEntry
        error_code::Int32
        dbus_error_name::Cstring
    end
    mutable struct GDBusErrorEntry
        handle::Ptr{_GDBusErrorEntry}
    end
    unsafe_convert(::Type{Ptr{_GDBusErrorEntry}}, box::GDBusErrorEntry) = convert(Ptr{_GDBusErrorEntry}, box.handle)
    convert(::Type{GDBusErrorEntry}, p::Ptr{_GDBusErrorEntry}, owns = false) = GDBusErrorEntry(p, owns)
    const GDBusErrorEntryLike = Union{Ref{_GDBusErrorEntry}, GDBusErrorEntry}
    convert(::Type{GDBusErrorEntryLike}, p, owns) = convert(GDBusErrorEntry, p, owns)
    struct _GFileAttributeInfo
        name::Cstring
        type::UInt32
        flags::UInt32
    end
    mutable struct GFileAttributeInfo
        handle::Ptr{_GFileAttributeInfo}
    end
    unsafe_convert(::Type{Ptr{_GFileAttributeInfo}}, box::GFileAttributeInfo) = convert(Ptr{_GFileAttributeInfo}, box.handle)
    convert(::Type{GFileAttributeInfo}, p::Ptr{_GFileAttributeInfo}, owns = false) = GFileAttributeInfo(p, owns)
    const GFileAttributeInfoLike = Union{Ref{_GFileAttributeInfo}, GFileAttributeInfo}
    convert(::Type{GFileAttributeInfoLike}, p, owns) = convert(GFileAttributeInfo, p, owns)
    struct _GFileAttributeInfoList
        infos::Ptr{_GFileAttributeInfo}
        n_infos::Int32
    end
    mutable struct GFileAttributeInfoList <: GBoxed
        handle::Ptr{_GFileAttributeInfoList}
        (GLib.g_type(::Type{T}) where T <: GFileAttributeInfoList) = ccall(("g_file_attribute_info_list_get_type", libgio), GType, ())
        function GFileAttributeInfoList(ref::Ptr{T}, own::Bool = false) where T <: Union{GBoxed, _GFileAttributeInfoList}
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GFileAttributeInfoList)
    end
    unsafe_convert(::Type{Ptr{_GFileAttributeInfoList}}, box::GFileAttributeInfoList) = convert(Ptr{_GFileAttributeInfoList}, box.handle)
    convert(::Type{GFileAttributeInfoList}, p::Ptr{_GFileAttributeInfoList}, owns = false) = GFileAttributeInfoList(p, owns)
    const GFileAttributeInfoListLike = Union{Ref{_GFileAttributeInfoList}, GFileAttributeInfoList}
    convert(::Type{GFileAttributeInfoListLike}, p, owns) = convert(GFileAttributeInfoList, p, owns)
    mutable struct GFileAttributeMatcher <: GBoxed
        handle::Ptr{GFileAttributeMatcher}
        (GLib.g_type(::Type{T}) where T <: GFileAttributeMatcher) = ccall(("g_file_attribute_matcher_get_type", libgio), GType, ())
        function GFileAttributeMatcher(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GFileAttributeMatcher)
    end
    const GFileAttributeMatcherLike = GFileAttributeMatcher
    struct _GInputVector
        buffer::Ptr{Nothing}
        size::UInt64
    end
    mutable struct GInputVector
        handle::Ptr{_GInputVector}
    end
    unsafe_convert(::Type{Ptr{_GInputVector}}, box::GInputVector) = convert(Ptr{_GInputVector}, box.handle)
    convert(::Type{GInputVector}, p::Ptr{_GInputVector}, owns = false) = GInputVector(p, owns)
    const GInputVectorLike = Union{Ref{_GInputVector}, GInputVector}
    convert(::Type{GInputVectorLike}, p, owns) = convert(GInputVector, p, owns)
    struct _GOutputVector
        buffer::Ptr{Nothing}
        size::UInt64
    end
    mutable struct GOutputVector
        handle::Ptr{_GOutputVector}
    end
    unsafe_convert(::Type{Ptr{_GOutputVector}}, box::GOutputVector) = convert(Ptr{_GOutputVector}, box.handle)
    convert(::Type{GOutputVector}, p::Ptr{_GOutputVector}, owns = false) = GOutputVector(p, owns)
    const GOutputVectorLike = Union{Ref{_GOutputVector}, GOutputVector}
    convert(::Type{GOutputVectorLike}, p, owns) = convert(GOutputVector, p, owns)
    mutable struct GResource <: GBoxed
        handle::Ptr{GResource}
        (GLib.g_type(::Type{T}) where T <: GResource) = ccall(("g_resource_get_type", libgio), GType, ())
        function GResource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GResource)
    end
    const GResourceLike = GResource
    mutable struct GSettingsSchema <: GBoxed
        handle::Ptr{GSettingsSchema}
        (GLib.g_type(::Type{T}) where T <: GSettingsSchema) = ccall(("g_settings_schema_get_type", libgio), GType, ())
        function GSettingsSchema(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GSettingsSchema)
    end
    const GSettingsSchemaLike = GSettingsSchema
    mutable struct GSettingsSchemaKey <: GBoxed
        handle::Ptr{GSettingsSchemaKey}
        (GLib.g_type(::Type{T}) where T <: GSettingsSchemaKey) = ccall(("g_settings_schema_key_get_type", libgio), GType, ())
        function GSettingsSchemaKey(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GSettingsSchemaKey)
    end
    const GSettingsSchemaKeyLike = GSettingsSchemaKey
    mutable struct GSettingsSchemaSource <: GBoxed
        handle::Ptr{GSettingsSchemaSource}
        (GLib.g_type(::Type{T}) where T <: GSettingsSchemaSource) = ccall(("g_settings_schema_source_get_type", libgio), GType, ())
        function GSettingsSchemaSource(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GSettingsSchemaSource)
    end
    const GSettingsSchemaSourceLike = GSettingsSchemaSource
    mutable struct GSrvTarget <: GBoxed
        handle::Ptr{GSrvTarget}
        (GLib.g_type(::Type{T}) where T <: GSrvTarget) = ccall(("g_srv_target_get_type", libgio), GType, ())
        function GSrvTarget(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
            x = new(ref)
            if own
                finalizer(x) do x
                    GLib.delboxed
                    x
                end
            end
            x
        end
        push!(gboxed_types, GSrvTarget)
    end
    const GSrvTargetLike = GSrvTarget
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.DBusErrorEntry.html)." GDBusErrorEntry
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.FileAttributeInfo.html)." GFileAttributeInfo
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.FileAttributeInfoList.html)." GFileAttributeInfoList
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.FileAttributeMatcher.html)." GFileAttributeMatcher
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.InputVector.html)." GInputVector
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.OutputVector.html)." GOutputVector
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.Resource.html)." GResource
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.SettingsSchema.html)." GSettingsSchema
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.SettingsSchemaKey.html)." GSettingsSchemaKey
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.SettingsSchemaSource.html)." GSettingsSchemaSource
    @doc "See the [GTK docs](https://docs.gtk.org/gio/struct.SrvTarget.html)." GSrvTarget
    GLib.@Giface GAction libgio g_action_get_type
    GLib.@Giface GActionGroup libgio g_action_group_get_type
    GLib.@Giface GActionMap libgio g_action_map_get_type
    GLib.@Giface GAppInfo libgio g_app_info_get_type
    GLib.@Giface GAsyncInitable libgio g_async_initable_get_type
    GLib.@Giface GAsyncResult libgio g_async_result_get_type
    GLib.@Giface GConverter libgio g_converter_get_type
    GLib.@Giface GDBusInterface libgio g_dbus_interface_get_type
    GLib.@Giface GDBusObject libgio g_dbus_object_get_type
    GLib.@Giface GDBusObjectManager libgio g_dbus_object_manager_get_type
    GLib.@Giface GDatagramBased libgio g_datagram_based_get_type
    GLib.@Giface GDebugController libgio g_debug_controller_get_type
    GLib.@Giface GDrive libgio g_drive_get_type
    GLib.@Giface GDtlsClientConnection libgio g_dtls_client_connection_get_type
    GLib.@Giface GDtlsConnection libgio g_dtls_connection_get_type
    GLib.@Giface GDtlsServerConnection libgio g_dtls_server_connection_get_type
    GLib.@Giface GFile libgio g_file_get_type
    GLib.@Giface GFileDescriptorBased libgio g_file_descriptor_based_get_type
    GLib.@Giface GIcon libgio g_icon_get_type
    GLib.@Giface GInitable libgio g_initable_get_type
    GLib.@Giface GListModel libgio g_list_model_get_type
    GLib.@Giface GLoadableIcon libgio g_loadable_icon_get_type
    GLib.@Giface GMemoryMonitor libgio g_memory_monitor_get_type
    GLib.@Giface GMount libgio g_mount_get_type
    GLib.@Giface GNetworkMonitor libgio g_network_monitor_get_type
    GLib.@Giface GPollableInputStream libgio g_pollable_input_stream_get_type
    GLib.@Giface GPollableOutputStream libgio g_pollable_output_stream_get_type
    GLib.@Giface GPowerProfileMonitor libgio g_power_profile_monitor_get_type
    GLib.@Giface GProxy libgio g_proxy_get_type
    GLib.@Giface GProxyResolver libgio g_proxy_resolver_get_type
    GLib.@Giface GRemoteActionGroup libgio g_remote_action_group_get_type
    GLib.@Giface GSeekable libgio g_seekable_get_type
    GLib.@Giface GSocketConnectable libgio g_socket_connectable_get_type
    GLib.@Giface GTlsBackend libgio g_tls_backend_get_type
    GLib.@Giface GTlsClientConnection libgio g_tls_client_connection_get_type
    GLib.@Giface GTlsFileDatabase libgio g_tls_file_database_get_type
    GLib.@Giface GTlsServerConnection libgio g_tls_server_connection_get_type
    GLib.@Giface GVolume libgio g_volume_get_type
    abstract type GAppInfoMonitor <: GObject end
    mutable struct GAppInfoMonitorLeaf <: GAppInfoMonitor
        handle::Ptr{GObject}
        function GAppInfoMonitorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GAppInfoMonitorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GAppInfoMonitor] = GAppInfoMonitorLeaf
    (GLib.g_type(::Type{T}) where T <: GAppInfoMonitor) = ccall(("g_app_info_monitor_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GAppInfoMonitor})
        vcat([:changed], signalnames(supertype(GAppInfoMonitor)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :changed => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GAppInfoMonitor
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GAppInfoMonitor
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GAppLaunchContext <: GObject end
    mutable struct GAppLaunchContextLeaf <: GAppLaunchContext
        handle::Ptr{GObject}
        function GAppLaunchContextLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GAppLaunchContextLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GAppLaunchContext] = GAppLaunchContextLeaf
    (GLib.g_type(::Type{T}) where T <: GAppLaunchContext) = ccall(("g_app_launch_context_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GAppLaunchContext})
        vcat([:launch_failed, :launch_started, :launched], signalnames(supertype(GAppLaunchContext)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :launch_failed => (:Nothing, [:Cstring]), :launched => (:Nothing, Any[:(Ptr{GObject}), :GVariant]), :launch_started => (:Nothing, Any[:(Ptr{GObject}), :GVariant]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GAppLaunchContext
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GAppLaunchContext
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GApplication <: GObject end
    mutable struct GApplicationLeaf <: GApplication
        handle::Ptr{GObject}
        function GApplicationLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GApplicationLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GApplication] = GApplicationLeaf
    (GLib.g_type(::Type{T}) where T <: GApplication) = ccall(("g_application_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GApplication})
        vcat([:activate, :command_line, :handle_local_options, :name_lost, :open, :shutdown, :startup, :action_added, :action_enabled_changed, :action_removed, :action_state_changed], signalnames(supertype(GApplication)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :startup => (:Nothing, Any[]), :shutdown => (:Nothing, Any[]), :command_line => (:Int32, Expr[:(Ptr{GObject})]), :name_lost => (:Cint, Any[]), :open => (:Nothing, Any[:(Ptr{Ptr{GObject}}), :Int32, :Cstring]), :activate => (:Nothing, Any[]), :handle_local_options => (:Int32, [:GVariantDict]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GApplication
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GApplication
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GApplicationCommandLine <: GObject end
    mutable struct GApplicationCommandLineLeaf <: GApplicationCommandLine
        handle::Ptr{GObject}
        function GApplicationCommandLineLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GApplicationCommandLineLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GApplicationCommandLine] = GApplicationCommandLineLeaf
    (GLib.g_type(::Type{T}) where T <: GApplicationCommandLine) = ccall(("g_application_command_line_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GApplicationCommandLine})
        signalnames(supertype(GApplicationCommandLine))
    end
    abstract type GInputStream <: GObject end
    mutable struct GInputStreamLeaf <: GInputStream
        handle::Ptr{GObject}
        function GInputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GInputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GInputStream] = GInputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GInputStream) = ccall(("g_input_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GInputStream})
        signalnames(supertype(GInputStream))
    end
    abstract type GFilterInputStream <: GInputStream end
    mutable struct GFilterInputStreamLeaf <: GFilterInputStream
        handle::Ptr{GObject}
        function GFilterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFilterInputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFilterInputStream] = GFilterInputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GFilterInputStream) = ccall(("g_filter_input_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFilterInputStream})
        signalnames(supertype(GFilterInputStream))
    end
    abstract type GBufferedInputStream <: GFilterInputStream end
    mutable struct GBufferedInputStreamLeaf <: GBufferedInputStream
        handle::Ptr{GObject}
        function GBufferedInputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GBufferedInputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GBufferedInputStream] = GBufferedInputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GBufferedInputStream) = ccall(("g_buffered_input_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GBufferedInputStream})
        signalnames(supertype(GBufferedInputStream))
    end
    abstract type GOutputStream <: GObject end
    mutable struct GOutputStreamLeaf <: GOutputStream
        handle::Ptr{GObject}
        function GOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GOutputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GOutputStream] = GOutputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GOutputStream) = ccall(("g_output_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GOutputStream})
        signalnames(supertype(GOutputStream))
    end
    abstract type GFilterOutputStream <: GOutputStream end
    mutable struct GFilterOutputStreamLeaf <: GFilterOutputStream
        handle::Ptr{GObject}
        function GFilterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFilterOutputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFilterOutputStream] = GFilterOutputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GFilterOutputStream) = ccall(("g_filter_output_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFilterOutputStream})
        signalnames(supertype(GFilterOutputStream))
    end
    abstract type GBufferedOutputStream <: GFilterOutputStream end
    mutable struct GBufferedOutputStreamLeaf <: GBufferedOutputStream
        handle::Ptr{GObject}
        function GBufferedOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GBufferedOutputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GBufferedOutputStream] = GBufferedOutputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GBufferedOutputStream) = ccall(("g_buffered_output_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GBufferedOutputStream})
        signalnames(supertype(GBufferedOutputStream))
    end
    abstract type GBytesIcon <: GObject end
    mutable struct GBytesIconLeaf <: GBytesIcon
        handle::Ptr{GObject}
        function GBytesIconLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GBytesIconLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GBytesIcon] = GBytesIconLeaf
    (GLib.g_type(::Type{T}) where T <: GBytesIcon) = ccall(("g_bytes_icon_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GBytesIcon})
        signalnames(supertype(GBytesIcon))
    end
    abstract type GCancellable <: GObject end
    mutable struct GCancellableLeaf <: GCancellable
        handle::Ptr{GObject}
        function GCancellableLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GCancellableLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GCancellable] = GCancellableLeaf
    (GLib.g_type(::Type{T}) where T <: GCancellable) = ccall(("g_cancellable_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GCancellable})
        vcat([:cancelled], signalnames(supertype(GCancellable)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :cancelled => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GCancellable
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GCancellable
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GCharsetConverter <: GObject end
    mutable struct GCharsetConverterLeaf <: GCharsetConverter
        handle::Ptr{GObject}
        function GCharsetConverterLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GCharsetConverterLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GCharsetConverter] = GCharsetConverterLeaf
    (GLib.g_type(::Type{T}) where T <: GCharsetConverter) = ccall(("g_charset_converter_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GCharsetConverter})
        signalnames(supertype(GCharsetConverter))
    end
    abstract type GConverterInputStream <: GFilterInputStream end
    mutable struct GConverterInputStreamLeaf <: GConverterInputStream
        handle::Ptr{GObject}
        function GConverterInputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GConverterInputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GConverterInputStream] = GConverterInputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GConverterInputStream) = ccall(("g_converter_input_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GConverterInputStream})
        signalnames(supertype(GConverterInputStream))
    end
    abstract type GConverterOutputStream <: GFilterOutputStream end
    mutable struct GConverterOutputStreamLeaf <: GConverterOutputStream
        handle::Ptr{GObject}
        function GConverterOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GConverterOutputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GConverterOutputStream] = GConverterOutputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GConverterOutputStream) = ccall(("g_converter_output_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GConverterOutputStream})
        signalnames(supertype(GConverterOutputStream))
    end
    abstract type GCredentials <: GObject end
    mutable struct GCredentialsLeaf <: GCredentials
        handle::Ptr{GObject}
        function GCredentialsLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GCredentialsLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GCredentials] = GCredentialsLeaf
    (GLib.g_type(::Type{T}) where T <: GCredentials) = ccall(("g_credentials_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GCredentials})
        signalnames(supertype(GCredentials))
    end
    abstract type GDBusActionGroup <: GObject end
    mutable struct GDBusActionGroupLeaf <: GDBusActionGroup
        handle::Ptr{GObject}
        function GDBusActionGroupLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusActionGroupLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusActionGroup] = GDBusActionGroupLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusActionGroup) = ccall(("g_dbus_action_group_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusActionGroup})
        vcat([:action_added, :action_enabled_changed, :action_removed, :action_state_changed], signalnames(supertype(GDBusActionGroup)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusActionGroup
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusActionGroup
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GDBusAuthObserver <: GObject end
    mutable struct GDBusAuthObserverLeaf <: GDBusAuthObserver
        handle::Ptr{GObject}
        function GDBusAuthObserverLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusAuthObserverLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusAuthObserver] = GDBusAuthObserverLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusAuthObserver) = ccall(("g_dbus_auth_observer_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusAuthObserver})
        vcat([:allow_mechanism, :authorize_authenticated_peer], signalnames(supertype(GDBusAuthObserver)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :authorize_authenticated_peer => (:Cint, Expr[:(Ptr{GObject}), :(Ptr{GObject})]), :allow_mechanism => (:Cint, [:Cstring]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusAuthObserver
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusAuthObserver
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GDBusConnection <: GObject end
    mutable struct GDBusConnectionLeaf <: GDBusConnection
        handle::Ptr{GObject}
        function GDBusConnectionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusConnectionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusConnection] = GDBusConnectionLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusConnection) = ccall(("g_dbus_connection_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusConnection})
        vcat([:closed], signalnames(supertype(GDBusConnection)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :closed => (:Nothing, Any[:Cint, :(Ptr{GError})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusConnection
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusConnection
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GMenuModel <: GObject end
    mutable struct GMenuModelLeaf <: GMenuModel
        handle::Ptr{GObject}
        function GMenuModelLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GMenuModelLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GMenuModel] = GMenuModelLeaf
    (GLib.g_type(::Type{T}) where T <: GMenuModel) = ccall(("g_menu_model_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GMenuModel})
        vcat([:items_changed], signalnames(supertype(GMenuModel)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :items_changed => (:Nothing, [:Int32, :Int32, :Int32]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GMenuModel
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GMenuModel
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GDBusMenuModel <: GMenuModel end
    mutable struct GDBusMenuModelLeaf <: GDBusMenuModel
        handle::Ptr{GObject}
        function GDBusMenuModelLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusMenuModelLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusMenuModel] = GDBusMenuModelLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusMenuModel) = ccall(("g_dbus_menu_model_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusMenuModel})
        signalnames(supertype(GDBusMenuModel))
    end
    abstract type GDBusMessage <: GObject end
    mutable struct GDBusMessageLeaf <: GDBusMessage
        handle::Ptr{GObject}
        function GDBusMessageLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusMessageLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusMessage] = GDBusMessageLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusMessage) = ccall(("g_dbus_message_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusMessage})
        signalnames(supertype(GDBusMessage))
    end
    abstract type GDBusMethodInvocation <: GObject end
    mutable struct GDBusMethodInvocationLeaf <: GDBusMethodInvocation
        handle::Ptr{GObject}
        function GDBusMethodInvocationLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusMethodInvocationLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusMethodInvocation] = GDBusMethodInvocationLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusMethodInvocation) = ccall(("g_dbus_method_invocation_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusMethodInvocation})
        signalnames(supertype(GDBusMethodInvocation))
    end
    abstract type GDBusObjectManagerClient <: GObject end
    mutable struct GDBusObjectManagerClientLeaf <: GDBusObjectManagerClient
        handle::Ptr{GObject}
        function GDBusObjectManagerClientLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusObjectManagerClientLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusObjectManagerClient] = GDBusObjectManagerClientLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusObjectManagerClient) = ccall(("g_dbus_object_manager_client_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusObjectManagerClient})
        vcat([:interface_proxy_properties_changed, :interface_proxy_signal, :interface_added, :interface_removed, :object_added, :object_removed], signalnames(supertype(GDBusObjectManagerClient)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :interface_proxy_signal => (:Nothing, Any[:(Ptr{GObject}), :(Ptr{GObject}), :Cstring, :Cstring, :GVariant]), :interface_proxy_properties_changed => (:Nothing, Any[:(Ptr{GObject}), :(Ptr{GObject}), :GVariant, :(Ptr{Cstring})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusObjectManagerClient
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusObjectManagerClient
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GDBusObjectProxy <: GObject end
    mutable struct GDBusObjectProxyLeaf <: GDBusObjectProxy
        handle::Ptr{GObject}
        function GDBusObjectProxyLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusObjectProxyLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusObjectProxy] = GDBusObjectProxyLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusObjectProxy) = ccall(("g_dbus_object_proxy_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusObjectProxy})
        vcat([:interface_added, :interface_removed], signalnames(supertype(GDBusObjectProxy)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusObjectProxy
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusObjectProxy
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GDBusProxy <: GObject end
    mutable struct GDBusProxyLeaf <: GDBusProxy
        handle::Ptr{GObject}
        function GDBusProxyLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusProxyLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusProxy] = GDBusProxyLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusProxy) = ccall(("g_dbus_proxy_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusProxy})
        vcat([:g_properties_changed, :g_signal], signalnames(supertype(GDBusProxy)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :g_signal => (:Nothing, [:Cstring, :Cstring, :GVariant]), :g_properties_changed => (:Nothing, Any[:GVariant, :(Ptr{Cstring})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusProxy
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusProxy
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GDBusServer <: GObject end
    mutable struct GDBusServerLeaf <: GDBusServer
        handle::Ptr{GObject}
        function GDBusServerLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDBusServerLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDBusServer] = GDBusServerLeaf
    (GLib.g_type(::Type{T}) where T <: GDBusServer) = ccall(("g_dbus_server_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDBusServer})
        vcat([:new_connection], signalnames(supertype(GDBusServer)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :new_connection => (:Cint, Expr[:(Ptr{GObject})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GDBusServer
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GDBusServer
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GDataInputStream <: GBufferedInputStream end
    mutable struct GDataInputStreamLeaf <: GDataInputStream
        handle::Ptr{GObject}
        function GDataInputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDataInputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDataInputStream] = GDataInputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GDataInputStream) = ccall(("g_data_input_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDataInputStream})
        signalnames(supertype(GDataInputStream))
    end
    abstract type GDataOutputStream <: GFilterOutputStream end
    mutable struct GDataOutputStreamLeaf <: GDataOutputStream
        handle::Ptr{GObject}
        function GDataOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDataOutputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDataOutputStream] = GDataOutputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GDataOutputStream) = ccall(("g_data_output_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDataOutputStream})
        signalnames(supertype(GDataOutputStream))
    end
    abstract type GDesktopAppInfo <: GObject end
    mutable struct GDesktopAppInfoLeaf <: GDesktopAppInfo
        handle::Ptr{GObject}
        function GDesktopAppInfoLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GDesktopAppInfoLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GDesktopAppInfo] = GDesktopAppInfoLeaf
    (GLib.g_type(::Type{T}) where T <: GDesktopAppInfo) = ccall(("g_desktop_app_info_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GDesktopAppInfo})
        signalnames(supertype(GDesktopAppInfo))
    end
    abstract type GEmblem <: GObject end
    mutable struct GEmblemLeaf <: GEmblem
        handle::Ptr{GObject}
        function GEmblemLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GEmblemLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GEmblem] = GEmblemLeaf
    (GLib.g_type(::Type{T}) where T <: GEmblem) = ccall(("g_emblem_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GEmblem})
        signalnames(supertype(GEmblem))
    end
    abstract type GEmblemedIcon <: GObject end
    mutable struct GEmblemedIconLeaf <: GEmblemedIcon
        handle::Ptr{GObject}
        function GEmblemedIconLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GEmblemedIconLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GEmblemedIcon] = GEmblemedIconLeaf
    (GLib.g_type(::Type{T}) where T <: GEmblemedIcon) = ccall(("g_emblemed_icon_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GEmblemedIcon})
        signalnames(supertype(GEmblemedIcon))
    end
    abstract type GFileEnumerator <: GObject end
    mutable struct GFileEnumeratorLeaf <: GFileEnumerator
        handle::Ptr{GObject}
        function GFileEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFileEnumeratorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFileEnumerator] = GFileEnumeratorLeaf
    (GLib.g_type(::Type{T}) where T <: GFileEnumerator) = ccall(("g_file_enumerator_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFileEnumerator})
        signalnames(supertype(GFileEnumerator))
    end
    abstract type GIOStream <: GObject end
    mutable struct GIOStreamLeaf <: GIOStream
        handle::Ptr{GObject}
        function GIOStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GIOStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GIOStream] = GIOStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GIOStream) = ccall(("g_io_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GIOStream})
        signalnames(supertype(GIOStream))
    end
    abstract type GFileIOStream <: GIOStream end
    mutable struct GFileIOStreamLeaf <: GFileIOStream
        handle::Ptr{GObject}
        function GFileIOStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFileIOStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFileIOStream] = GFileIOStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GFileIOStream) = ccall(("g_file_io_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFileIOStream})
        signalnames(supertype(GFileIOStream))
    end
    abstract type GFileIcon <: GObject end
    mutable struct GFileIconLeaf <: GFileIcon
        handle::Ptr{GObject}
        function GFileIconLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFileIconLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFileIcon] = GFileIconLeaf
    (GLib.g_type(::Type{T}) where T <: GFileIcon) = ccall(("g_file_icon_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFileIcon})
        signalnames(supertype(GFileIcon))
    end
    abstract type GFileInfo <: GObject end
    mutable struct GFileInfoLeaf <: GFileInfo
        handle::Ptr{GObject}
        function GFileInfoLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFileInfoLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFileInfo] = GFileInfoLeaf
    (GLib.g_type(::Type{T}) where T <: GFileInfo) = ccall(("g_file_info_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFileInfo})
        signalnames(supertype(GFileInfo))
    end
    abstract type GFileInputStream <: GInputStream end
    mutable struct GFileInputStreamLeaf <: GFileInputStream
        handle::Ptr{GObject}
        function GFileInputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFileInputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFileInputStream] = GFileInputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GFileInputStream) = ccall(("g_file_input_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFileInputStream})
        signalnames(supertype(GFileInputStream))
    end
    abstract type GFileMonitor <: GObject end
    mutable struct GFileMonitorLeaf <: GFileMonitor
        handle::Ptr{GObject}
        function GFileMonitorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFileMonitorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFileMonitor] = GFileMonitorLeaf
    (GLib.g_type(::Type{T}) where T <: GFileMonitor) = ccall(("g_file_monitor_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFileMonitor})
        vcat([:changed], signalnames(supertype(GFileMonitor)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :changed => (:Nothing, Any[:(Ptr{GObject}), :(Ptr{GObject}), :UInt32]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GFileMonitor
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GFileMonitor
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GFileOutputStream <: GOutputStream end
    mutable struct GFileOutputStreamLeaf <: GFileOutputStream
        handle::Ptr{GObject}
        function GFileOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFileOutputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFileOutputStream] = GFileOutputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GFileOutputStream) = ccall(("g_file_output_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFileOutputStream})
        signalnames(supertype(GFileOutputStream))
    end
    abstract type GFilenameCompleter <: GObject end
    mutable struct GFilenameCompleterLeaf <: GFilenameCompleter
        handle::Ptr{GObject}
        function GFilenameCompleterLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GFilenameCompleterLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GFilenameCompleter] = GFilenameCompleterLeaf
    (GLib.g_type(::Type{T}) where T <: GFilenameCompleter) = ccall(("g_filename_completer_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GFilenameCompleter})
        vcat([:got_completion_data], signalnames(supertype(GFilenameCompleter)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :got_completion_data => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GFilenameCompleter
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GFilenameCompleter
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GIOModule <: GTypeModule end
    mutable struct GIOModuleLeaf <: GIOModule
        handle::Ptr{GObject}
        function GIOModuleLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GIOModuleLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GIOModule] = GIOModuleLeaf
    (GLib.g_type(::Type{T}) where T <: GIOModule) = ccall(("g_io_module_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GIOModule})
        signalnames(supertype(GIOModule))
    end
    abstract type GInetAddress <: GObject end
    mutable struct GInetAddressLeaf <: GInetAddress
        handle::Ptr{GObject}
        function GInetAddressLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GInetAddressLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GInetAddress] = GInetAddressLeaf
    (GLib.g_type(::Type{T}) where T <: GInetAddress) = ccall(("g_inet_address_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GInetAddress})
        signalnames(supertype(GInetAddress))
    end
    abstract type GInetAddressMask <: GObject end
    mutable struct GInetAddressMaskLeaf <: GInetAddressMask
        handle::Ptr{GObject}
        function GInetAddressMaskLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GInetAddressMaskLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GInetAddressMask] = GInetAddressMaskLeaf
    (GLib.g_type(::Type{T}) where T <: GInetAddressMask) = ccall(("g_inet_address_mask_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GInetAddressMask})
        signalnames(supertype(GInetAddressMask))
    end
    abstract type GSocketAddress <: GObject end
    mutable struct GSocketAddressLeaf <: GSocketAddress
        handle::Ptr{GObject}
        function GSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSocketAddressLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSocketAddress] = GSocketAddressLeaf
    (GLib.g_type(::Type{T}) where T <: GSocketAddress) = ccall(("g_socket_address_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSocketAddress})
        signalnames(supertype(GSocketAddress))
    end
    abstract type GInetSocketAddress <: GSocketAddress end
    mutable struct GInetSocketAddressLeaf <: GInetSocketAddress
        handle::Ptr{GObject}
        function GInetSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GInetSocketAddressLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GInetSocketAddress] = GInetSocketAddressLeaf
    (GLib.g_type(::Type{T}) where T <: GInetSocketAddress) = ccall(("g_inet_socket_address_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GInetSocketAddress})
        signalnames(supertype(GInetSocketAddress))
    end
    abstract type GListStore <: GObject end
    mutable struct GListStoreLeaf <: GListStore
        handle::Ptr{GObject}
        function GListStoreLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GListStoreLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GListStore] = GListStoreLeaf
    (GLib.g_type(::Type{T}) where T <: GListStore) = ccall(("g_list_store_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GListStore})
        vcat([:items_changed], signalnames(supertype(GListStore)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GListStore
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GListStore
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GMemoryInputStream <: GInputStream end
    mutable struct GMemoryInputStreamLeaf <: GMemoryInputStream
        handle::Ptr{GObject}
        function GMemoryInputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GMemoryInputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GMemoryInputStream] = GMemoryInputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GMemoryInputStream) = ccall(("g_memory_input_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GMemoryInputStream})
        signalnames(supertype(GMemoryInputStream))
    end
    abstract type GMemoryOutputStream <: GOutputStream end
    mutable struct GMemoryOutputStreamLeaf <: GMemoryOutputStream
        handle::Ptr{GObject}
        function GMemoryOutputStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GMemoryOutputStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GMemoryOutputStream] = GMemoryOutputStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GMemoryOutputStream) = ccall(("g_memory_output_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GMemoryOutputStream})
        signalnames(supertype(GMemoryOutputStream))
    end
    abstract type GMenu <: GMenuModel end
    mutable struct GMenuLeaf <: GMenu
        handle::Ptr{GObject}
        function GMenuLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GMenuLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GMenu] = GMenuLeaf
    (GLib.g_type(::Type{T}) where T <: GMenu) = ccall(("g_menu_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GMenu})
        signalnames(supertype(GMenu))
    end
    abstract type GMenuAttributeIter <: GObject end
    mutable struct GMenuAttributeIterLeaf <: GMenuAttributeIter
        handle::Ptr{GObject}
        function GMenuAttributeIterLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GMenuAttributeIterLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GMenuAttributeIter] = GMenuAttributeIterLeaf
    (GLib.g_type(::Type{T}) where T <: GMenuAttributeIter) = ccall(("g_menu_attribute_iter_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GMenuAttributeIter})
        signalnames(supertype(GMenuAttributeIter))
    end
    abstract type GMenuItem <: GObject end
    mutable struct GMenuItemLeaf <: GMenuItem
        handle::Ptr{GObject}
        function GMenuItemLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GMenuItemLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GMenuItem] = GMenuItemLeaf
    (GLib.g_type(::Type{T}) where T <: GMenuItem) = ccall(("g_menu_item_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GMenuItem})
        signalnames(supertype(GMenuItem))
    end
    abstract type GMenuLinkIter <: GObject end
    mutable struct GMenuLinkIterLeaf <: GMenuLinkIter
        handle::Ptr{GObject}
        function GMenuLinkIterLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GMenuLinkIterLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GMenuLinkIter] = GMenuLinkIterLeaf
    (GLib.g_type(::Type{T}) where T <: GMenuLinkIter) = ccall(("g_menu_link_iter_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GMenuLinkIter})
        signalnames(supertype(GMenuLinkIter))
    end
    abstract type GMountOperation <: GObject end
    mutable struct GMountOperationLeaf <: GMountOperation
        handle::Ptr{GObject}
        function GMountOperationLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GMountOperationLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GMountOperation] = GMountOperationLeaf
    (GLib.g_type(::Type{T}) where T <: GMountOperation) = ccall(("g_mount_operation_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GMountOperation})
        vcat([:aborted, :ask_password, :ask_question, :reply, :show_processes, :show_unmount_progress], signalnames(supertype(GMountOperation)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :show_unmount_progress => (:Nothing, [:Cstring, :Int64, :Int64]), :show_processes => (:Nothing, Any[:Cstring, :(Ptr{GArray}), :(Ptr{Cstring})]), :ask_password => (:Nothing, [:Cstring, :Cstring, :Cstring, :UInt32]), :aborted => (:Nothing, Any[]), :ask_question => (:Nothing, Any[:Cstring, :(Ptr{Cstring})]), :reply => (:Nothing, [:UInt32]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GMountOperation
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GMountOperation
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GNativeSocketAddress <: GSocketAddress end
    mutable struct GNativeSocketAddressLeaf <: GNativeSocketAddress
        handle::Ptr{GObject}
        function GNativeSocketAddressLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GNativeSocketAddressLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GNativeSocketAddress] = GNativeSocketAddressLeaf
    (GLib.g_type(::Type{T}) where T <: GNativeSocketAddress) = ccall(("g_native_socket_address_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GNativeSocketAddress})
        signalnames(supertype(GNativeSocketAddress))
    end
    abstract type GVolumeMonitor <: GObject end
    mutable struct GVolumeMonitorLeaf <: GVolumeMonitor
        handle::Ptr{GObject}
        function GVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GVolumeMonitorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GVolumeMonitor] = GVolumeMonitorLeaf
    (GLib.g_type(::Type{T}) where T <: GVolumeMonitor) = ccall(("g_volume_monitor_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GVolumeMonitor})
        vcat([:drive_changed, :drive_connected, :drive_disconnected, :drive_eject_button, :drive_stop_button, :mount_added, :mount_changed, :mount_pre_unmount, :mount_removed, :volume_added, :volume_changed, :volume_removed], signalnames(supertype(GVolumeMonitor)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :volume_added => (:Nothing, Expr[:(Ptr{GObject})]), :mount_removed => (:Nothing, Expr[:(Ptr{GObject})]), :volume_changed => (:Nothing, Expr[:(Ptr{GObject})]), :drive_disconnected => (:Nothing, Expr[:(Ptr{GObject})]), :volume_removed => (:Nothing, Expr[:(Ptr{GObject})]), :mount_pre_unmount => (:Nothing, Expr[:(Ptr{GObject})]), :drive_changed => (:Nothing, Expr[:(Ptr{GObject})]), :drive_stop_button => (:Nothing, Expr[:(Ptr{GObject})]), :mount_added => (:Nothing, Expr[:(Ptr{GObject})]), :drive_eject_button => (:Nothing, Expr[:(Ptr{GObject})]), :mount_changed => (:Nothing, Expr[:(Ptr{GObject})]), :drive_connected => (:Nothing, Expr[:(Ptr{GObject})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GVolumeMonitor
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GVolumeMonitor
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GNativeVolumeMonitor <: GVolumeMonitor end
    mutable struct GNativeVolumeMonitorLeaf <: GNativeVolumeMonitor
        handle::Ptr{GObject}
        function GNativeVolumeMonitorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GNativeVolumeMonitorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GNativeVolumeMonitor] = GNativeVolumeMonitorLeaf
    (GLib.g_type(::Type{T}) where T <: GNativeVolumeMonitor) = ccall(("g_native_volume_monitor_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GNativeVolumeMonitor})
        signalnames(supertype(GNativeVolumeMonitor))
    end
    abstract type GNetworkAddress <: GObject end
    mutable struct GNetworkAddressLeaf <: GNetworkAddress
        handle::Ptr{GObject}
        function GNetworkAddressLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GNetworkAddressLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GNetworkAddress] = GNetworkAddressLeaf
    (GLib.g_type(::Type{T}) where T <: GNetworkAddress) = ccall(("g_network_address_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GNetworkAddress})
        signalnames(supertype(GNetworkAddress))
    end
    abstract type GNetworkService <: GObject end
    mutable struct GNetworkServiceLeaf <: GNetworkService
        handle::Ptr{GObject}
        function GNetworkServiceLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GNetworkServiceLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GNetworkService] = GNetworkServiceLeaf
    (GLib.g_type(::Type{T}) where T <: GNetworkService) = ccall(("g_network_service_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GNetworkService})
        signalnames(supertype(GNetworkService))
    end
    abstract type GNotification <: GObject end
    mutable struct GNotificationLeaf <: GNotification
        handle::Ptr{GObject}
        function GNotificationLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GNotificationLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GNotification] = GNotificationLeaf
    (GLib.g_type(::Type{T}) where T <: GNotification) = ccall(("g_notification_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GNotification})
        signalnames(supertype(GNotification))
    end
    abstract type GPermission <: GObject end
    mutable struct GPermissionLeaf <: GPermission
        handle::Ptr{GObject}
        function GPermissionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GPermissionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GPermission] = GPermissionLeaf
    (GLib.g_type(::Type{T}) where T <: GPermission) = ccall(("g_permission_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GPermission})
        signalnames(supertype(GPermission))
    end
    abstract type GPropertyAction <: GObject end
    mutable struct GPropertyActionLeaf <: GPropertyAction
        handle::Ptr{GObject}
        function GPropertyActionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GPropertyActionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GPropertyAction] = GPropertyActionLeaf
    (GLib.g_type(::Type{T}) where T <: GPropertyAction) = ccall(("g_property_action_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GPropertyAction})
        signalnames(supertype(GPropertyAction))
    end
    abstract type GProxyAddress <: GInetSocketAddress end
    mutable struct GProxyAddressLeaf <: GProxyAddress
        handle::Ptr{GObject}
        function GProxyAddressLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GProxyAddressLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GProxyAddress] = GProxyAddressLeaf
    (GLib.g_type(::Type{T}) where T <: GProxyAddress) = ccall(("g_proxy_address_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GProxyAddress})
        signalnames(supertype(GProxyAddress))
    end
    abstract type GSocketAddressEnumerator <: GObject end
    mutable struct GSocketAddressEnumeratorLeaf <: GSocketAddressEnumerator
        handle::Ptr{GObject}
        function GSocketAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSocketAddressEnumeratorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSocketAddressEnumerator] = GSocketAddressEnumeratorLeaf
    (GLib.g_type(::Type{T}) where T <: GSocketAddressEnumerator) = ccall(("g_socket_address_enumerator_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSocketAddressEnumerator})
        signalnames(supertype(GSocketAddressEnumerator))
    end
    abstract type GProxyAddressEnumerator <: GSocketAddressEnumerator end
    mutable struct GProxyAddressEnumeratorLeaf <: GProxyAddressEnumerator
        handle::Ptr{GObject}
        function GProxyAddressEnumeratorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GProxyAddressEnumeratorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GProxyAddressEnumerator] = GProxyAddressEnumeratorLeaf
    (GLib.g_type(::Type{T}) where T <: GProxyAddressEnumerator) = ccall(("g_proxy_address_enumerator_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GProxyAddressEnumerator})
        signalnames(supertype(GProxyAddressEnumerator))
    end
    abstract type GResolver <: GObject end
    mutable struct GResolverLeaf <: GResolver
        handle::Ptr{GObject}
        function GResolverLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GResolverLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GResolver] = GResolverLeaf
    (GLib.g_type(::Type{T}) where T <: GResolver) = ccall(("g_resolver_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GResolver})
        vcat([:reload], signalnames(supertype(GResolver)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :reload => (:Nothing, Any[]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GResolver
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GResolver
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GSettings <: GObject end
    mutable struct GSettingsLeaf <: GSettings
        handle::Ptr{GObject}
        function GSettingsLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSettingsLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSettings] = GSettingsLeaf
    (GLib.g_type(::Type{T}) where T <: GSettings) = ccall(("g_settings_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSettings})
        vcat([:change_event, :changed, :writable_change_event, :writable_changed], signalnames(supertype(GSettings)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :change_event => (:Cint, Any[:(Ptr{UInt32}), :Int32]), :changed => (:Nothing, [:Cstring]), :writable_change_event => (:Cint, [:UInt32]), :writable_changed => (:Nothing, [:Cstring]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSettings
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSettings
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GSettingsBackend <: GObject end
    mutable struct GSettingsBackendLeaf <: GSettingsBackend
        handle::Ptr{GObject}
        function GSettingsBackendLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSettingsBackendLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSettingsBackend] = GSettingsBackendLeaf
    (GLib.g_type(::Type{T}) where T <: GSettingsBackend) = ccall(("g_settings_backend_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSettingsBackend})
        signalnames(supertype(GSettingsBackend))
    end
    abstract type GSimpleAction <: GObject end
    mutable struct GSimpleActionLeaf <: GSimpleAction
        handle::Ptr{GObject}
        function GSimpleActionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSimpleActionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSimpleAction] = GSimpleActionLeaf
    (GLib.g_type(::Type{T}) where T <: GSimpleAction) = ccall(("g_simple_action_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSimpleAction})
        vcat([:activate, :change_state], signalnames(supertype(GSimpleAction)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :change_state => (:Nothing, [:GVariant]), :activate => (:Nothing, [:GVariant]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSimpleAction
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSimpleAction
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GSimpleActionGroup <: GObject end
    mutable struct GSimpleActionGroupLeaf <: GSimpleActionGroup
        handle::Ptr{GObject}
        function GSimpleActionGroupLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSimpleActionGroupLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSimpleActionGroup] = GSimpleActionGroupLeaf
    (GLib.g_type(::Type{T}) where T <: GSimpleActionGroup) = ccall(("g_simple_action_group_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSimpleActionGroup})
        vcat([:action_added, :action_enabled_changed, :action_removed, :action_state_changed], signalnames(supertype(GSimpleActionGroup)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSimpleActionGroup
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSimpleActionGroup
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GSimpleAsyncResult <: GObject end
    mutable struct GSimpleAsyncResultLeaf <: GSimpleAsyncResult
        handle::Ptr{GObject}
        function GSimpleAsyncResultLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSimpleAsyncResultLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSimpleAsyncResult] = GSimpleAsyncResultLeaf
    (GLib.g_type(::Type{T}) where T <: GSimpleAsyncResult) = ccall(("g_simple_async_result_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSimpleAsyncResult})
        signalnames(supertype(GSimpleAsyncResult))
    end
    abstract type GSimpleIOStream <: GIOStream end
    mutable struct GSimpleIOStreamLeaf <: GSimpleIOStream
        handle::Ptr{GObject}
        function GSimpleIOStreamLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSimpleIOStreamLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSimpleIOStream] = GSimpleIOStreamLeaf
    (GLib.g_type(::Type{T}) where T <: GSimpleIOStream) = ccall(("g_simple_io_stream_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSimpleIOStream})
        signalnames(supertype(GSimpleIOStream))
    end
    abstract type GSimplePermission <: GPermission end
    mutable struct GSimplePermissionLeaf <: GSimplePermission
        handle::Ptr{GObject}
        function GSimplePermissionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSimplePermissionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSimplePermission] = GSimplePermissionLeaf
    (GLib.g_type(::Type{T}) where T <: GSimplePermission) = ccall(("g_simple_permission_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSimplePermission})
        signalnames(supertype(GSimplePermission))
    end
    abstract type GSimpleProxyResolver <: GObject end
    mutable struct GSimpleProxyResolverLeaf <: GSimpleProxyResolver
        handle::Ptr{GObject}
        function GSimpleProxyResolverLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSimpleProxyResolverLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSimpleProxyResolver] = GSimpleProxyResolverLeaf
    (GLib.g_type(::Type{T}) where T <: GSimpleProxyResolver) = ccall(("g_simple_proxy_resolver_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSimpleProxyResolver})
        signalnames(supertype(GSimpleProxyResolver))
    end
    abstract type GSocket <: GObject end
    mutable struct GSocketLeaf <: GSocket
        handle::Ptr{GObject}
        function GSocketLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSocketLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSocket] = GSocketLeaf
    (GLib.g_type(::Type{T}) where T <: GSocket) = ccall(("g_socket_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSocket})
        signalnames(supertype(GSocket))
    end
    abstract type GSocketClient <: GObject end
    mutable struct GSocketClientLeaf <: GSocketClient
        handle::Ptr{GObject}
        function GSocketClientLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSocketClientLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSocketClient] = GSocketClientLeaf
    (GLib.g_type(::Type{T}) where T <: GSocketClient) = ccall(("g_socket_client_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSocketClient})
        vcat([:event], signalnames(supertype(GSocketClient)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Nothing, Any[:UInt32, :(Ptr{GObject}), :(Ptr{GObject})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSocketClient
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSocketClient
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GSocketConnection <: GIOStream end
    mutable struct GSocketConnectionLeaf <: GSocketConnection
        handle::Ptr{GObject}
        function GSocketConnectionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSocketConnectionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSocketConnection] = GSocketConnectionLeaf
    (GLib.g_type(::Type{T}) where T <: GSocketConnection) = ccall(("g_socket_connection_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSocketConnection})
        signalnames(supertype(GSocketConnection))
    end
    abstract type GSocketControlMessage <: GObject end
    mutable struct GSocketControlMessageLeaf <: GSocketControlMessage
        handle::Ptr{GObject}
        function GSocketControlMessageLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSocketControlMessageLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSocketControlMessage] = GSocketControlMessageLeaf
    (GLib.g_type(::Type{T}) where T <: GSocketControlMessage) = ccall(("g_socket_control_message_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSocketControlMessage})
        signalnames(supertype(GSocketControlMessage))
    end
    abstract type GSocketListener <: GObject end
    mutable struct GSocketListenerLeaf <: GSocketListener
        handle::Ptr{GObject}
        function GSocketListenerLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSocketListenerLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSocketListener] = GSocketListenerLeaf
    (GLib.g_type(::Type{T}) where T <: GSocketListener) = ccall(("g_socket_listener_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSocketListener})
        vcat([:event], signalnames(supertype(GSocketListener)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Nothing, Any[:UInt32, :(Ptr{GObject})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSocketListener
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSocketListener
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GSocketService <: GSocketListener end
    mutable struct GSocketServiceLeaf <: GSocketService
        handle::Ptr{GObject}
        function GSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSocketServiceLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSocketService] = GSocketServiceLeaf
    (GLib.g_type(::Type{T}) where T <: GSocketService) = ccall(("g_socket_service_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSocketService})
        vcat([:incoming], signalnames(supertype(GSocketService)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Nothing, Any[:UInt32, :(Ptr{GObject})]), :incoming => (:Cint, Expr[:(Ptr{GObject}), :(Ptr{GObject})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GSocketService
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GSocketService
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GSubprocess <: GObject end
    mutable struct GSubprocessLeaf <: GSubprocess
        handle::Ptr{GObject}
        function GSubprocessLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSubprocessLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSubprocess] = GSubprocessLeaf
    (GLib.g_type(::Type{T}) where T <: GSubprocess) = ccall(("g_subprocess_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSubprocess})
        signalnames(supertype(GSubprocess))
    end
    abstract type GSubprocessLauncher <: GObject end
    mutable struct GSubprocessLauncherLeaf <: GSubprocessLauncher
        handle::Ptr{GObject}
        function GSubprocessLauncherLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GSubprocessLauncherLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GSubprocessLauncher] = GSubprocessLauncherLeaf
    (GLib.g_type(::Type{T}) where T <: GSubprocessLauncher) = ccall(("g_subprocess_launcher_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GSubprocessLauncher})
        signalnames(supertype(GSubprocessLauncher))
    end
    abstract type GTask <: GObject end
    mutable struct GTaskLeaf <: GTask
        handle::Ptr{GObject}
        function GTaskLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GTaskLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GTask] = GTaskLeaf
    (GLib.g_type(::Type{T}) where T <: GTask) = ccall(("g_task_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GTask})
        signalnames(supertype(GTask))
    end
    abstract type GTcpConnection <: GSocketConnection end
    mutable struct GTcpConnectionLeaf <: GTcpConnection
        handle::Ptr{GObject}
        function GTcpConnectionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GTcpConnectionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GTcpConnection] = GTcpConnectionLeaf
    (GLib.g_type(::Type{T}) where T <: GTcpConnection) = ccall(("g_tcp_connection_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GTcpConnection})
        signalnames(supertype(GTcpConnection))
    end
    abstract type GTcpWrapperConnection <: GTcpConnection end
    mutable struct GTcpWrapperConnectionLeaf <: GTcpWrapperConnection
        handle::Ptr{GObject}
        function GTcpWrapperConnectionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GTcpWrapperConnectionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GTcpWrapperConnection] = GTcpWrapperConnectionLeaf
    (GLib.g_type(::Type{T}) where T <: GTcpWrapperConnection) = ccall(("g_tcp_wrapper_connection_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GTcpWrapperConnection})
        signalnames(supertype(GTcpWrapperConnection))
    end
    abstract type GTestDBus <: GObject end
    mutable struct GTestDBusLeaf <: GTestDBus
        handle::Ptr{GObject}
        function GTestDBusLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GTestDBusLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GTestDBus] = GTestDBusLeaf
    (GLib.g_type(::Type{T}) where T <: GTestDBus) = ccall(("g_test_dbus_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GTestDBus})
        signalnames(supertype(GTestDBus))
    end
    abstract type GThemedIcon <: GObject end
    mutable struct GThemedIconLeaf <: GThemedIcon
        handle::Ptr{GObject}
        function GThemedIconLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GThemedIconLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GThemedIcon] = GThemedIconLeaf
    (GLib.g_type(::Type{T}) where T <: GThemedIcon) = ccall(("g_themed_icon_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GThemedIcon})
        signalnames(supertype(GThemedIcon))
    end
    abstract type GThreadedResolver <: GResolver end
    mutable struct GThreadedResolverLeaf <: GThreadedResolver
        handle::Ptr{GObject}
        function GThreadedResolverLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GThreadedResolverLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GThreadedResolver] = GThreadedResolverLeaf
    (GLib.g_type(::Type{T}) where T <: GThreadedResolver) = ccall(("g_threaded_resolver_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GThreadedResolver})
        signalnames(supertype(GThreadedResolver))
    end
    abstract type GThreadedSocketService <: GSocketService end
    mutable struct GThreadedSocketServiceLeaf <: GThreadedSocketService
        handle::Ptr{GObject}
        function GThreadedSocketServiceLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GThreadedSocketServiceLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GThreadedSocketService] = GThreadedSocketServiceLeaf
    (GLib.g_type(::Type{T}) where T <: GThreadedSocketService) = ccall(("g_threaded_socket_service_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GThreadedSocketService})
        vcat([:run], signalnames(supertype(GThreadedSocketService)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :event => (:Nothing, Any[:UInt32, :(Ptr{GObject})]), :run => (:Cint, Expr[:(Ptr{GObject}), :(Ptr{GObject})]), :incoming => (:Cint, Expr[:(Ptr{GObject}), :(Ptr{GObject})]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GThreadedSocketService
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GThreadedSocketService
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GTlsCertificate <: GObject end
    mutable struct GTlsCertificateLeaf <: GTlsCertificate
        handle::Ptr{GObject}
        function GTlsCertificateLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GTlsCertificateLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GTlsCertificate] = GTlsCertificateLeaf
    (GLib.g_type(::Type{T}) where T <: GTlsCertificate) = ccall(("g_tls_certificate_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GTlsCertificate})
        signalnames(supertype(GTlsCertificate))
    end
    abstract type GTlsConnection <: GIOStream end
    mutable struct GTlsConnectionLeaf <: GTlsConnection
        handle::Ptr{GObject}
        function GTlsConnectionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GTlsConnectionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GTlsConnection] = GTlsConnectionLeaf
    (GLib.g_type(::Type{T}) where T <: GTlsConnection) = ccall(("g_tls_connection_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GTlsConnection})
        vcat([:accept_certificate], signalnames(supertype(GTlsConnection)))
    end
    let d = Dict{Symbol, Tuple{Any, Any}}(:notify => (:Nothing, Any[:(Ptr{GParamSpec})]), :accept_certificate => (:Cint, Any[:(Ptr{GObject}), :UInt32]))
        function GLib.signal_return_type(::Type{T}, name::Symbol) where T <: GTlsConnection
            eval((d[name])[1])
        end
        function GLib.signal_argument_types(::Type{T}, name::Symbol) where T <: GTlsConnection
            Tuple(eval.((d[name])[2]))
        end
    end
    abstract type GTlsDatabase <: GObject end
    mutable struct GTlsDatabaseLeaf <: GTlsDatabase
        handle::Ptr{GObject}
        function GTlsDatabaseLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GTlsDatabaseLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GTlsDatabase] = GTlsDatabaseLeaf
    (GLib.g_type(::Type{T}) where T <: GTlsDatabase) = ccall(("g_tls_database_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GTlsDatabase})
        signalnames(supertype(GTlsDatabase))
    end
    abstract type GTlsInteraction <: GObject end
    mutable struct GTlsInteractionLeaf <: GTlsInteraction
        handle::Ptr{GObject}
        function GTlsInteractionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GTlsInteractionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GTlsInteraction] = GTlsInteractionLeaf
    (GLib.g_type(::Type{T}) where T <: GTlsInteraction) = ccall(("g_tls_interaction_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GTlsInteraction})
        signalnames(supertype(GTlsInteraction))
    end
    abstract type GTlsPassword <: GObject end
    mutable struct GTlsPasswordLeaf <: GTlsPassword
        handle::Ptr{GObject}
        function GTlsPasswordLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GTlsPasswordLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GTlsPassword] = GTlsPasswordLeaf
    (GLib.g_type(::Type{T}) where T <: GTlsPassword) = ccall(("g_tls_password_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GTlsPassword})
        signalnames(supertype(GTlsPassword))
    end
    abstract type GUnixConnection <: GSocketConnection end
    mutable struct GUnixConnectionLeaf <: GUnixConnection
        handle::Ptr{GObject}
        function GUnixConnectionLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GUnixConnectionLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GUnixConnection] = GUnixConnectionLeaf
    (GLib.g_type(::Type{T}) where T <: GUnixConnection) = ccall(("g_unix_connection_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GUnixConnection})
        signalnames(supertype(GUnixConnection))
    end
    abstract type GUnixCredentialsMessage <: GSocketControlMessage end
    mutable struct GUnixCredentialsMessageLeaf <: GUnixCredentialsMessage
        handle::Ptr{GObject}
        function GUnixCredentialsMessageLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GUnixCredentialsMessageLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GUnixCredentialsMessage] = GUnixCredentialsMessageLeaf
    (GLib.g_type(::Type{T}) where T <: GUnixCredentialsMessage) = ccall(("g_unix_credentials_message_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GUnixCredentialsMessage})
        signalnames(supertype(GUnixCredentialsMessage))
    end
    abstract type GVfs <: GObject end
    mutable struct GVfsLeaf <: GVfs
        handle::Ptr{GObject}
        function GVfsLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GVfsLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GVfs] = GVfsLeaf
    (GLib.g_type(::Type{T}) where T <: GVfs) = ccall(("g_vfs_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GVfs})
        signalnames(supertype(GVfs))
    end
    abstract type GZlibCompressor <: GObject end
    mutable struct GZlibCompressorLeaf <: GZlibCompressor
        handle::Ptr{GObject}
        function GZlibCompressorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GZlibCompressorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GZlibCompressor] = GZlibCompressorLeaf
    (GLib.g_type(::Type{T}) where T <: GZlibCompressor) = ccall(("g_zlib_compressor_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GZlibCompressor})
        signalnames(supertype(GZlibCompressor))
    end
    abstract type GZlibDecompressor <: GObject end
    mutable struct GZlibDecompressorLeaf <: GZlibDecompressor
        handle::Ptr{GObject}
        function GZlibDecompressorLeaf(handle::Ptr{GObject}, owns = false)
            if handle == C_NULL
                error("Cannot construct GZlibDecompressorLeaf with a NULL pointer")
            end
            GLib.gobject_maybe_sink(handle, owns)
            return gobject_ref(new(handle))
        end
    end
    gtype_wrapper_cache[:GZlibDecompressor] = GZlibDecompressorLeaf
    (GLib.g_type(::Type{T}) where T <: GZlibDecompressor) = ccall(("g_zlib_decompressor_get_type", libgio), GType, ())
    function GLib.signalnames(::Type{GZlibDecompressor})
        signalnames(supertype(GZlibDecompressor))
    end
    function GAppLaunchContext()
        G_.AppLaunchContext_new()
    end
    function GApplication(_application_id::Maybe(Union{AbstractString, Symbol}), _flags; kwargs...)
        obj = G_.Application_new(_application_id, _flags)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBufferedInputStream(_base_stream::GInputStream; kwargs...)
        obj = G_.BufferedInputStream_new(_base_stream)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBufferedInputStream(_base_stream::GInputStream, _size::Integer; kwargs...)
        obj = G_.BufferedInputStream_new_sized(_base_stream, _size)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBufferedOutputStream(_base_stream::GOutputStream; kwargs...)
        obj = G_.BufferedOutputStream_new(_base_stream)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBufferedOutputStream(_base_stream::GOutputStream, _size::Integer; kwargs...)
        obj = G_.BufferedOutputStream_new_sized(_base_stream, _size)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GBytesIcon(_bytes::GBytes; kwargs...)
        obj = G_.BytesIcon_new(_bytes)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GCancellable()
        G_.Cancellable_new()
    end
    function GCharsetConverter(_to_charset::Union{AbstractString, Symbol}, _from_charset::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.CharsetConverter_new(_to_charset, _from_charset)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GConverterInputStream(_base_stream::GInputStream, _converter::GConverter; kwargs...)
        obj = G_.ConverterInputStream_new(_base_stream, _converter)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GConverterOutputStream(_base_stream::GOutputStream, _converter::GConverter; kwargs...)
        obj = G_.ConverterOutputStream_new(_base_stream, _converter)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GCredentials()
        G_.Credentials_new()
    end
    function GDBusAuthObserver()
        G_.DBusAuthObserver_new()
    end
    function GDBusConnection(_res::GAsyncResult; kwargs...)
        obj = G_.DBusConnection_new_finish(_res)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusConnection(_address::Union{AbstractString, Symbol}, _flags, _observer::Maybe(GDBusAuthObserver), _cancellable::Maybe(GCancellable); kwargs...)
        obj = G_.DBusConnection_new_for_address_sync(_address, _flags, _observer, _cancellable)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusMessage(; kwargs...)
        obj = G_.DBusMessage_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusMessage(_blob, _capabilities; kwargs...)
        obj = G_.DBusMessage_new_from_blob(_blob, _capabilities)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusMessage(_name::Maybe(Union{AbstractString, Symbol}), _path::Union{AbstractString, Symbol}, _interface_::Maybe(Union{AbstractString, Symbol}), _method::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DBusMessage_new_method_call(_name, _path, _interface_, _method)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusMessage(_path::Union{AbstractString, Symbol}, _interface_::Union{AbstractString, Symbol}, _signal::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DBusMessage_new_signal(_path, _interface_, _signal)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusObjectManagerClient(_res::GAsyncResult; kwargs...)
        obj = G_.DBusObjectManagerClient_new_finish(_res)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusObjectProxy(_connection::GDBusConnection, _object_path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DBusObjectProxy_new(_connection, _object_path)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDBusProxy(_res::GAsyncResult; kwargs...)
        obj = G_.DBusProxy_new_finish(_res)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDataInputStream(_base_stream::GInputStream; kwargs...)
        obj = G_.DataInputStream_new(_base_stream)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDataOutputStream(_base_stream::GOutputStream; kwargs...)
        obj = G_.DataOutputStream_new(_base_stream)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDesktopAppInfo(_desktop_id::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.DesktopAppInfo_new(_desktop_id)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GDesktopAppInfo(_key_file::GKeyFile; kwargs...)
        obj = G_.DesktopAppInfo_new_from_keyfile(_key_file)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GEmblem(_icon::GIcon; kwargs...)
        obj = G_.Emblem_new(_icon)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GEmblem(_icon::GIcon, _origin; kwargs...)
        obj = G_.Emblem_new_with_origin(_icon, _origin)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GEmblemedIcon(_icon::GIcon, _emblem::Maybe(GEmblem); kwargs...)
        obj = G_.EmblemedIcon_new(_icon, _emblem)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GFileIcon(_file::GFile; kwargs...)
        obj = G_.FileIcon_new(_file)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GFileInfo()
        G_.FileInfo_new()
    end
    function GFilenameCompleter()
        G_.FilenameCompleter_new()
    end
    function GIOModule(_filename::Union{AbstractString, Symbol})
        G_.IOModule_new(_filename)
    end
    function GInetAddress(_family; kwargs...)
        obj = G_.InetAddress_new_any(_family)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetAddress(_bytes, _family; kwargs...)
        obj = G_.InetAddress_new_from_bytes(_bytes, _family)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetAddress(_string::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.InetAddress_new_from_string(_string)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetAddressMask(_addr::GInetAddress, _length::Integer; kwargs...)
        obj = G_.InetAddressMask_new(_addr, _length)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetAddressMask(_mask_string::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.InetAddressMask_new_from_string(_mask_string)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetSocketAddress(_address::GInetAddress, _port::Integer; kwargs...)
        obj = G_.InetSocketAddress_new(_address, _port)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GInetSocketAddress(_address::Union{AbstractString, Symbol}, _port::Integer; kwargs...)
        obj = G_.InetSocketAddress_new_from_string(_address, _port)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GListStore(_item_type::Integer; kwargs...)
        obj = G_.ListStore_new(_item_type)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GMemoryInputStream()
        G_.MemoryInputStream_new()
    end
    function GMemoryInputStream(_bytes::GBytes)
        G_.MemoryInputStream_new_from_bytes(_bytes)
    end
    function GMemoryInputStream(_data, _destroy::Maybe(Function))
        G_.MemoryInputStream_new_from_data(_data, _destroy)
    end
    function GMemoryOutputStream(; kwargs...)
        obj = G_.MemoryOutputStream_new_resizable()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GMenu()
        G_.Menu_new()
    end
    function GMenuItem(_label::Maybe(Union{AbstractString, Symbol}), _detailed_action::Maybe(Union{AbstractString, Symbol}))
        G_.MenuItem_new(_label, _detailed_action)
    end
    function GMenuItem(_model::GMenuModel, _item_index::Integer)
        G_.MenuItem_new_from_model(_model, _item_index)
    end
    function GMenuItem(_label::Maybe(Union{AbstractString, Symbol}), _submenu::GMenuModel)
        G_.MenuItem_new_submenu(_label, _submenu)
    end
    function GMountOperation(; kwargs...)
        obj = G_.MountOperation_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GNativeSocketAddress(_native::Maybe(Nothing), _len::Integer)
        G_.NativeSocketAddress_new(_native, _len)
    end
    function GNetworkAddress(_hostname::Union{AbstractString, Symbol}, _port::Integer; kwargs...)
        obj = G_.NetworkAddress_new(_hostname, _port)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GNetworkService(_service::Union{AbstractString, Symbol}, _protocol::Union{AbstractString, Symbol}, _domain::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.NetworkService_new(_service, _protocol, _domain)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GNotification(_title::Union{AbstractString, Symbol})
        G_.Notification_new(_title)
    end
    function GPropertyAction(_name::Union{AbstractString, Symbol}, _object::GObject, _property_name::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.PropertyAction_new(_name, _object, _property_name)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GProxyAddress(_inetaddr::GInetAddress, _port::Integer, _protocol::Union{AbstractString, Symbol}, _dest_hostname::Union{AbstractString, Symbol}, _dest_port::Integer, _username::Maybe(Union{AbstractString, Symbol}), _password::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.ProxyAddress_new(_inetaddr, _port, _protocol, _dest_hostname, _dest_port, _username, _password)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema_id::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Settings_new(_schema_id)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema::GSettingsSchema, _backend::Maybe(GSettingsBackend), _path::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.Settings_new_full(_schema, _backend, _path)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema_id::Union{AbstractString, Symbol}, _backend::GSettingsBackend; kwargs...)
        obj = G_.Settings_new_with_backend(_schema_id, _backend)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema_id::Union{AbstractString, Symbol}, _backend::GSettingsBackend, _path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Settings_new_with_backend_and_path(_schema_id, _backend, _path)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSettings(_schema_id::Union{AbstractString, Symbol}, _path::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.Settings_new_with_path(_schema_id, _path)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSimpleAction(_name::Union{AbstractString, Symbol}, _parameter_type::Maybe(GVariantType); kwargs...)
        obj = G_.SimpleAction_new(_name, _parameter_type)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSimpleAction(_name::Union{AbstractString, Symbol}, _parameter_type::Maybe(GVariantType), _state::GVariant; kwargs...)
        obj = G_.SimpleAction_new_stateful(_name, _parameter_type, _state)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSimpleActionGroup()
        G_.SimpleActionGroup_new()
    end
    function GSimpleIOStream(_input_stream::GInputStream, _output_stream::GOutputStream; kwargs...)
        obj = G_.SimpleIOStream_new(_input_stream, _output_stream)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSimplePermission(_allowed::Bool)
        G_.SimplePermission_new(_allowed)
    end
    function GSocket(_family, _type, _protocol; kwargs...)
        obj = G_.Socket_new(_family, _type, _protocol)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocket(_fd::Integer; kwargs...)
        obj = G_.Socket_new_from_fd(_fd)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocketAddress(_native::Nothing, _len::Integer; kwargs...)
        obj = G_.SocketAddress_new_from_native(_native, _len)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocketClient(; kwargs...)
        obj = G_.SocketClient_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocketListener(; kwargs...)
        obj = G_.SocketListener_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSocketService(; kwargs...)
        obj = G_.SocketService_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSubprocess(_argv, _flags; kwargs...)
        obj = G_.Subprocess_new(_argv, _flags)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GSubprocessLauncher(_flags; kwargs...)
        obj = G_.SubprocessLauncher_new(_flags)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTask(_source_object::Maybe(GObject), _cancellable::Maybe(GCancellable), _callback::Maybe(Function); kwargs...)
        obj = G_.Task_new(_source_object, _cancellable, _callback)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTcpWrapperConnection(_base_io_stream::GIOStream, _socket::GSocket; kwargs...)
        obj = G_.TcpWrapperConnection_new(_base_io_stream, _socket)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTestDBus(_flags; kwargs...)
        obj = G_.TestDBus_new(_flags)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GThemedIcon(_iconname::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.ThemedIcon_new(_iconname)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GThemedIcon(_iconnames; kwargs...)
        obj = G_.ThemedIcon_new_from_names(_iconnames)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GThreadedSocketService(_max_threads::Integer; kwargs...)
        obj = G_.ThreadedSocketService_new(_max_threads)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_file::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.TlsCertificate_new_from_file(_file)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_cert_file::Union{AbstractString, Symbol}, _key_file::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.TlsCertificate_new_from_files(_cert_file, _key_file)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_data::Union{AbstractString, Symbol}, _length::Integer; kwargs...)
        obj = G_.TlsCertificate_new_from_pem(_data, _length)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_pkcs11_uri::Union{AbstractString, Symbol}, _private_key_pkcs11_uri::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.TlsCertificate_new_from_pkcs11_uris(_pkcs11_uri, _private_key_pkcs11_uri)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsCertificate(_data, _password::Maybe(Union{AbstractString, Symbol}); kwargs...)
        obj = G_.TlsCertificate_new_from_pkcs12(_data, _password)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GTlsPassword(_flags, _description::Union{AbstractString, Symbol}; kwargs...)
        obj = G_.TlsPassword_new(_flags, _description)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GUnixCredentialsMessage(; kwargs...)
        obj = G_.UnixCredentialsMessage_new()
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GUnixCredentialsMessage(_credentials::GCredentials; kwargs...)
        obj = G_.UnixCredentialsMessage_new_with_credentials(_credentials)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GZlibCompressor(_format, _level::Integer; kwargs...)
        obj = G_.ZlibCompressor_new(_format, _level)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GZlibDecompressor(_format; kwargs...)
        obj = G_.ZlibDecompressor_new(_format)
        obj !== nothing && GLib.setproperties!(obj; kwargs...)
        obj
    end
    function GFileAttributeInfoList()
        G_.FileAttributeInfoList_new()
    end
    function GFileAttributeMatcher(_attributes::Union{AbstractString, Symbol})
        G_.FileAttributeMatcher_new(_attributes)
    end
    function GResource(_data::GBytes)
        G_.Resource_new_from_data(_data)
    end
    function GSettingsSchemaSource(_directory::Union{AbstractString, Symbol}, _parent::Maybe(GSettingsSchemaSource), _trusted::Bool)
        G_.SettingsSchemaSource_new_from_directory(_directory, _parent, _trusted)
    end
    function GSrvTarget(_hostname::Union{AbstractString, Symbol}, _port::Integer, _priority::Integer, _weight::Integer)
        G_.SrvTarget_new(_hostname, _port, _priority, _weight)
    end
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.AppInfoMonitor.html)." GAppInfoMonitor
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.AppLaunchContext.html)." GAppLaunchContext
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Application.html)." GApplication
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ApplicationCommandLine.html)." GApplicationCommandLine
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.BufferedInputStream.html)." GBufferedInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.BufferedOutputStream.html)." GBufferedOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.BytesIcon.html)." GBytesIcon
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Cancellable.html)." GCancellable
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.CharsetConverter.html)." GCharsetConverter
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ConverterInputStream.html)." GConverterInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ConverterOutputStream.html)." GConverterOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Credentials.html)." GCredentials
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusActionGroup.html)." GDBusActionGroup
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusAuthObserver.html)." GDBusAuthObserver
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusConnection.html)." GDBusConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusMenuModel.html)." GDBusMenuModel
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusMessage.html)." GDBusMessage
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusMethodInvocation.html)." GDBusMethodInvocation
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectManagerClient.html)." GDBusObjectManagerClient
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusObjectProxy.html)." GDBusObjectProxy
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusProxy.html)." GDBusProxy
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DBusServer.html)." GDBusServer
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DataInputStream.html)." GDataInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DataOutputStream.html)." GDataOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.DesktopAppInfo.html)." GDesktopAppInfo
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Emblem.html)." GEmblem
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.EmblemedIcon.html)." GEmblemedIcon
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileEnumerator.html)." GFileEnumerator
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileIOStream.html)." GFileIOStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileIcon.html)." GFileIcon
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileInfo.html)." GFileInfo
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileInputStream.html)." GFileInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileMonitor.html)." GFileMonitor
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FileOutputStream.html)." GFileOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FilenameCompleter.html)." GFilenameCompleter
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FilterInputStream.html)." GFilterInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.FilterOutputStream.html)." GFilterOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.IOModule.html)." GIOModule
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.IOStream.html)." GIOStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.InetAddress.html)." GInetAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.InetAddressMask.html)." GInetAddressMask
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.InetSocketAddress.html)." GInetSocketAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.InputStream.html)." GInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ListStore.html)." GListStore
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MemoryInputStream.html)." GMemoryInputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MemoryOutputStream.html)." GMemoryOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Menu.html)." GMenu
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MenuAttributeIter.html)." GMenuAttributeIter
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MenuItem.html)." GMenuItem
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MenuLinkIter.html)." GMenuLinkIter
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MenuModel.html)." GMenuModel
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.MountOperation.html)." GMountOperation
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.NativeSocketAddress.html)." GNativeSocketAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.NetworkAddress.html)." GNetworkAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.NetworkService.html)." GNetworkService
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Notification.html)." GNotification
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.OutputStream.html)." GOutputStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Permission.html)." GPermission
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.PropertyAction.html)." GPropertyAction
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ProxyAddress.html)." GProxyAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ProxyAddressEnumerator.html)." GProxyAddressEnumerator
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Resolver.html)." GResolver
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Settings.html)." GSettings
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SettingsBackend.html)." GSettingsBackend
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleAction.html)." GSimpleAction
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleActionGroup.html)." GSimpleActionGroup
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleAsyncResult.html)." GSimpleAsyncResult
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleIOStream.html)." GSimpleIOStream
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimplePermission.html)." GSimplePermission
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SimpleProxyResolver.html)." GSimpleProxyResolver
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Socket.html)." GSocket
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketAddress.html)." GSocketAddress
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketAddressEnumerator.html)." GSocketAddressEnumerator
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketClient.html)." GSocketClient
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketConnection.html)." GSocketConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketControlMessage.html)." GSocketControlMessage
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketListener.html)." GSocketListener
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SocketService.html)." GSocketService
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Subprocess.html)." GSubprocess
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.SubprocessLauncher.html)." GSubprocessLauncher
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Task.html)." GTask
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TcpConnection.html)." GTcpConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TcpWrapperConnection.html)." GTcpWrapperConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TestDBus.html)." GTestDBus
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ThemedIcon.html)." GThemedIcon
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ThreadedResolver.html)." GThreadedResolver
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ThreadedSocketService.html)." GThreadedSocketService
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsCertificate.html)." GTlsCertificate
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsConnection.html)." GTlsConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsDatabase.html)." GTlsDatabase
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsInteraction.html)." GTlsInteraction
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.TlsPassword.html)." GTlsPassword
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.UnixConnection.html)." GUnixConnection
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.UnixCredentialsMessage.html)." GUnixCredentialsMessage
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.Vfs.html)." GVfs
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.VolumeMonitor.html)." GVolumeMonitor
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ZlibCompressor.html)." GZlibCompressor
    @doc "See the [GTK docs](https://docs.gtk.org/gio/class.ZlibDecompressor.html)." GZlibDecompressor
    function on_changed(f, object::GAppInfoMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "changed", Nothing, (), after, user_data)
    end
    function on_launch_failed(f, object::GAppLaunchContext, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "launch-failed", Nothing, (Cstring,), after, user_data)
    end
    function on_launch_started(f, object::GAppLaunchContext, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "launch-started", Nothing, (Ptr{GObject}, GVariant), after, user_data)
    end
    function on_launched(f, object::GAppLaunchContext, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "launched", Nothing, (Ptr{GObject}, GVariant), after, user_data)
    end
    function on_activate(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "activate", Nothing, (), after, user_data)
    end
    function on_command_line(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "command-line", Int32, (Ptr{GObject},), after, user_data)
    end
    function on_handle_local_options(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "handle-local-options", Int32, (GVariantDict,), after, user_data)
    end
    function on_name_lost(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "name-lost", Cint, (), after, user_data)
    end
    function on_open(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "open", Nothing, (Ptr{Ptr{GObject}}, Int32, Cstring), after, user_data)
    end
    function on_shutdown(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "shutdown", Nothing, (), after, user_data)
    end
    function on_startup(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "startup", Nothing, (), after, user_data)
    end
    function on_action_added(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-added", Nothing, (Cstring,), after, user_data)
    end
    function on_action_enabled_changed(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-enabled-changed", Nothing, (Cstring, Cint), after, user_data)
    end
    function on_action_removed(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-removed", Nothing, (Cstring,), after, user_data)
    end
    function on_action_state_changed(f, object::GApplication, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-state-changed", Nothing, (Cstring, GVariant), after, user_data)
    end
    function on_cancelled(f, object::GCancellable, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "cancelled", Nothing, (), after, user_data)
    end
    function on_action_added(f, object::GDBusActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-added", Nothing, (Cstring,), after, user_data)
    end
    function on_action_enabled_changed(f, object::GDBusActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-enabled-changed", Nothing, (Cstring, Cint), after, user_data)
    end
    function on_action_removed(f, object::GDBusActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-removed", Nothing, (Cstring,), after, user_data)
    end
    function on_action_state_changed(f, object::GDBusActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-state-changed", Nothing, (Cstring, GVariant), after, user_data)
    end
    function on_allow_mechanism(f, object::GDBusAuthObserver, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "allow-mechanism", Cint, (Cstring,), after, user_data)
    end
    function on_authorize_authenticated_peer(f, object::GDBusAuthObserver, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "authorize-authenticated-peer", Cint, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_closed(f, object::GDBusConnection, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "closed", Nothing, (Cint, Ptr{GError}), after, user_data)
    end
    function on_interface_proxy_properties_changed(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-proxy-properties-changed", Nothing, (Ptr{GObject}, Ptr{GObject}, GVariant, Ptr{Cstring}), after, user_data)
    end
    function on_interface_proxy_signal(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-proxy-signal", Nothing, (Ptr{GObject}, Ptr{GObject}, Cstring, Cstring, GVariant), after, user_data)
    end
    function on_interface_added(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-added", Nothing, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_interface_removed(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-removed", Nothing, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_object_added(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "object-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_object_removed(f, object::GDBusObjectManagerClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "object-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_interface_added(f, object::GDBusObjectProxy, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_interface_removed(f, object::GDBusObjectProxy, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "interface-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_g_properties_changed(f, object::GDBusProxy, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "g-properties-changed", Nothing, (GVariant, Ptr{Cstring}), after, user_data)
    end
    function on_g_signal(f, object::GDBusProxy, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "g-signal", Nothing, (Cstring, Cstring, GVariant), after, user_data)
    end
    function on_new_connection(f, object::GDBusServer, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "new-connection", Cint, (Ptr{GObject},), after, user_data)
    end
    function on_changed(f, object::GFileMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "changed", Nothing, (Ptr{GObject}, Ptr{GObject}, UInt32), after, user_data)
    end
    function on_got_completion_data(f, object::GFilenameCompleter, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "got-completion-data", Nothing, (), after, user_data)
    end
    function on_items_changed(f, object::GListStore, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "items-changed", Nothing, (UInt32, UInt32, UInt32), after, user_data)
    end
    function on_items_changed(f, object::GMenuModel, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "items-changed", Nothing, (Int32, Int32, Int32), after, user_data)
    end
    function on_aborted(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "aborted", Nothing, (), after, user_data)
    end
    function on_ask_password(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "ask-password", Nothing, (Cstring, Cstring, Cstring, UInt32), after, user_data)
    end
    function on_ask_question(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "ask-question", Nothing, (Cstring, Ptr{Cstring}), after, user_data)
    end
    function on_reply(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "reply", Nothing, (UInt32,), after, user_data)
    end
    function on_show_processes(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "show-processes", Nothing, (Cstring, Ptr{GArray}, Ptr{Cstring}), after, user_data)
    end
    function on_show_unmount_progress(f, object::GMountOperation, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "show-unmount-progress", Nothing, (Cstring, Int64, Int64), after, user_data)
    end
    function on_reload(f, object::GResolver, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "reload", Nothing, (), after, user_data)
    end
    function on_change_event(f, object::GSettings, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "change-event", Cint, (Ptr{UInt32}, Int32), after, user_data)
    end
    function on_changed(f, object::GSettings, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "changed", Nothing, (Cstring,), after, user_data)
    end
    function on_writable_change_event(f, object::GSettings, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "writable-change-event", Cint, (UInt32,), after, user_data)
    end
    function on_writable_changed(f, object::GSettings, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "writable-changed", Nothing, (Cstring,), after, user_data)
    end
    function on_activate(f, object::GSimpleAction, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "activate", Nothing, (GVariant,), after, user_data)
    end
    function on_change_state(f, object::GSimpleAction, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "change-state", Nothing, (GVariant,), after, user_data)
    end
    function on_action_added(f, object::GSimpleActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-added", Nothing, (Cstring,), after, user_data)
    end
    function on_action_enabled_changed(f, object::GSimpleActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-enabled-changed", Nothing, (Cstring, Cint), after, user_data)
    end
    function on_action_removed(f, object::GSimpleActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-removed", Nothing, (Cstring,), after, user_data)
    end
    function on_action_state_changed(f, object::GSimpleActionGroup, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "action-state-changed", Nothing, (Cstring, GVariant), after, user_data)
    end
    function on_event(f, object::GSocketClient, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "event", Nothing, (UInt32, Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_event(f, object::GSocketListener, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "event", Nothing, (UInt32, Ptr{GObject}), after, user_data)
    end
    function on_incoming(f, object::GSocketService, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "incoming", Cint, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_run(f, object::GThreadedSocketService, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "run", Cint, (Ptr{GObject}, Ptr{GObject}), after, user_data)
    end
    function on_accept_certificate(f, object::GTlsConnection, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "accept-certificate", Cint, (Ptr{GObject}, UInt32), after, user_data)
    end
    function on_drive_changed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-changed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_drive_connected(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-connected", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_drive_disconnected(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-disconnected", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_drive_eject_button(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-eject-button", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_drive_stop_button(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "drive-stop-button", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_mount_added(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "mount-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_mount_changed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "mount-changed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_mount_pre_unmount(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "mount-pre-unmount", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_mount_removed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "mount-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_volume_added(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "volume-added", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_volume_changed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "volume-changed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function on_volume_removed(f, object::GVolumeMonitor, user_data = object, after = false)
        GLib.signal_connect_generic(f, object, "volume-removed", Nothing, (Ptr{GObject},), after, user_data)
    end
    function GAsyncReadyCallback(source_object, res, data)
        source_object = convert_if_not_null(GObject, source_object, false)
        res = begin
                leaftype = GLib.find_leaf_type(res)
                convert(leaftype, res, false)
            end
        f = data
        ret = f(source_object, res)
        nothing
    end
    function GBusAcquiredCallback(connection, name, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        f = user_data
        ret = f(connection, name)
        nothing
    end
    function GBusNameAcquiredCallback(connection, name, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        f = user_data
        ret = f(connection, name)
        nothing
    end
    function GBusNameAppearedCallback(connection, name, name_owner, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        name_owner = string_or_nothing(name_owner, false)
        f = user_data
        ret = f(connection, name, name_owner)
        nothing
    end
    function GBusNameLostCallback(connection, name, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        f = user_data
        ret = f(connection, name)
        nothing
    end
    function GBusNameVanishedCallback(connection, name, user_data)
        connection = convert(GDBusConnection, connection, false)
        name = string_or_nothing(name, false)
        f = user_data
        ret = f(connection, name)
        nothing
    end
    function GCancellableSourceFunc(cancellable, data)
        cancellable = convert_if_not_null(GCancellable, cancellable, false)
        f = data
        ret = f(cancellable)
        convert(Cint, ret)
    end
    function GDBusInterfaceGetPropertyFunc(connection, sender, object_path, interface_name, property_name, error, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        property_name = string_or_nothing(property_name, false)
        f = user_data
        ret = f(connection, sender, object_path, interface_name, property_name, error)
        ret != C_NULL && GLib.glib_ref(ret)
        convert(Ptr{GVariant}, GLib.get_pointer(ret))
    end
    function GDBusInterfaceMethodCallFunc(connection, sender, object_path, interface_name, method_name, parameters, invocation, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        method_name = string_or_nothing(method_name, false)
        parameters = convert(GVariant, parameters)
        invocation = convert(GDBusMethodInvocation, invocation, true)
        f = user_data
        ret = f(connection, sender, object_path, interface_name, method_name, parameters, invocation)
        nothing
    end
    function GDBusInterfaceSetPropertyFunc(connection, sender, object_path, interface_name, property_name, value, error, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        property_name = string_or_nothing(property_name, false)
        value = convert(GVariant, value)
        f = user_data
        ret = f(connection, sender, object_path, interface_name, property_name, value, error)
        convert(Cint, ret)
    end
    function GDBusMessageFilterFunction(connection, message, incoming, user_data)
        connection = convert(GDBusConnection, connection, false)
        message = convert(GDBusMessage, message, true)
        incoming = convert(Bool, incoming)
        f = user_data
        ret = f(connection, message, incoming)
        ret != C_NULL && GLib.glib_ref(ret)
        convert(Ptr{GObject}, GLib.get_pointer(ret))
    end
    function GDBusProxyTypeFunc(manager, object_path, interface_name, data)
        manager = convert(GDBusObjectManagerClient, manager, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        f = data
        ret = f(manager, object_path, interface_name)
        convert(GType, ret)
    end
    function GDBusSignalCallback(connection, sender_name, object_path, interface_name, signal_name, parameters, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender_name = string_or_nothing(sender_name, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        signal_name = string_or_nothing(signal_name, false)
        parameters = convert(GVariant, parameters)
        f = user_data
        ret = f(connection, sender_name, object_path, interface_name, signal_name, parameters)
        nothing
    end
    function GDBusSubtreeDispatchFunc(connection, sender, object_path, interface_name, node, out_user_data, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        interface_name = string_or_nothing(interface_name, false)
        node = string_or_nothing(node, false)
        out_user_data = convert(Nothing, out_user_data)
        f = user_data
        ret = f(connection, sender, object_path, interface_name, node, out_user_data)
        convert(Ptr{_GDBusInterfaceVTable}, ret)
    end
    function GDBusSubtreeEnumerateFunc(connection, sender, object_path, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        f = user_data
        ret = f(connection, sender, object_path)
        convert(Ptr{Cstring}, ret)
    end
    function GDBusSubtreeIntrospectFunc(connection, sender, object_path, node, user_data)
        connection = convert(GDBusConnection, connection, false)
        sender = string_or_nothing(sender, false)
        object_path = string_or_nothing(object_path, false)
        node = string_or_nothing(node, false)
        f = user_data
        ret = f(connection, sender, object_path, node)
        convert(Ptr{Ptr{_GDBusInterfaceInfo}}, ret)
    end
    function GDatagramBasedSourceFunc(datagram_based, condition, data)
        datagram_based = begin
                leaftype = GLib.find_leaf_type(datagram_based)
                convert(leaftype, datagram_based, false)
            end
        condition = IOCondition(condition)
        f = data
        ret = f(datagram_based, condition)
        convert(Cint, ret)
    end
    function GDesktopAppLaunchCallback(appinfo, pid, user_data)
        appinfo = convert(GDesktopAppInfo, appinfo, false)
        f = user_data
        ret = f(appinfo, pid)
        nothing
    end
    function GFileMeasureProgressCallback(reporting, current_size, num_dirs, num_files, data)
        reporting = convert(Bool, reporting)
        f = data
        ret = f(reporting, current_size, num_dirs, num_files)
        nothing
    end
    function GFileProgressCallback(current_num_bytes, total_num_bytes, data)
        f = data
        ret = f(current_num_bytes, total_num_bytes)
        nothing
    end
    function GFileReadMoreCallback(file_contents, file_size, callback_data)
        file_contents = string_or_nothing(file_contents, false)
        f = callback_data
        ret = f(file_contents, file_size)
        convert(Cint, ret)
    end
    function GPollableSourceFunc(pollable_stream, data)
        pollable_stream = convert(GObject, pollable_stream, false)
        f = data
        ret = f(pollable_stream)
        convert(Cint, ret)
    end
    function GSettingsBindGetMapping(value, variant, user_data)
        value = convert(GValueLike, value, false)
        variant = convert(GVariant, variant)
        f = user_data
        ret = f(value, variant)
        convert(Cint, ret)
    end
    function GSettingsBindSetMapping(value, expected_type, user_data)
        value = convert(GValueLike, value, false)
        expected_type = convert(GVariantType, expected_type, false)
        f = user_data
        ret = f(value, expected_type)
        ret != C_NULL && GLib.glib_ref(ret)
        convert(Ptr{GVariant}, GLib.get_pointer(ret))
    end
    function GSettingsGetMapping(value, result, user_data)
        value = convert(Maybe(GVariant), value)
        result = convert(Maybe(Nothing), result)
        f = user_data
        ret = f(value, result)
        convert(Cint, ret)
    end
    function GSocketSourceFunc(socket, condition, data)
        socket = convert(GSocket, socket, false)
        condition = IOCondition(condition)
        f = data
        ret = f(socket, condition)
        convert(Cint, ret)
    end
    function GVfsFileLookupFunc(vfs, identifier, user_data)
        vfs = convert(GVfs, vfs, false)
        identifier = string_or_nothing(identifier, false)
        f = user_data
        ret = f(vfs, identifier)
        ret != C_NULL && GLib.glib_ref(ret)
        convert(Ptr{GObject}, GLib.get_pointer(ret))
    end
    export GDBusErrorEntry, GDBusErrorEntryLike, _GDBusErrorEntry, GFileAttributeInfo, GFileAttributeInfoLike, _GFileAttributeInfo, GFileAttributeInfoList, GFileAttributeInfoListLike, _GFileAttributeInfoList, GFileAttributeMatcher, GInputVector, GInputVectorLike, _GInputVector, GOutputVector, GOutputVectorLike, _GOutputVector, GResource, GSettingsSchema, GSettingsSchemaKey, GSettingsSchemaSource, GSrvTarget, GAction, GActionGroup, GActionMap, GAppInfo, GAsyncInitable, GAsyncResult, GConverter, GDBusInterface, GDBusObject, GDBusObjectManager, GDatagramBased, GDebugController, GDrive, GDtlsClientConnection, GDtlsConnection, GDtlsServerConnection, GFile, GFileDescriptorBased, GIcon, GInitable, GListModel, GLoadableIcon, GMemoryMonitor, GMount, GNetworkMonitor, GPollableInputStream, GPollableOutputStream, GPowerProfileMonitor, GProxy, GProxyResolver, GRemoteActionGroup, GSeekable, GSocketConnectable, GTlsBackend, GTlsClientConnection, GTlsFileDatabase, GTlsServerConnection, GVolume, GAppInfoMonitor, GAppInfoMonitorLeaf, GAppLaunchContext, GAppLaunchContextLeaf, GApplication, GApplicationLeaf, GApplicationCommandLine, GApplicationCommandLineLeaf, GBufferedInputStream, GBufferedInputStreamLeaf, GBufferedOutputStream, GBufferedOutputStreamLeaf, GBytesIcon, GBytesIconLeaf, GCancellable, GCancellableLeaf, GCharsetConverter, GCharsetConverterLeaf, GConverterInputStream, GConverterInputStreamLeaf, GConverterOutputStream, GConverterOutputStreamLeaf, GCredentials, GCredentialsLeaf, GDBusActionGroup, GDBusActionGroupLeaf, GDBusAuthObserver, GDBusAuthObserverLeaf, GDBusConnection, GDBusConnectionLeaf, GDBusMenuModel, GDBusMenuModelLeaf, GDBusMessage, GDBusMessageLeaf, GDBusMethodInvocation, GDBusMethodInvocationLeaf, GDBusObjectManagerClient, GDBusObjectManagerClientLeaf, GDBusObjectProxy, GDBusObjectProxyLeaf, GDBusProxy, GDBusProxyLeaf, GDBusServer, GDBusServerLeaf, GDataInputStream, GDataInputStreamLeaf, GDataOutputStream, GDataOutputStreamLeaf, GDesktopAppInfo, GDesktopAppInfoLeaf, GEmblem, GEmblemLeaf, GEmblemedIcon, GEmblemedIconLeaf, GFileEnumerator, GFileEnumeratorLeaf, GFileIOStream, GFileIOStreamLeaf, GFileIcon, GFileIconLeaf, GFileInfo, GFileInfoLeaf, GFileInputStream, GFileInputStreamLeaf, GFileMonitor, GFileOutputStream, GFileOutputStreamLeaf, GFilenameCompleter, GFilenameCompleterLeaf, GFilterInputStream, GFilterOutputStream, GIOModule, GIOModuleLeaf, GIOStream, GInetAddress, GInetAddressLeaf, GInetAddressMask, GInetAddressMaskLeaf, GInetSocketAddress, GInetSocketAddressLeaf, GInputStream, GListStore, GListStoreLeaf, GMemoryInputStream, GMemoryInputStreamLeaf, GMemoryOutputStream, GMemoryOutputStreamLeaf, GMenu, GMenuLeaf, GMenuAttributeIter, GMenuItem, GMenuItemLeaf, GMenuLinkIter, GMenuModel, GMountOperation, GMountOperationLeaf, GNativeSocketAddress, GNativeSocketAddressLeaf, GNativeVolumeMonitor, GNetworkAddress, GNetworkAddressLeaf, GNetworkService, GNetworkServiceLeaf, GNotification, GNotificationLeaf, GOutputStream, GPermission, GPropertyAction, GPropertyActionLeaf, GProxyAddress, GProxyAddressLeaf, GProxyAddressEnumerator, GProxyAddressEnumeratorLeaf, GResolver, GSettings, GSettingsLeaf, GSettingsBackend, GSimpleAction, GSimpleActionLeaf, GSimpleActionGroup, GSimpleActionGroupLeaf, GSimpleAsyncResult, GSimpleAsyncResultLeaf, GSimpleIOStream, GSimpleIOStreamLeaf, GSimplePermission, GSimplePermissionLeaf, GSimpleProxyResolver, GSimpleProxyResolverLeaf, GSocket, GSocketLeaf, GSocketAddress, GSocketAddressEnumerator, GSocketClient, GSocketClientLeaf, GSocketConnection, GSocketConnectionLeaf, GSocketControlMessage, GSocketListener, GSocketListenerLeaf, GSocketService, GSocketServiceLeaf, GSubprocess, GSubprocessLeaf, GSubprocessLauncher, GSubprocessLauncherLeaf, GTask, GTaskLeaf, GTcpConnection, GTcpConnectionLeaf, GTcpWrapperConnection, GTcpWrapperConnectionLeaf, GTestDBus, GTestDBusLeaf, GThemedIcon, GThemedIconLeaf, GThreadedResolver, GThreadedResolverLeaf, GThreadedSocketService, GThreadedSocketServiceLeaf, GTlsCertificate, GTlsConnection, GTlsDatabase, GTlsInteraction, GTlsInteractionLeaf, GTlsPassword, GTlsPasswordLeaf, GUnixConnection, GUnixConnectionLeaf, GUnixCredentialsMessage, GUnixCredentialsMessageLeaf, GVfs, GVfsLeaf, GVolumeMonitor, GVolumeMonitorLeaf, GZlibCompressor, GZlibCompressorLeaf, GZlibDecompressor, GZlibDecompressorLeaf, GAsyncReadyCallback, GBusAcquiredCallback, GBusNameAcquiredCallback, GBusNameAppearedCallback, GBusNameLostCallback, GBusNameVanishedCallback, GCancellableSourceFunc, GDBusInterfaceGetPropertyFunc, GDBusInterfaceMethodCallFunc, GDBusInterfaceSetPropertyFunc, GDBusMessageFilterFunction, GDBusProxyTypeFunc, GDBusSignalCallback, GDBusSubtreeDispatchFunc, GDBusSubtreeEnumerateFunc, GDBusSubtreeIntrospectFunc, GDatagramBasedSourceFunc, GDesktopAppLaunchCallback, GFileMeasureProgressCallback, GFileProgressCallback, GFileReadMoreCallback, GPollableSourceFunc, GSettingsBindGetMapping, GSettingsBindSetMapping, GSettingsGetMapping, GSocketSourceFunc, GVfsFileLookupFunc
end
