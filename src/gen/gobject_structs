quote
$(Expr(:toplevel, quote
    begin
        struct _GEnumValue
            value::Int32
            value_name::Cstring
            value_nick::Cstring
        end
        mutable struct GEnumValue
            handle::Ptr{_GEnumValue}
        end
        unsafe_convert(::Type{Ptr{_GEnumValue}}, box::GEnumValue) = begin
                convert(Ptr{_GEnumValue}, box.handle)
            end
    end
    begin
        struct _GTypeClass
            g_type::UInt64
        end
        mutable struct GTypeClass
            handle::Ptr{_GTypeClass}
        end
        unsafe_convert(::Type{Ptr{_GTypeClass}}, box::GTypeClass) = begin
                convert(Ptr{_GTypeClass}, box.handle)
            end
    end
    begin
        struct _GFlagsValue
            value::UInt32
            value_name::Cstring
            value_nick::Cstring
        end
        mutable struct GFlagsValue
            handle::Ptr{_GFlagsValue}
        end
        unsafe_convert(::Type{Ptr{_GFlagsValue}}, box::GFlagsValue) = begin
                convert(Ptr{_GFlagsValue}, box.handle)
            end
    end
    begin
        struct _GTypeValueTable
            value_init::Ptr{Cvoid}
            value_free::Ptr{Cvoid}
            value_copy::Ptr{Cvoid}
            value_peek_pointer::Ptr{Cvoid}
            collect_format::Cstring
            collect_value::Ptr{Cvoid}
            lcopy_format::Cstring
            lcopy_value::Ptr{Cvoid}
        end
        mutable struct GTypeValueTable
            handle::Ptr{_GTypeValueTable}
        end
        unsafe_convert(::Type{Ptr{_GTypeValueTable}}, box::GTypeValueTable) = begin
                convert(Ptr{_GTypeValueTable}, box.handle)
            end
    end
    begin
        struct _GEnumClass
            g_type_class::_GTypeClass
            minimum::Int32
            maximum::Int32
            n_values::UInt32
            values::Ptr{_GEnumValue}
        end
        mutable struct GEnumClass
            handle::Ptr{_GEnumClass}
        end
        unsafe_convert(::Type{Ptr{_GEnumClass}}, box::GEnumClass) = begin
                convert(Ptr{_GEnumClass}, box.handle)
            end
    end
    begin
        struct _GFlagsClass
            g_type_class::_GTypeClass
            mask::UInt32
            n_values::UInt32
            values::Ptr{_GFlagsValue}
        end
        mutable struct GFlagsClass
            handle::Ptr{_GFlagsClass}
        end
        unsafe_convert(::Type{Ptr{_GFlagsClass}}, box::GFlagsClass) = begin
                convert(Ptr{_GFlagsClass}, box.handle)
            end
    end
    begin
        struct _GSignalInvocationHint
            signal_id::UInt32
            detail::UInt32
            run_type::UInt32
        end
        mutable struct GSignalInvocationHint
            handle::Ptr{_GSignalInvocationHint}
        end
        unsafe_convert(::Type{Ptr{_GSignalInvocationHint}}, box::GSignalInvocationHint) = begin
                convert(Ptr{_GSignalInvocationHint}, box.handle)
            end
    end
    begin
        struct _GSignalQuery
            signal_id::UInt32
            signal_name::Cstring
            itype::UInt64
            signal_flags::UInt32
            return_type::UInt64
            n_params::UInt32
            param_types::Ptr{UInt64}
        end
        mutable struct GSignalQuery
            handle::Ptr{_GSignalQuery}
        end
        unsafe_convert(::Type{Ptr{_GSignalQuery}}, box::GSignalQuery) = begin
                convert(Ptr{_GSignalQuery}, box.handle)
            end
    end
    begin
        struct _GTypeFundamentalInfo
            type_flags::UInt32
        end
        mutable struct GTypeFundamentalInfo
            handle::Ptr{_GTypeFundamentalInfo}
        end
        unsafe_convert(::Type{Ptr{_GTypeFundamentalInfo}}, box::GTypeFundamentalInfo) = begin
                convert(Ptr{_GTypeFundamentalInfo}, box.handle)
            end
    end
    begin
        struct _GTypeInfo
            class_size::UInt16
            base_init::Ptr{Cvoid}
            base_finalize::Ptr{Cvoid}
            class_init::Ptr{Cvoid}
            class_finalize::Ptr{Cvoid}
            class_data::Ptr{Nothing}
            instance_size::UInt16
            n_preallocs::UInt16
            instance_init::Ptr{Cvoid}
            value_table::Ptr{_GTypeValueTable}
        end
        mutable struct GTypeInfo
            handle::Ptr{_GTypeInfo}
        end
        unsafe_convert(::Type{Ptr{_GTypeInfo}}, box::GTypeInfo) = begin
                convert(Ptr{_GTypeInfo}, box.handle)
            end
    end
    begin
        struct _GTypePluginClass
            base_iface::_GTypeInterface
            use_plugin::Ptr{Cvoid}
            unuse_plugin::Ptr{Cvoid}
            complete_type_info::Ptr{Cvoid}
            complete_interface_info::Ptr{Cvoid}
        end
        mutable struct GTypePluginClass
            handle::Ptr{_GTypePluginClass}
        end
        unsafe_convert(::Type{Ptr{_GTypePluginClass}}, box::GTypePluginClass) = begin
                convert(Ptr{_GTypePluginClass}, box.handle)
            end
    end
    begin
        struct _GTypeQuery
            type::UInt64
            type_name::Cstring
            class_size::UInt32
            instance_size::UInt32
        end
        mutable struct GTypeQuery
            handle::Ptr{_GTypeQuery}
        end
        unsafe_convert(::Type{Ptr{_GTypeQuery}}, box::GTypeQuery) = begin
                convert(Ptr{_GTypeQuery}, box.handle)
            end
    end
    begin
        struct _GValueArray
            n_values::UInt32
            values::Ptr{_GValue}
            n_prealloced::UInt32
        end
        mutable struct GValueArray <: GBoxed
            handle::Ptr{_GValueArray}
            begin
                (GLib.g_type(::Type{T}) where T <: GValueArray) = begin
                        ccall(("g_value_array_get_type", libgobject), GType, ())
                    end
                function GValueArray(ref::Ptr{T}, own::Bool = false) where T <: GBoxed
                    x = new(ref)
                    if own
                        finalizer(x) do x
                            GLib.delboxed(x)
                        end
                    end
                    x
                end
                push!(gboxed_types, GValueArray)
            end
        end
        unsafe_convert(::Type{Ptr{_GValueArray}}, box::GValueArray) = begin
                convert(Ptr{_GValueArray}, box.handle)
            end
    end
    @doc "The class of an enumeration type holds information about its\npossible values.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/struct.EnumClass.html)." GEnumClass
    @doc "The class of a flags type holds information about its\npossible values.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/struct.FlagsClass.html)." GFlagsClass
    @doc "The #GSignalInvocationHint structure is used to pass on additional information\nto callbacks during a signal emission.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/struct.SignalInvocationHint.html)." GSignalInvocationHint
    @doc "A structure holding in-depth information for a specific signal.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/struct.SignalQuery.html)." GSignalQuery
    @doc "A structure that provides information to the type system which is\nused specifically for managing fundamental types.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/struct.TypeFundamentalInfo.html)." GTypeFundamentalInfo
    @doc "This structure is used to provide the type system with the information\nrequired to initialize and destruct (finalize) a type's class and\nits instances.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/struct.TypeInfo.html)." GTypeInfo
    @doc "The #GTypePlugin interface is used by the type system in order to handle\nthe lifecycle of dynamically loaded types.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/struct.TypePluginClass.html)." GTypePluginClass
    @doc "A structure holding information for a specific type.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/struct.TypeQuery.html)." GTypeQuery
    @doc "A #GValueArray contains an array of #GValue elements.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/struct.ValueArray.html)." GValueArray
    gtype_wrapper_cache = Dict{Symbol, Type}()
    begin
        abstract type GBinding <: GObject end
        mutable struct GBindingLeaf <: GBinding
            handle::Ptr{GObject}
            function GBindingLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBindingLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GBinding] = GBindingLeaf
        (GLib.g_type(::Type{T}) where T <: GBinding) = begin
                ccall(("g_binding_get_type", libgobject), GType, ())
            end
    end
    begin
        abstract type GBindingGroup <: GObject end
        mutable struct GBindingGroupLeaf <: GBindingGroup
            handle::Ptr{GObject}
            function GBindingGroupLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GBindingGroupLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GBindingGroup] = GBindingGroupLeaf
        (GLib.g_type(::Type{T}) where T <: GBindingGroup) = begin
                ccall(("g_binding_group_get_type", libgobject), GType, ())
            end
    end
    begin
        abstract type GInitiallyUnowned <: GObject end
        mutable struct GInitiallyUnownedLeaf <: GInitiallyUnowned
            handle::Ptr{GObject}
            function GInitiallyUnownedLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GInitiallyUnownedLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GInitiallyUnowned] = GInitiallyUnownedLeaf
        (GLib.g_type(::Type{T}) where T <: GInitiallyUnowned) = begin
                ccall(("g_initially_unowned_get_type", libgobject), GType, ())
            end
    end
    begin
        abstract type GTypeModule <: GObject end
        mutable struct GTypeModuleLeaf <: GTypeModule
            handle::Ptr{GObject}
            function GTypeModuleLeaf(handle::Ptr{GObject}, owns = false)
                if handle == C_NULL
                    error("Cannot construct GTypeModuleLeaf with a NULL pointer")
                end
                GLib.gobject_maybe_sink(handle, owns)
                return gobject_ref(new(handle))
            end
        end
        gtype_wrapper_cache[:GTypeModule] = GTypeModuleLeaf
        (GLib.g_type(::Type{T}) where T <: GTypeModule) = begin
                ccall(("g_type_module_get_type", libgobject), GType, ())
            end
    end
    begin
        gtype_wrapper_cache_init() = begin
                merge!(GLib.gtype_wrappers, gtype_wrapper_cache)
            end
    end
    function GBindingGroup(; kwargs...)
        obj = G_.BindingGroup_new()
        GLib.setproperties!(obj; kwargs...)
        obj
    end
    @doc "#GBinding is the representation of a binding between a property on a\n#GObject instance (or source) and another property on another #GObject\ninstance (or target).\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/class.Binding.html)." GBinding
    @doc "The #GBindingGroup can be used to bind multiple properties\nfrom an object collectively.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/class.BindingGroup.html)." GBindingGroup
    @doc "A type for objects that have an initially floating reference.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/class.InitiallyUnowned.html)." GInitiallyUnowned
    @doc "#GTypeModule provides a simple implementation of the #GTypePlugin\ninterface.\n \nDetails can be found in the [GTK docs](https://docs.gtk.org/gobject/class.TypeModule.html)." GTypeModule
    gtype_wrapper_cache[:GObject] = GObjectLeaf
    struct GTypePlugin <: GInterface
        handle::Ptr{GObject}
        gc::Any
        GTypePlugin(x::GObject) = begin
                new(unsafe_convert(Ptr{GObject}, x), x)
            end
    end
    function GBindingTransformFunc(binding, from_value, to_value, user_data)
        f = user_data
        ret = f(binding, from_value, to_value)
        convert(Cint, ret)
    end
    function GClassFinalizeFunc(g_class, class_data)
        f = class_data
        ret = f(g_class)
        nothing
    end
    function GClassInitFunc(g_class, class_data)
        f = class_data
        ret = f(g_class)
        nothing
    end
    function GClosureMarshal(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
        f = marshal_data
        ret = f(closure, return_value, n_param_values, param_values, invocation_hint)
        nothing
    end
    function GInterfaceFinalizeFunc(g_iface, iface_data)
        f = iface_data
        ret = f(g_iface)
        nothing
    end
    function GInterfaceInitFunc(g_iface, iface_data)
        f = iface_data
        ret = f(g_iface)
        nothing
    end
    function GSignalAccumulator(ihint, return_accu, handler_return, data)
        f = data
        ret = f(ihint, return_accu, handler_return)
        convert(Cint, ret)
    end
    function GSignalEmissionHook(ihint, n_param_values, param_values, data)
        f = data
        ret = f(ihint, n_param_values, param_values)
        convert(Cint, ret)
    end
    export GEnumValue, _GEnumValue, GTypeClass, _GTypeClass, GFlagsValue, _GFlagsValue, GTypeValueTable, _GTypeValueTable, GEnumClass, _GEnumClass, GFlagsClass, _GFlagsClass, GSignalInvocationHint, _GSignalInvocationHint, GSignalQuery, _GSignalQuery, GTypeFundamentalInfo, _GTypeFundamentalInfo, GTypeInfo, _GTypeInfo, GTypePluginClass, _GTypePluginClass, GTypeQuery, _GTypeQuery, GValueArray, _GValueArray, GBinding, GBindingLeaf, GBindingGroup, GBindingGroupLeaf, GInitiallyUnowned, GInitiallyUnownedLeaf, GTypeModule, GTypePlugin, GBindingTransformFunc, GClassFinalizeFunc, GClassInitFunc, GClosureMarshal, GInterfaceFinalizeFunc, GInterfaceInitFunc, GSignalAccumulator, GSignalEmissionHook
end))
end
