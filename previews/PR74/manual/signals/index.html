<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Signals and Callbacks · Gtk4.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Gtk4.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../gettingStarted/">Getting Started</a></li><li><a class="tocitem" href="../properties/">Properties</a></li><li><a class="tocitem" href="../methods/">Automatically generated methods</a></li><li><a class="tocitem" href="../layout/">Layout</a></li><li class="is-active"><a class="tocitem" href>Signals and Callbacks</a><ul class="internal"><li><a class="tocitem" href="#Property-notifications"><span>Property notifications</span></a></li><li><a class="tocitem" href="#Alternative-approach-to-signals-and-signal-handlers"><span>Alternative approach to signals and signal handlers</span></a></li></ul></li><li><a class="tocitem" href="../builder/">Builder</a></li><li><a class="tocitem" href="../actions/">Actions</a></li><li><a class="tocitem" href="../buttons/">Buttons</a></li><li><a class="tocitem" href="../textwidgets/">Text Widgets</a></li><li><a class="tocitem" href="../display/">Display widgets</a></li><li><a class="tocitem" href="../combobox/">Dropdown widgets</a></li><li><a class="tocitem" href="../listtreeview/">List and Tree Widgets</a></li><li><a class="tocitem" href="../dialogs/">Dialogs</a></li><li><a class="tocitem" href="../keyevents/">Key Events</a></li><li><a class="tocitem" href="../canvas/">Drawing with Cairo</a></li></ul></li><li><span class="tocitem">Howto</span><ul><li><a class="tocitem" href="../../howto/nonreplusage/">Using Gtk4 outside the REPL</a></li><li><a class="tocitem" href="../../howto/async/">Asynchronous UI</a></li><li><a class="tocitem" href="../../howto/sysimage/">Gtk4 in a sysimage</a></li></ul></li><li><a class="tocitem" href="../../diff3to4/">Gtk.jl to Gtk4.jl</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../doc/reference/">Gtk4 Reference</a></li><li><a class="tocitem" href="../../doc/GLib_reference/">GLib Reference</a></li><li><a class="tocitem" href="../../doc/Gtk4_types_reference/">Gtk4 Types</a></li><li><a class="tocitem" href="../../doc/GLib_types_reference/">GLib Types</a></li><li><a class="tocitem" href="../../doc/constants_reference/">Constants</a></li><li><a class="tocitem" href="../../doc/preferences/">Preference Settings</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Signals and Callbacks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Signals and Callbacks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGtk/Gtk4.jl/blob/main/docs/src/manual/signals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Signals-and-Callbacks"><a class="docs-heading-anchor" href="#Signals-and-Callbacks">Signals and Callbacks</a><a id="Signals-and-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Signals-and-Callbacks" title="Permalink"></a></h1><p>A button is not much use if it doesn&#39;t do anything. GTK uses <em>signals</em> as a method for communicating that something of interest has happened. Most signals will be <em>emitted</em> as a consequence of user interaction: clicking on a button, closing a window, or just moving the mouse. You <em>connect</em> your signals to particular functions to make something happen.</p><p>Let&#39;s try a simple example:</p><pre><code class="language-julia hljs">b = GtkButton(&quot;Press me&quot;)
win = GtkWindow(b, &quot;Callbacks&quot;)

function button_clicked_callback(widget)
    println(widget, &quot; was clicked!&quot;)
end

id = signal_connect(button_clicked_callback, b, &quot;clicked&quot;)</code></pre><p>Here, <code>button_clicked_callback</code> is a <em>callback function</em>, something designed to be called by GTK to implement the response to user action.  You use the <code>signal_connect</code> function to specify when it should be called: in this case, when widget <code>b</code> (your button) emits the <code>&quot;clicked&quot;</code> signal.</p><p>Using Julia&#39;s <code>do</code> syntax, the exact same code could alternatively be written as</p><pre><code class="language-julia hljs">b = GtkButton(&quot;Press me&quot;)
win = GtkWindow(b, &quot;Callbacks&quot;)
id = signal_connect(b, &quot;clicked&quot;) do widget
     println(widget, &quot; was clicked!&quot;)
end</code></pre><p>If you try this, and click on the button, you should see something like the following:</p><pre><code class="nohighlight hljs">julia&gt; GtkButton(action-name=NULL, action-target, related-action, use-action-appearance=TRUE, name=&quot;&quot;, parent, width-request=-1, height-request=-1, visible=TRUE, sensitive=TRUE, app-paintable=FALSE, can-focus=TRUE, has-focus=TRUE, is-focus=TRUE, can-default=FALSE, has-default=FALSE, receives-default=TRUE, composite-child=FALSE, style, events=0, no-show-all=FALSE, has-tooltip=FALSE, tooltip-markup=NULL, tooltip-text=NULL, window, double-buffered=TRUE, halign=GTK_ALIGN_FILL, valign=GTK_ALIGN_FILL, margin-left=0, margin-right=0, margin-top=0, margin-bottom=0, margin=0, hexpand=FALSE, vexpand=FALSE, hexpand-set=FALSE, vexpand-set=FALSE, expand=FALSE, border-width=0, resize-mode=GTK_RESIZE_PARENT, child, label=&quot;Press me&quot;, image, relief=GTK_RELIEF_NORMAL, use-underline=TRUE, use-stock=FALSE, focus-on-click=TRUE, xalign=0.500000, yalign=0.500000, image-position=GTK_POS_LEFT, ) was clicked!</code></pre><p>That&#39;s quite a lot of output; let&#39;s just print the label of the button:</p><pre><code class="language-julia hljs">id2 = signal_connect(b, &quot;clicked&quot;) do widget
    println(&quot;\&quot;&quot;, get_gtk_property(widget,:label,String), &quot;\&quot; was clicked!&quot;)
end</code></pre><p>Now you get something like this:</p><pre><code class="nohighlight hljs">julia&gt; GtkButton(action-name=NULL, action-target, related-action, use-action-appearance=TRUE, name=&quot;&quot;, parent, width-request=-1, height-request=-1, visible=TRUE, sensitive=TRUE, app-paintable=FALSE, can-focus=TRUE, has-focus=TRUE, is-focus=TRUE, can-default=FALSE, has-default=FALSE, receives-default=TRUE, composite-child=FALSE, style, events=0, no-show-all=FALSE, has-tooltip=FALSE, tooltip-markup=NULL, tooltip-text=NULL, window, double-buffered=TRUE, halign=GTK_ALIGN_FILL, valign=GTK_ALIGN_FILL, margin-left=0, margin-right=0, margin-top=0, margin-bottom=0, margin=0, hexpand=FALSE, vexpand=FALSE, hexpand-set=FALSE, vexpand-set=FALSE, expand=FALSE, border-width=0, resize-mode=GTK_RESIZE_PARENT, child, label=&quot;Press me&quot;, image, relief=GTK_RELIEF_NORMAL, use-underline=TRUE, use-stock=FALSE, focus-on-click=TRUE, xalign=0.500000, yalign=0.500000, image-position=GTK_POS_LEFT, ) was clicked!
&quot;Press me&quot; was clicked!</code></pre><p>Notice that <em>both</em> of the callback functions executed! GTK allows you to define multiple signal handlers for a given object; even the execution order can be <a href="https://docs.gtk.org/gobject/concepts.html#signals">specified</a>. Callbacks for some <a href="https://docs.gtk.org/gtk4/signal.Widget.query-tooltip.html">signals</a> require that you return an <code>Int32</code>, with value 0 if you want the next handler to run or 1 if you want to prevent any other handlers from running on this event.</p><p>The <a href="https://docs.gtk.org/gtk4/signal.Button.clicked.html"><code>&quot;clicked&quot;</code> signal callback</a> should return <code>nothing</code> (<code>void</code> in C parlance), so you can&#39;t prevent other callbacks from running. However, we can disconnect the first signal handler:</p><pre><code class="language-julia hljs">signal_handler_disconnect(b, id)</code></pre><p>Now clicking on the button just yields</p><pre><code class="language-julia hljs">julia&gt; &quot;Press me&quot; was clicked!</code></pre><p>Alternatively, you can temporarily enable or disable individual handlers with <code>signal_handler_block</code> and <code>signal_handler_unblock</code>.</p><p>The arguments of the callback depend on the signal type. Arguments and their meaning are described along with their corresponding signals. <strong>You should omit the final <code>user_data</code> argument described in the GTK documentation</strong>; keep in mind that you can always address other variables from inside your function block, or define the callback in terms of an anonymous function:</p><pre><code class="language-julia hljs">id = signal_connect((widget, event) -&gt; cb_buttonpressed(widget, event, guistate, drawfunction, ...), b, &quot;button-press-event&quot;)</code></pre><h2 id="Property-notifications"><a class="docs-heading-anchor" href="#Property-notifications">Property notifications</a><a id="Property-notifications-1"></a><a class="docs-heading-anchor-permalink" href="#Property-notifications" title="Permalink"></a></h2><p>Any time a GObject <a href="../properties/">property</a> is changed, a <a href="https://docs.gtk.org/gobject/signal.Object.notify.html">&quot;notify&quot; signal</a> is emitted.</p><p>To set a callback to be called when a window&#39;s title is changed, use:</p><pre><code class="language-julia hljs">signal_connect(win, &quot;notify::title&quot;) do obj, pspec    # here `obj` is the GObject
    println(obj.title)
end</code></pre><h2 id="Alternative-approach-to-signals-and-signal-handlers"><a class="docs-heading-anchor" href="#Alternative-approach-to-signals-and-signal-handlers">Alternative approach to signals and signal handlers</a><a id="Alternative-approach-to-signals-and-signal-handlers-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-approach-to-signals-and-signal-handlers" title="Permalink"></a></h2><p>In addition to the &quot;simple&quot; interface described above, Gtk4 includes an approach that allows your callback function to be directly compiled to machine code. Gtk4 makes this easier by using GObject introspection data to look up the return type and parameter types, saving the user the hassle of doing this themselves.</p><p>For the &quot;clicked&quot; signal of a <code>GtkButton</code>, the equivalent to the example at the beginning of this page is as follows:</p><pre><code class="language-julia hljs">b = GtkButton(&quot;Press me&quot;)
win = GtkWindow(b, &quot;Callbacks&quot;)
function button_cb(::Ptr, b)
    println(b, &quot; was clicked!&quot;)
end

on_clicked(cb, b)</code></pre><p>Note that the main difference here, other than the name of the function being called to connect the signal, is the argument list of the callback. The first argument here is always a pointer to the GObject that sends the signal, which in this case is the <code>GtkButton</code>.</p><p>The full definition of the function <code>on_clicked</code> is</p><pre><code class="language-julia hljs">on_clicked(cb::Function, widget::GtkButton, user_data = widget, after = false)</code></pre><p>where:</p><ul><li><code>cb</code> is your callback function. This will be compiled with <code>@cfunction</code>, and you need to follow its rules. In particular, you should use a generic function (i.e., one defined as <code>function foo(x,y,z) ... end</code>), and the arguments and return type should match the GTK+ documentation for the widget and signal (<a href="https://docs.gtk.org/gtk4/signal.Widget.query-tooltip.html">see examples</a>). <strong>In contrast with the simpler interface, when writing these callbacks you must include the <code>user_data</code> argument</strong>.  See examples below.</li><li><code>widget</code> is the widget that will send the signal</li><li><code>user_data</code> contains any additional information your callback needs to operate.  For example, you can pass other widgets, tuples of values, etc.  If omitted (as it was in the example above), it defaults to <code>widget</code>.</li><li><code>after</code> is a boolean, <code>true</code> if you want your callback to run after the default handler for your signal. When in doubt, specify <code>false</code>.</li></ul><p>Functions like this are defined for every signal of every widget supported by Gtk4.jl. They are named <code>on_signalname</code>, where signals with <code>-</code> in their names have them replaced by underscores <code>_</code>. So to connect to <code>GtkWindow</code>&#39;s &quot;close-request&quot; signal, you would use <code>on_close_request</code>.</p><p>When you define the callback, you still have to use the correct argument list or else the call to <code>@cfunction</code> will throw an error. It should be <code>Ptr{GObject}</code>, <code>param_types...</code>, <code>user_data</code>. The callback should also return the right type. Functions <code>signal_return_type(WidgetType, signame)</code> and <code>signal_argument_types(WidgetType, signame)</code> are defined that return the needed types for the signal &quot;signame&quot; of the type &quot;WidgetType&quot;.</p><p>For example, consider a GUI in which pressing a button updates a counter:</p><pre><code class="language-julia hljs">box = GtkBox(:h)
button = GtkButton(&quot;click me&quot;)
label  = GtkLabel(&quot;0&quot;)
push!(box, button)
push!(box, label)
win = GtkWindow(box, &quot;Callbacks&quot;)

const counter = [0]  # Pack counter value inside array to make it a reference

# &quot;clicked&quot; callback declaration is
#     void user_function(GtkButton *button, gpointer user_data)
# But user_data gets converted into a Julia object automatically
function button_cb(widgetptr::Ptr, user_data)
     widget = convert(Gtk4.GtkButtonLeaf, widgetptr)  # pointer -&gt; object
     lbl, cntr = user_data                # unpack the user_data tuple
     cntr[] = cntr[]+1                    # increment counter[1]
     lbl.label = string(cntr[])
     nothing                              # return type is void
end

on_clicked(button_cb, button, (label, counter))</code></pre><p>Here, the tuple <code>(label, counter)</code> was passed in as <code>user_data</code>. Note that the value of <code>counter[]</code> matches the display in the GUI.</p><h3 id="@guarded"><a class="docs-heading-anchor" href="#@guarded"><code>@guarded</code></a><a id="@guarded-1"></a><a class="docs-heading-anchor-permalink" href="#@guarded" title="Permalink"></a></h3><p>The &quot;simple&quot; callback interface includes protections against corrupting Gtk state from errors, but this <code>@cfunction</code>-based approach does not. Consequently, you may wish to use <code>@guarded</code> when writing these functions. (<a href="../canvas/">Canvas</a> draw functions and mouse event-handling are called through this interface, which is why you should use <code>@guarded</code> there.) For functions that should return a value, you can specify the value to be returned on error as the first argument. For example:</p><pre><code class="language-julia hljs">    const unhandled = convert(Int32, false)
    @guarded unhandled function my_callback(widgetptr, ...)
        ...
    end</code></pre><h3 id="Old-approach-to-@cfunction-based-signals"><a class="docs-heading-anchor" href="#Old-approach-to-@cfunction-based-signals">Old approach to @cfunction based signals</a><a id="Old-approach-to-@cfunction-based-signals-1"></a><a class="docs-heading-anchor-permalink" href="#Old-approach-to-@cfunction-based-signals" title="Permalink"></a></h3><p>The approach taken by Gtk.jl and earlier versions of Gtk4.jl is still supported, where you supply the return type and parameter types:</p><pre><code class="language-julia hljs">signal_connect(cb, widget, signalname, return_type, parameter_type_tuple, after, user_data=widget)</code></pre><p>where:</p><ul><li><code>cb</code> is your callback function. This will be compiled with <code>@cfunction</code>, and you need to follow its rules. In particular, you should use a generic function (i.e., one defined as <code>function foo(x,y,z) ... end</code>), and the arguments and return type should match the GTK+ documentation for the widget and signal (<a href="https://docs.gtk.org/gtk4/signal.Widget.query-tooltip.html">see examples</a>). <strong>In contrast with the simpler interface, when writing these callbacks you must include the <code>user_data</code> argument</strong>.  See examples below.</li><li><code>widget</code> is the widget that will send the signal</li><li><code>signalname</code> is a string or symbol identifying the signal, e.g., <code>&quot;clicked&quot;</code> or <code>&quot;button-press-event&quot;</code></li><li><code>return_type</code> is the type of the value returned by your callback. Usually <code>Nothing</code> (for <code>void</code>) or <code>Cint</code> (for <code>gboolean</code>)</li><li><code>parameter_type_tuple</code> specifies the types of the <em>middle</em> arguments to the callback function, omitting the first (the widget) and last (<code>user_data</code>).  For example, for <a href="https://docs.gtk.org/gtk4/signal.Button.clicked.html"><code>&quot;clicked&quot;</code></a> we have <code>parameter_type_tuple = ()</code> (because there are no middle arguments) and for <a href="https://docs.gtk.org/gtk4/signal.GestureClick.pressed.html"><code>&quot;button-press-event&quot;</code></a> we have <code>parameter_type_tuple = (Cint, Cdouble, Cdouble)</code>.</li><li><code>after</code> is a boolean, <code>true</code> if you want your callback to run after the default handler for your signal. When in doubt, specify <code>false</code>.</li><li><code>user_data</code> contains any additional information your callback needs to operate.  For example, you can pass other widgets, tuples of values, etc.  If omitted, it defaults to <code>widget</code>.</li></ul><p>The callback&#39;s arguments need to match the GTK documentation, with the exception of the <code>user_data</code> argument. (Rather than being a pointer, <code>user_data</code> will automatically be converted back to an object.)</p><p>For example, consider a GUI in which pressing a button updates a counter:</p><pre><code class="language-julia hljs">box = GtkBox(:h)
button = GtkButton(&quot;click me&quot;)
label  = GtkLabel(&quot;0&quot;)
push!(box, button)
push!(box, label)
win = GtkWindow(box, &quot;Callbacks&quot;)

const counter = [0]  # Pack counter value inside array to make it a reference

# &quot;clicked&quot; callback declaration is
#     void user_function(GtkButton *button, gpointer user_data)
# But user_data gets converted into a Julia object automatically
function button_cb(widgetptr::Ptr, user_data)
     widget = convert(Gtk4.GtkButtonLeaf, widgetptr)  # pointer -&gt; object
     lbl, cntr = user_data                # unpack the user_data tuple
     cntr[] = cntr[]+1                    # increment counter[1]
     lbl.label = string(cntr[])
     nothing                              # return type is void
end

signal_connect(button_cb, button, &quot;clicked&quot;, Nothing, (), false, (label, counter))</code></pre><p>You should note that the value of <code>counter[]</code> matches the display in the GUI.</p><h3 id="Specifying-the-event-type"><a class="docs-heading-anchor" href="#Specifying-the-event-type">Specifying the event type</a><a id="Specifying-the-event-type-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-the-event-type" title="Permalink"></a></h3><p>If your callback function takes an <code>event</code> argument, it is important to declare its type correctly. An easy way to do that is to first write a callback using the &quot;simple&quot; interface, e.g.,</p><pre><code class="language-julia hljs">    signal_connect(win, &quot;delete-event&quot;) do widget, event
        @show typeof(event)
        @show event
    end</code></pre><p>and then use the reported type in <code>parameter_type_tuple</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../layout/">« Layout</a><a class="docs-footer-nextpage" href="../builder/">Builder »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 20 September 2024 21:06">Friday 20 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
